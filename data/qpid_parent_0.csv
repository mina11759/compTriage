Issue Type,Issue key,Issue id,title,Assignee,Reporter,Status,Resolution,Updated,top_component,Component/s,Component/s,Component/s,Component/s,Component/s,Component/s,Component/s,description
Bug,QPID-3132,12500873,Threshold alert on a queue used to receive alerts causes broker crash,gsim,gsim,Closed,Fixed,2017-03-14 20:08,C++,C++ Broker,,,,,,,"If a queue bound to the QMF exchange for receiving events reaches a configured threhold and generates an alert, the alert will result in an infinite recursion where the message for the event is enqueued triggering a further event etc etc"
Bug,QPID-6568,12835121,[amqp1.0] bump the minimum required proton version to 0.7,kgiusti,kgiusti,Closed,Fixed,2016-09-08 10:25,C++,C++ Broker,,,,,,,"Recent testing of qpidd against proton 0.6 for QPID-6563 shows a leak of session objects on long lived connections.

Upgrading the proton library to 0.7+ resolved the problem. "
Bug,QPID-6790,12904918,qpidd crashes in the interop_tests unit test.,kgiusti,kgiusti,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"Crashes consistently on certain systems, like RHEL6 or Fedora 21.  Appears to be a race that leaves stale pointers to pn_delivery_t objects after a link has been closed.

delivery passed to pni_add_tpwork has a null link ptr.  likely that the delivery has already been freed.

Backtrace:

Thread 1 (Thread 0x7fb832b44700 (LWP 15941)):
#0  0x00007fb838f34c65 in pni_add_tpwork (delivery=0x7fb80c046290) at /home/chug/git/qpid-proton/proton-c/src/engine/engine.c:704
#1  0x00007fb838f38359 in pn_delivery_update (delivery=0x7fb80c046290, state=36) at /home/chug/git/qpid-proton/proton-c/src/engine/engine.c:1981
---Type <return> to continue, or q <return> to quit---
#2  0x00007fb839269e41 in qpid::broker::amqp::Session::accepted (this=0x7fb80c00f470, delivery=0x7fb80c046290, sync=true)
    at /home/chug/git/qpid/qpid/cpp/src/qpid/broker/amqp/Session.cpp:621
#3  0x00007fb83926a72b in qpid::broker::amqp::Session::dispatch (this=0x7fb80c00f470) at /home/chug/git/qpid/qpid/cpp/src/qpid/broker/amqp/Session.cpp:693
#4  0x00007fb839211927 in qpid::broker::amqp::Connection::dispatch (this=0x7fb80c0108a8) at /home/chug/git/qpid/qpid/cpp/src/qpid/broker/amqp/Connection.cpp:286
#5  0x00007fb839211a3c in qpid::broker::amqp::Connection::canEncode (this=0x7fb80c0108a8) at /home/chug/git/qpid/qpid/cpp/src/qpid/broker/amqp/Connection.cpp:301
#6  0x00007fb83925fa24 in qpid::broker::amqp::Sasl::canEncode (this=0x7fb80c010840) at /home/chug/git/qpid/qpid/cpp/src/qpid/broker/amqp/Sasl.cpp:94
#7  0x00007fb83cb4d170 in qpid::sys::AsynchIOHandler::idle (this=0x7fb80c032a00) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp:215
#8  0x00007fb83d397e88 in boost::_mfi::mf1<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&>::operator() (this=0x7fb80c0447d0, p=0x7fb80c032a00, a1=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:165
#9  0x00007fb83d396bb1 in boost::_bi::list2<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&>, boost::_bi::list1<qpid::sys::AsynchIO&> > (this=0x7fb80c0447e0, f=..., a=...) at /usr/include/boost/bind/bind.hpp:313
#10 0x00007fb83d396060 in boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&>, boost::_bi::list2<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1> > >::operator()<qpid::sys::AsynchIO> (this=0x7fb80c0447d0, a1=...) at /usr/include/boost/bind/bind_template.hpp:32
#11 0x00007fb83d395412 in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&>, boost::_bi::list2<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1> > >, void, qpid::sys::AsynchIO&>::invoke (function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:153
#12 0x00007fb83caae137 in boost::function1<void, qpid::sys::AsynchIO&>::operator() (this=0x7fb80c0447c8, a0=...) at /usr/include/boost/function/function_template.hpp:767
#13 0x00007fb83caabd90 in qpid::sys::posix::AsynchIO::writeable (this=0x7fb80c0445d0, h=...) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp:582
#14 0x00007fb83cab31d4 in boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>::operator() (this=0x7fb80c044610, p=0x7fb80c0445d0, a1=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:165
#15 0x00007fb83cab2507 in boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> > (this=0x7fb80c044620, f=..., a=...) at /usr/include/boost/bind/bind.hpp:313
#16 0x00007fb83cab17d4 in boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >::operator()<qpid::sys::DispatchHandle> (this=0x7fb80c044610, a1=...) at /usr/include/boost/bind/bind_template.hpp:32
#17 0x00007fb83cab07da in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke (function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:153
#18 0x00007fb83cb500e3 in boost::function1<void, qpid::sys::DispatchHandle&>::operator() (this=0x7fb80c044608, a0=...) at /usr/include/boost/function/function_template.hpp:767
#19 0x00007fb83cb4f765 in qpid::sys::DispatchHandle::processEvent (this=0x7fb80c0445d8, type=qpid::sys::Poller::WRITABLE)
    at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/DispatchHandle.cpp:283
#20 0x00007fb83cad509a in qpid::sys::Poller::Event::process (this=0x7fb832b43cb0) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/Poller.h:131
#21 0x00007fb83cad4480 in qpid::sys::Poller::run (this=0x232c420) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/epoll/EpollPoller.cpp:522
#22 0x00007fb83cb4e473 in qpid::sys::Dispatcher::run (this=0x7ffcb83a9ae0) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/Dispatcher.cpp:37
#23 0x00007fb83cac87cd in qpid::sys::(anonymous namespace)::runRunnable (p=0x7ffcb83a9ae0) at /home/chug/git/qpid/qpid/cpp/src/qpid/sys/posix/Thread.cpp:35
#24 0x00007fb83be5852a in start_thread () from /lib64/libpthread.so.0
#25 0x00007fb83bb9422d in clone () from /lib64/libc.so.6"
Bug,QPID-5590,12698116,It is trivially easy to fatally crash qpidd using a dodgy exchange type in a TopicPolicy,gsim,fadams,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"It is trivially easy to fatally crash qpidd using a dodgy exchange type in a TopicPolicy

Steps to reproduce:
1) Start up qpidd
2) Create a TopicPolicy
qpid-config add TopicPolicy header-exchange-* --argument exchange-type=foo
3) Attempt to create a matching node
./drain --connection-options {protocol:amqp1.0} -b localhost -f ""header-exchange-test""

qpidd dies saying
""terminate called after throwing an instance of 'qpid::broker::UnknownExchangeTypeException'
Aborted""

It's probably not likely that someone would use ""exchange-type=foo"" but I stumbled across this problem 'cause I accidentally did ""exchange-type=amq.match"" when I meant to use headers, that sort of finger trouble is *reasonably* likely and probably shouldn't be causing a fatal crash.

At a guess the best approach might be to do a check on the QMF create TopicPolicy and check a valid exchange type has been specified there, but it's probably safest to also check when resolving link attachment and send the exception back to the client.
"
Bug,QPID-5646,12703761,Can't build against any released version of proton,astitcher,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,"as a result of changes for QPID-5631.

Both trunk and beta need to be able to build against a released version of proton."
Bug,QPID-5488,12689352,Apparent corruption of SSL connection,astitcher,jross,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,ssl_test fails.  See attached output for details.
Bug,QPID-5129,12668054,Legacy store fails to compile on ARM due to alignment issues,astitcher,mcpierce,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"When compiling on ARM (ARM hfp) the following occurs:
{noformat}
[ 85%] Building CXX object src/CMakeFiles/legacystore.dir/qpid/legacystore/jrnl/deq_rec.o
cd /builddir/build/BUILD/qpid-0.24/cpp/src && /usr/bin/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -D_IN_QPID_BROKER -Dlegacystore_EXPORTS -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard  -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -fPIC -I/builddir/build/BUILD/qpid-0.24/cpp/src -I/builddir/build/BUILD/qpid-0.24/cpp/src/../include -I/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/legacystore    -pthread -o CMakeFiles/legacystore.dir/qpid/legacystore/jrnl/deq_rec.o -c /builddir/build/BUILD/qpid-0.24/cpp/src/qpid/legacystore/jrnl/deq_rec.cpp
/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/legacystore/jrnl/deq_rec.cpp: In member function 'virtual u_int32_t mrg::journal::deq_rec::decode(mrg::journal::rec_hdr&, void*, u_int32_t, u_int32_t)':
/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/legacystore/jrnl/deq_rec.cpp:273:63: error: cast from 'char*' to 'u_int64_t* {aka long long unsigned int*}' increases required alignment of target type [-Werror=cast-align]
         _deq_hdr._deq_rid = *(u_int64_t*)((char*)rptr + rd_cnt);
                                                               ^
/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/legacystore/jrnl/deq_rec.cpp:278:65: error: cast from 'char*' to 'std::size_t* {aka unsigned int*}' increases required alignment of target type [-Werror=cast-align]
         _deq_hdr._xidsize = *(std::size_t*)((char*)rptr + rd_cnt);
                                                                 ^
cc1plus: all warnings being treated as errors
make[2]: Leaving directory `/builddir/build/BUILD/qpid-0.24/cpp'
make[2]: *** [src/CMakeFiles/legacystore.dir/qpid/legacystore/jrnl/deq_rec.o] Error 1
make[1]: *** [src/CMakeFiles/legacystore.dir/all] Error 2
{noformat}"
Bug,QPID-5445,12686235,Make install writes to OS-reserved location despite setting prefix,mcpierce,jross,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"The qmfgen install ignores the install prefix.  An unprivileged install will fail:

http://people.apache.org/~jross/qpid-cpp-0.26-rc2-make-install-to-prefix.txt

Worse, a privileged install can overwrite system-installed code."
Bug,QPID-4907,12650887,qpid-tool displays duplicate entries for objects managed by the broker.,kgiusti,kgiusti,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Tools,QMF,,,,,"qpid-tool displays two entries for each object managed by the broker.

Example:

$ qpid-config add queue KEN-Q
$ qpid-tool

Management Tool for QPID
qpid: list queue
Object Summary:
    ID   Created   Destroyed  Index
    ============================================================
    141  14:19:42  -          169.KEN-Q
<SNIP>
    156  14:19:42  -          org.apache.qpid.broker:queue:KEN-Q
<SNIP>
qpid: "
Bug,QPID-5439,12685716,[AMQP 1.0 JMS client] Client hangs during connection.close(),,uromahn,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,JMS AMQP 0-x,,,,,,"I am connecting to a cpp broker via the amqp-1-0-client-jms client and send 1000 simple text messages to a queue on the broker. After that, I am opening a second session to receive those 1000 messages.
When trying to close the connection (calling connection.close()), the client ""hangs"". When I look at the broker (qpid-tool, list connection) I am still seeing this connection open.
Debugging through the code, shows that there is a lock in the class org.apache.qpid.amqp_1_0.client.Sender at the following code in method close():
...
        _session.removeSender(this);
        _endpoint.setSource(null);
        _endpoint.detach();
        _closed = true;

        synchronized(_endpoint.getLock())
        {
            while(!_endpoint.isDetached())
            {
                try
                {
                    _endpoint.getLock().wait();
                }
                catch (InterruptedException e)
                {
                    throw new SenderClosingException(e);
                }
            }
        }

It actually seems to hang at the line "" _endpoint.getLock().wait(); ""
NOTE: the exact same code works when running against a Java broker 0.24."
Bug,QPID-4883,12649195,C++ Broker may crash if client provides SSL certificate without CommonName entry.,kgiusti,kgiusti,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Broker does not check for a null pointer return value from the Certificate parsing routines.
"
Bug,QPID-4950,12654930,"Exchange statistics byteReceives, byteDrops, byteRoutes do not increment.",gsim,kgiusti,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,Found by Fraser Adams.
Bug,QPID-5055,12662599,paged queues count of loaded pages is not initialised,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,Meaning it is the luck of the draw as to whether it actually enforces the maximum loaded page count.
Bug,QPID-2674,12467117,heartbeats can cause seg faults under tcp on linux,astitcher,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"If there is a queued callback that is processed during a writeable
event (or read-writeable) the writeable callback, i.e. AsynchIO::writeable(), takes the path through
line 536 of AsyncIO.cpp, then AsynchIOHandler::closedSocket() is called
which deletes the AsynchIOHandler instance, the thread then goes on to process the callbacks in DipatchHandle, which invoke on the now deleted AsynchIOHandler.

Results in cores like:

Core was generated by `/home/gordon/qpid/cpp/build/src/.libs/lt-qpidd
--load-module /home/gordon/qpid/'.
Program terminated with signal 11, Segmentation fault.
[New process 9483]
[New process 9516]
[New process 9490]
[New process 9489]
[New process 9488]
[New process 9487]
[New process 9486]
[New process 9484]
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
194     if (codec) codec->closed();
(gdb) bt
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
#1  0x00002aaefd5e9c29 in qpid::sys::AsynchIOHandler::eof (this=0x2aaab1b330c0,
a=@0x1a8778a0) at ../../src/qpid/sys/AsynchIOHandler.cpp:177
#2  0x00002aaefd51ccbf in boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#3  0x00002aaefd51c873 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, boost::function1<void,
qpid::sys::AsynchIO&, std::allocator<boost::function_base> > >,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::_bi::value<boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> > > > >, void,
qpid::sys::DispatchHandle&>::invoke (function_obj_ptr=<value optimized out>,
a0=<value optimized out>) at /usr/include/boost/bind/mem_fn_template.hpp:149
#4  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#5  0x00002aaefd5ed2b6 in qpid::sys::DispatchHandle::processEvent
(this=0x1a8778a8, type=qpid::sys::Poller::READ_WRITABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:309
#6  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#7  0x00002aaefd0844e4 in qpid::broker::Broker::run (this=<value optimized
out>) at ../../src/qpid/broker/Broker.cpp:339
#8  0x0000000000409014 in QpiddDaemon::child (this=0x7fff989850d0) at
../../src/posix/QpiddBroker.cpp:130
#9  0x00002aaefd0a482f in qpid::broker::Daemon::fork (this=0x7fff989850d0) at
../../src/qpid/broker/Daemon.cpp:91
#10 0x0000000000407585 in QpiddBroker::execute (this=<value optimized out>,
options=<value optimized out>) at ../../src/posix/QpiddBroker.cpp:168
#11 0x00000000004057ff in main (argc=12, argv=0x7fff989856b8) at
../../src/qpidd.cpp:80
(gdb) print codec
$1 = (class qpid::sys::ConnectionCodec *) 0x2aaab1b330c0
(gdb) thread apply all bt

Thread 8 (process 9484):
#0  0x00000038f9c92149 in strftime_l () from /lib64/libc.so.6
#1  0x00002aaefd51f111 in qpid::sys::outputFormattedNow (o=@0x413214b0) at
../../src/qpid/sys/posix/Time.cpp:89
#2  0x00002aaefd5da5a1 in qpid::log::Logger::log (this=0x2aaefd895680,
s=@0x2aaefd894d80, msg=@0x41321770) at ../../src/qpid/log/Logger.cpp:77
#3  0x00002aaefd5dfa9c in qpid::log::Statement::log (this=0x2aaefd894d80,
message=@0x41321f90) at ../../src/qpid/log/Statement.cpp:57
#4  0x00002aaefd5f3b4b in qpid::sys::Timer::run (this=0x19b59b40) at
../../src/qpid/sys/Timer.cpp:129
#5  0x00002aaefd51f14a in runRunnable (p=0x413213f0) at
../../src/qpid/sys/posix/Thread.cpp:35
#6  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#7  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 7 (process 9486):
#0  0x00000038fa40ad09 in pthread_cond_wait@@GLIBC_2.3.2 () from
/lib64/libpthread.so.0
#1  0x00002aaefd5f3b73 in qpid::sys::Timer::run (this=0x19b5f490) at
../../include/qpid/sys/posix/Condition.h:63
#2  0x00002aaefd51f14a in runRunnable (p=0x19b5f4c4) at
../../src/qpid/sys/posix/Thread.cpp:35
#3  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#4  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 6 (process 9487):
#0  0x00000038f9cd4018 in epoll_wait () from /lib64/libc.so.6
#1  0x00002aaefd526343 in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:570
#2  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#3  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#4  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#5  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 5 (process 9488):
#0  0x00000038f9cd3f9a in epoll_ctl () from /lib64/libc.so.6
#1  0x00002aaefd525fd7 in qpid::sys::PollerPrivate::resetMode (this=0x19b593a0,
eh=@0x2aaab4090920) at ../../src/qpid/sys/epoll/EpollPoller.cpp:389
#2  0x00002aaefd52624d in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:558
#3  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#4  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#5  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#6  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 4 (process 9489):
#0  0x00000038f9cd447b in accept () from /lib64/libc.so.6
#1  0x00002aaefd511ca4 in qpid::sys::Socket::accept (this=<value optimized
out>) at ../../src/qpid/sys/posix/Socket.cpp:215
#2  0x00002aaefd51a085 in qpid::sys::posix::AsynchAcceptor::readable
(this=0x19b634b0, h=@0x19b634d0) at ../../src/qpid/sys/posix/AsynchIO.cpp:121
#3  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x157, a0=@0x0)
    at /usr/include/boost/function/function_template.hpp:576
---Type <return> to continue, or q <return> to quit---
#4  0x00002aaefd5ed1f9 in qpid::sys::DispatchHandle::processEvent
(this=0x19b634d0, type=qpid::sys::Poller::READABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:278
#5  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#6  0x00002aaefd51f14a in runRunnable (p=0x13) at
../../src/qpid/sys/posix/Thread.cpp:35
#7  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#8  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 3 (process 9490):
#0  0x00000038f9cd3f9a in epoll_ctl () from /lib64/libc.so.6
#1  0x00002aaefd525fd7 in qpid::sys::PollerPrivate::resetMode (this=0x19b593a0,
eh=@0x2aaab40dc910) at ../../src/qpid/sys/epoll/EpollPoller.cpp:389
#2  0x00002aaefd52624d in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:558
#3  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#4  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#5  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#6  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 2 (process 9516):
#0  0x00000038f9cd4018 in epoll_wait () from /lib64/libc.so.6
#1  0x00002aaefd526343 in qpid::sys::Poller::wait (this=0x19b65e60,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:570
#2  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b65e60) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#3  0x00002aaefd51f14a in runRunnable (p=0x14) at
../../src/qpid/sys/posix/Thread.cpp:35
#4  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#5  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 1 (process 9483):
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
#1  0x00002aaefd5e9c29 in qpid::sys::AsynchIOHandler::eof (this=0x2aaab1b330c0,
a=@0x1a8778a0) at ../../src/qpid/sys/AsynchIOHandler.cpp:177
#2  0x00002aaefd51ccbf in boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#3  0x00002aaefd51c873 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, boost::function1<void,
qpid::sys::AsynchIO&, std::allocator<boost::function_base> > >,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::_bi::value<boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> > > > >, void,
qpid::sys::DispatchHandle&>::invoke (function_obj_ptr=<value optimized out>,
a0=<value optimized out>) at /usr/include/boost/bind/mem_fn_template.hpp:149
#4  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#5  0x00002aaefd5ed2b6 in qpid::sys::DispatchHandle::processEvent
(this=0x1a8778a8, type=qpid::sys::Poller::READ_WRITABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:309
#6  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#7  0x00002aaefd0844e4 in qpid::broker::Broker::run (this=<value optimized
out>) at ../../src/qpid/broker/Broker.cpp:339
#8  0x0000000000409014 in QpiddDaemon::child (this=0x7fff989850d0) at
../../src/posix/QpiddBroker.cpp:130
#9  0x00002aaefd0a482f in qpid::broker::Daemon::fork (this=0x7fff989850d0) at
../../src/qpid/broker/Daemon.cpp:91
---Type <return> to continue, or q <return> to quit---
#10 0x0000000000407585 in QpiddBroker::execute (this=<value optimized out>,
options=<value optimized out>) at ../../src/posix/QpiddBroker.cpp:168
#11 0x00000000004057ff in main (argc=12, argv=0x7fff989856b8) at
../../src/qpidd.cpp:80
(gdb)    "
Bug,QPID-2086,12435128,intermittent federated cluster hangs since r810591,aconway,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"On revision 810590 I can run federated_cluster_test_with_node_failure in a loop for over 100 iterations without any hangs.

However on revision 810591 the same loop hangs quite easily (generally within 10 runs or so). "
Bug,QPID-3920,12548503,Occasional header corruption observed in federated system,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"While repeatedly running the federated unit tests, a client will receive a message with a corrupt header.  Example:

Running federation tests using brokers on ports 56253 34505 39575 59519
federation.FederationTests.test_dynamic_topic_bounce .................................................................................................................................................. start
  Exception in thread Thread-1:
  Traceback (most recent call last):
    File ""/usr/lib64/python2.7/threading.py"", line 552, in __bootstrap_inner
      self.run()
    File ""/usr/lib64/python2.7/threading.py"", line 505, in run
      self.__target(*self.__args, **self.__kwargs)
    File ""/home/kgiusti/Desktop/work/qpid/git/apache/qpid/build/0.16/src/tests/python/qpid/connection.py"", line 186, in run
      op_dec.write(*seg_dec.read())
    File ""/home/kgiusti/Desktop/work/qpid/git/apache/qpid/build/0.16/src/tests/python/qpid/framing.py"", line 271, in write
      self.op.headers.extend(self.decode_headers(seg.payload))
    File ""/home/kgiusti/Desktop/work/qpid/git/apache/qpid/build/0.16/src/tests/python/qpid/framing.py"", line 303, in decode_headers
      result.append(sc.read_struct32())
    File ""/home/kgiusti/Desktop/work/qpid/git/apache/qpid/build/0.16/src/tests/python/qpid/codec010.py"", line 308, in read_struct32
      cls = COMPOUND[code]
  KeyError: 3192
  
federation.FederationTests.test_dynamic_topic_bounce .................................................................................................................................................. fail"
Bug,QPID-2256,12442894,cluster_test hangs with threads deadlocked on mutex in DeletionManager.,astitcher,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Running cluster_test in a loop will fairly quickly result in a deadlock. The test is blocked waiting for a child broker to exit. The  broker appears deadlocked around a mutex in DeletionManager, here are the stack traces of the deadlocked broker:

Thread 10 (Thread 0x414b2940 (LWP 2351)):
#0  0x0000003da400af70 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x00002af11703c21d in qpid::sys::Condition::wait (this=0x1accd4e0, mutex=@0x1accd4b8, absoluteTime=@0x1acccae0) at ../../cpp/include/qpid/sys/posix/Condition.h:69
#2  0x00002af11703c48b in qpid::sys::Monitor::wait (this=0x1accd4b8, absoluteTime=@0x1acccae0) at ../../cpp/include/qpid/sys/Monitor.h:45
#3  0x00002af1170396ac in qpid::sys::Timer::run (this=0x1accd4b0) at ../../cpp/src/qpid/sys/Timer.cpp:139
#4  0x00002af116f4f7cc in runRunnable (p=0x1accd4b0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#5  0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#6  0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 9 (Thread 0x4217c940 (LWP 2353)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x4217bd70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd4d00)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 8 (Thread 0x42b7d940 (LWP 2354)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x42b7cd70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd6160)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 7 (Thread 0x4357e940 (LWP 2355)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x1acd4bc0) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x4357da30, l=@0x1acd4bc0) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5b162 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::handleAdder::operator() (this=0x4357dad0, ptr=0x1acd4bc0)
    at ../../cpp/src/qpid/sys/DeletionManager.h:128
#6  0x00002af116f5b1d3 in std::for_each<__gnu_cxx::__normal_iterator<qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::ThreadStatus**, std::vector<qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::ThreadStatus*, std::allocator<qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::ThreadStatus*> > >, qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::handleAdder> (__first={_M_current = 0x1acd6410}, __last={_M_current = 0x1acd6458}, __f={handle = {px = 0x4357dad0, pn = {pi_ = 0x1acd6458}}})
    at /usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_algo.h:159
#7  0x00002af116f5b268 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::addHandle (this=0x2af11730c360, h=
        {px = 0x4357db20, pn = {pi_ = 0x2af11730c360}}) at ../../cpp/src/qpid/sys/DeletionManager.h:158
#8  0x00002af116f5b310 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::markForDeletion (handle=0x2aaaac001470) at ../../cpp/src/qpid/sys/DeletionManager.h:63
#9  0x00002af116f550bf in ~PollerHandle (this=0x2aaaac0016b8) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:156
#10 0x00002af117032938 in ~DispatchHandle (this=0x2aaaac0016b8) at ../../cpp/src/qpid/sys/DispatchHandle.cpp:44
#11 0x00002af116f46266 in ~AsynchIO (this=0x2aaaac0016b0) at ../../cpp/src/qpid/sys/posix/AsynchIO.cpp:313
#12 0x00002af11703175f in qpid::sys::DispatchHandle::processEvent (this=0x2aaaac0016b8, type=qpid::sys::Poller::READ_WRITABLE) at ../../cpp/src/qpid/sys/DispatchHandle.cpp:334
#13 0x00002af116f5741d in qpid::sys::Poller::Event::process (this=0x4357deb0) at ../../cpp/src/qpid/sys/Poller.h:123
#14 0x00002af116f56b3e in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:483
#15 0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#16 0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#17 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#18 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 6 (Thread 0x43f7f940 (LWP 2356)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x43f7ed70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd6230)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 5 (Thread 0x44980940 (LWP 2357)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x4497fd70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd62d0)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 4 (Thread 0x45381940 (LWP 2358)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x45380d70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd6320)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 3 (Thread 0x45d82940 (LWP 2360)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x45d81d70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd6370)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 2 (Thread 0x46783940 (LWP 2361)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x46782d70, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd63c0)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af116f4f7cc in runRunnable (p=0x7fff608801d0) at ../../cpp/src/qpid/sys/posix/Thread.cpp:35
#10 0x0000003da4006617 in start_thread () from /lib64/libpthread.so.0
#11 0x0000003da34d3c2d in clone () from /lib64/libc.so.6

Thread 1 (Thread 0x2af11732b940 (LWP 2335)):
#0  0x0000003da400d2e4 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x0000003da4008c55 in _L_lock_1127 () from /lib64/libpthread.so.0
#2  0x0000003da4008b53 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00002af116965181 in qpid::sys::Mutex::lock (this=0x2af11730c360) at ../../cpp/include/qpid/sys/posix/Mutex.h:116
#4  0x00002af1169651e6 in ScopedLock (this=0x7fff6087fe80, l=@0x2af11730c360) at ../../cpp/include/qpid/sys/Mutex.h:33
#5  0x00002af116f5c29a in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::AllThreadsStatuses::delThreadStatus (this=0x2af11730c360, t=0x1acd4bc0)
    at ../../cpp/src/qpid/sys/DeletionManager.h:148
#6  0x00002af116f5c340 in qpid::sys::DeletionManager<qpid::sys::PollerHandlePrivate>::destroyThreadState () at ../../cpp/src/qpid/sys/DeletionManager.h:83
#7  0x00002af116f56b52 in qpid::sys::Poller::run (this=0x1acc9b50) at ../../cpp/src/qpid/sys/epoll/EpollPoller.cpp:488
#8  0x00002af1170379c2 in qpid::sys::Dispatcher::run (this=0x7fff608801d0) at ../../cpp/src/qpid/sys/Dispatcher.cpp:37
#9  0x00002af1169a8684 in qpid::broker::Broker::run (this=0x1accd460) at ../../cpp/src/qpid/broker/Broker.cpp:318
#10 0x000000000040ae56 in QpiddBroker::execute (this=0x7fff6088077f, options=0x1acc6000) at ../../cpp/src/posix/QpiddBroker.cpp:176
#11 0x0000000000409231 in main (argc=13, argv=0x7fff60880a38) at ../../cpp/src/qpidd.cpp:80
"
Bug,QPID-4579,12631962,Fails to build from source with GCC 4.8.0,mcpierce,mcpierce,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The compiler error seen is:

In file included from ./qpid/framing/FrameHandler.h:23:0,
                 from ./qpid/framing/Proxy.h:22,
                 from qpid/framing/Proxy.cpp:19:
./qpid/framing/Handler.h:52:47: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     template <class F> class Functor : public Handler<T> {
                                               ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
./qpid/framing/Handler.h:64:30: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     class MemFunRef : public Handler<T> {
                              ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
cc1plus: all warnings being treated as errors
make[3]: *** [qpid/framing/Proxy.lo] Error 1
In file included from ./qpid/framing/FrameHandler.h:23:0,
                 from ./qpid/framing/InputHandler.h:24,
                 from ./qpid/framing/amqp_framing.h:28,
                 from ./qpid/framing/SendContent.h:22,
                 from qpid/framing/SendContent.cpp:22:
./qpid/framing/Handler.h:52:47: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     template <class F> class Functor : public Handler<T> {
                                               ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
./qpid/framing/Handler.h:64:30: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     class MemFunRef : public Handler<T> {
                              ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^"
Bug,QPID-3338,12513092,qpidxarm CMake target is missing in 0-12,cliffjansen,cliffjansen,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"cpp/src/CMakeLists.txt was altered for mingw builds in QPID-2905 (r1104662).

The qpidxarm target builds the XA distributed transaction resource manager for use with the Microsoft distributed trasanction coordinator.  It was targeted for Windows builds only, using the CMake variable ""WIN32"".

This variable was changed to ""_MSC_VER"" for QPID-2905, presumably to indicate that the build target should only apply to builds using the Microsoft compiler, and not mingw.  Unfortunately ""_MSC_VER"" is not a recognized CMAKE variable and the qpidxarm target is never generated.

The CMake documentation indicates the the variable ""MSVC"" should be used to indicate The Microsoft compiler compared to mingw.
"
Bug,QPID-3586,12530360,Changes for QPID-3464 break cmake build in tar.gz distribution,astitcher,astitcher,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,The changes to the cmake build system in QPID-3464 added some new cmake build files however they weren't added to the autotools list of files to distribute. As it's autotools that creates the .tar.gz this means that the distribution doesn't have all teh files for the cmake build.
Bug,QPID-3522,12525817,SASL EXTERNAL mechanism no longer works,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Seems to be as a result of QPID-3393 (i.e. regression since 0.12) which was a fix for CRAM-MD5. From a simplistic point of view it seems like the CRAM-MD5 mechanism requires an empty response string to be treated as null, whereas for the EXTERNAL mechanism  an empty response should be treated as a zero length string. It may be though that there is more to this than that."
Bug,QPID-2290,12443638,Unauthorised-access exception raised when sending message from JMS on connection authenticated using PLAIN mechanism ,rajith,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Email from prattrs@adobe.com on user list states: 

> when I enable auth=yes, I get the following:
> 
> 2009-12-16 18:33:18 error qpid/amqp_0_10/SessionHandler.cpp:97: Execution exception: unauthorized-access: authorised user id : prattrs@QPID but user id in message decla
> red as prattrs (qpid/broker/SemanticState.cpp:435)

I believe this is a result of the change brought in by r819819 to address QPID-2129."
Bug,QPID-4424,12615029,C++ Broker on Windows - Assertion Failed: !dispatcher - PollableQueue.h line 136,shuston,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Start broker with 'qpidd --auth no --no-data-dir'.
Sit for 15 or so seconds. No external connections from clients. No cluster.
Assert happens.
Stack at assert time:

 	msvcr100d.dll!_NMSG_WRITE(int rterrnum=10)  Line 217	C
 	msvcr100d.dll!abort()  Line 61 + 0x7 bytes	C
 	msvcr100d.dll!_wassert(const wchar_t * expr=0x5ff25504, const wchar_t * filename=0x5ff25480, unsigned int lineno=136)  Line 153	C
>	qpidbrokerd.dll!qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >::dispatch(qpid::sys::PollableCondition & cond={...})  Line 136 + 0x36 bytes	C++
 	qpidbrokerd.dll!boost::_mfi::mf1<void,qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >,qpid::sys::PollableCondition &>::operator()(qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> > * p=0x00c72b80, qpid::sys::PollableCondition & a1={...})  Line 165 + 0x10 bytes	C++
 	qpidbrokerd.dll!boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> > *>,boost::arg<1> >::operator()<boost::_mfi::mf1<void,qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >,qpid::sys::PollableCondition &>,boost::_bi::list1<qpid::sys::PollableCondition &> >(boost::_bi::type<void> __formal={...}, boost::_mfi::mf1<void,qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >,qpid::sys::PollableCondition &> & f={...}, boost::_bi::list1<qpid::sys::PollableCondition &> & a={...}, boost::_bi::type<void> __formal={...})  Line 314	C++
 	qpidbrokerd.dll!boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >,qpid::sys::PollableCondition &>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> > *>,boost::arg<1> > >::operator()<qpid::sys::PollableCondition>(qpid::sys::PollableCondition & a1={...})  Line 33	C++
 	qpidbrokerd.dll!boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> >,qpid::sys::PollableCondition &>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<std::pair<boost::shared_ptr<qpid::broker::Exchange>,qpid::broker::Message> > *>,boost::arg<1> > >,void,qpid::sys::PollableCondition &>::invoke(boost::detail::function::function_buffer & function_obj_ptr={...}, qpid::sys::PollableCondition & a0={...})  Line 154	C++
 	qpidcommond.dll!boost::function1<void,qpid::sys::PollableCondition &>::operator()(qpid::sys::PollableCondition & a0={...})  Line 760 + 0x1a bytes	C++
 	qpidcommond.dll!qpid::sys::PollableConditionPrivate::dispatch(qpid::sys::windows::AsynchIoResult * result=0x00cad6e0)  Line 81	C++
 	qpidcommond.dll!boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>::operator()(qpid::sys::PollableConditionPrivate * p=0x00c72cd0, qpid::sys::windows::AsynchIoResult * a1=0x00cad6e0)  Line 165 + 0x10 bytes	C++
 	qpidcommond.dll!boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> >::operator()<boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list1<qpid::sys::windows::AsynchIoResult * &> >(boost::_bi::type<void> __formal={...}, boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *> & f={...}, boost::_bi::list1<qpid::sys::windows::AsynchIoResult * &> & a={...}, boost::_bi::type<void> __formal={...})  Line 314	C++
 	qpidcommond.dll!boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> > >::operator()<qpid::sys::windows::AsynchIoResult *>(qpid::sys::windows::AsynchIoResult * & a1=0x00cad6e0)  Line 33	C++
 	qpidcommond.dll!boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> > >,void,qpid::sys::windows::AsynchIoResult *>::invoke(boost::detail::function::function_buffer & function_obj_ptr={...}, qpid::sys::windows::AsynchIoResult * a0=0x00cad6e0)  Line 154	C++
 	qpidcommond.dll!boost::function1<void,qpid::sys::windows::AsynchIoResult *>::operator()(qpid::sys::windows::AsynchIoResult * a0=0x00cad6e0)  Line 760 + 0x1a bytes	C++
 	qpidcommond.dll!qpid::sys::windows::AsynchCallbackRequest::complete()  Line 189	C++
 	qpidcommond.dll!qpid::sys::windows::AsynchResult::success(unsigned int bytesTransferred=0)  Line 57 + 0xf bytes	C++
 	qpidcommond.dll!qpid::sys::Poller::wait(qpid::sys::Duration timeout={...})  Line 196 + 0x12 bytes	C++
 	qpidcommond.dll!qpid::sys::Poller::run()  Line 118	C++
 	qpidcommond.dll!qpid::sys::Dispatcher::run()  Line 37 + 0x1d bytes	C++
 	qpidbrokerd.dll!qpid::broker::Broker::run()  Line 429 + 0xb bytes	C++
 	qpidd.exe!qpid::broker::QpiddBroker::execute(qpid::broker::QpiddOptions * options=0x00c5b818)  Line 481 + 0x26 bytes	C++
 	qpidd.exe!qpid::broker::run_broker(int argc=4, char * * argv=0x00c519f8, bool hidden=false)  Line 106 + 0x16 bytes	C++
 	qpidd.exe!main(int argc=4, char * * argv=0x00c519f8)  Line 507 + 0xf bytes	C++
 	qpidd.exe!__tmainCRTStartup()  Line 555 + 0x19 bytes	C
 	qpidd.exe!mainCRTStartup()  Line 371	C
 	kernel32.dll!75d333aa() 	
 	[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]	
 	ntdll.dll!770c9ef2() 	
 	ntdll.dll!770c9ec5() 	
"
Bug,QPID-1835,12424419,C++ qpidbroker.vcproj missing from RC1 kit,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Build,,,,,,The cpp/src/qpidbroker.vcproj file is missing from the RC1 kit. This is required to build the C++ broker.
Bug,QPID-4717,12641069,QMF issue on exchange: update timestamp doesn't seem to be getting updated,tross,fadams,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"I've just noticed an issue with QMF2 statistics on trunk (0.23).

I'm pretty sure it didn't exist in 0.20 and below, but not sure about what's gone off to the 0.22 branch.

The issue is that exchange object update timestamps are not being updated. The objects in question definitely have statistics updates as I'm seeing changes to msgReceives and msgRoutes but each exchange now has an _update_ts that isn't getting updated when the statistics change.

This only seems to be affecting exchange objects, queue and connection objects still seem to be OK.

I noticed this when I pointed the GUI at qpidd 0.23 and tried to look at the graph for qmf.default.direct msgReceives, the graph wasn't updating despite the msgReceives value updating (the graph uses the actual timestamp to derive its x index).

I also tried adding console.log to display exchange._update_ts and I'm getting the same value each object update.

Any idea what might have changed?

I personally think this is a 0.22 blocker. It certainly prevents graphs of exchange statistics being displayed properly.
"
Bug,QPID-1985,12430362,failover_soak test failing,aconway,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"new broker created: pid == 11006 log-prefix == soak-3
soak-1: 2009-07-14 05:43:12 warning Session was not closed cleanly
soak-1: 2009-07-14 05:43:12 warning Session was not closed cleanly
soak-1: 2009-07-14 05:43:12 warning Ignoring frame while closing connection: Frame[BEbe; channel=2; {SessionTimeoutBody: timeout=0; }]
soak-3: 2009-07-14 05:43:12 notice 10.16.43.0:11006(READY) caught up, active cluster member
soak-3: 2009-07-14 05:43:12 error Execution exception: invalid-argument: anonymous.a60597a3-dca1-45d7-b31d-e9c04c9c2783: confirmed < (36146+0) but only sent < (36145+0) (qpid/SessionState.cpp:151)
soak-3: 2009-07-14 05:43:12 error 10.16.43.0:11006(READY/error) channel error 474085 on 10.16.43.0:10880-2(shadow): invalid-argument: anonymous.a60597a3-dca1-45d7-b31d-e9c04c9c2783: confirmed < (36146+0) but only sent < (36145+0) (qpid/SessionState.cpp:151) (unresolved: 10.16.43.0:10880 10.16.43.0:10904 10.16.43.0:11006 )
soak-3: 2009-07-14 05:43:12 critical 10.16.43.0:11006(READY/error) error 474085 did not occur on 10.16.43.0:10904
soak-3: 2009-07-14 05:43:12 error Error delivering frames: Aborted by local failure that did not occur on all replicas
soak-3: 2009-07-14 05:43:12 notice 10.16.43.0:11006(LEFT/error) leaving cluster soakTestCluster_5d4b980b-d086-4610-ad92-b7475a054f3c
soak-3: 2009-07-14 05:43:12 notice Shut down
killFrontBroker: waiting for newbie sync...
wait_for_newbie error: Connection refused: 127.0.0.1:60528 (qpid/sys/posix/Socket.cpp:162)
END_OF_TEST ERROR_BROKER
Invalid argument
lt-qpidd: ./qpid/sys/posix/Mutex.h:116: void qpid::sys::Mutex::lock(): Assertion `0' failed.
/bin/sh: line 4: 10825 Segmentation fault      (core dumped) VALGRIND= srcdir=. top_builddir=../.. QPID_DATA_DIR= ACL_LIB=../.libs/acl.so CLUSTER_LIB=../.libs/cluster.so TEST_STORE_LIB=.libs/test_store.so BOOST_TEST_SHOW_PROGRESS=yes ./run_test ${dir}$tst
FAIL: run_failover_soak"
Bug,QPID-3899,12546483,Grouped messages with expired TTL will cause the broker to crash.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If a message on a grouped message queue has an expired TTL, the broker will crash when de-queuing it.

lt-qpidd: ../../../qpid/cpp/src/qpid/broker/MessageGroupManager.cpp:156: virtual void qpid::broker::MessageGroupManager::dequeued(const qpid::broker::QueuedMessage&): Assertion `state.acquired != 0' failed.
Aborted (core dumped)
"
Bug,QPID-1525,12410405,Missing pure virtual method in Windows AsynchIO.cpp,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,svn rev 724233 added a pure virtual method to qpid/sys/AsynchIO.h which was not added to qpid/sys/windows/AsynchIO.cpp. This causes the common lib compile to fail. Must be fixed for M4.
Bug,QPID-4345,12609110,Windows memory leak,cliffjansen,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,In our large system performance test environments we see Broker memory growth until the process crashes.  This appears to be reproducible simply by opening and closing connections as fast as possible.  Marked as 'Blocker' as it was blocking shipment of our Windows based product - the Broker would exhaust memory and crash itself every few days of operation.
Bug,QPID-2046,12432852,"Closing of a federation link done on management thread, not links own io thread",tross,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"This allows concurrent closingof a connection that may be processing incoming or outgoing frames on another thread. The Link::destory() method should not call connection->close() on the management connections thread but should request the io thread for the link itself and do the close on that.

E.g. The following is from a core dump running reliable_replication_test (which is currently failing reliably):

Core was generated by `/var/lib/ptolemy/sources/qpid/cpp/src/.libs/lt-qpidd --daemon --port 0 --no-dat'.
Program terminated with signal 11, Segmentation fault.
[New process 2138]
[New process 2139]
[New process 2137]
[New process 2136]
[New process 2135]
[New process 2134]
#0  0x00002b81d22cb229 in main_arena () from /lib64/libc.so.6
(gdb) thread apply all bt

Thread 6 (process 2134):
#0  0x00002b81d22db5b5 in pthread_sigmask () from /lib64/libpthread.so.0
#1  0x00002b81d1575a8c in qpid::sys::Poller::wait () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#2  0x00002b81d15763f7 in qpid::sys::Poller::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#3  0x00002b81d110cc36 in qpid::broker::Broker::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#4  0x000000000040916b in QpiddDaemon::child ()
#5  0x00002b81d1125e0e in qpid::broker::Daemon::fork () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#6  0x0000000000406a73 in QpiddBroker::execute ()
#7  0x0000000000405488 in main ()

Thread 5 (process 2135):
#0  0x00002b81d22dab00 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
#1  0x00002b81d16393e2 in qpid::sys::Timer::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#2  0x00002b81d156cc5a in qpid::sys::(anonymous namespace)::runRunnable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#3  0x00002b81d22d6367 in start_thread () from /lib64/libpthread.so.0
#4  0x00002b81d204c09d in clone () from /lib64/libc.so.6

Thread 4 (process 2136):
#0  0x00002b81d2057e5e in __lll_lock_wait_private () from /lib64/libc.so.6
#1  0x00002b81d1fef934 in _L_lock_15421 () from /lib64/libc.so.6
#2  0x00002b81d1fee901 in free () from /lib64/libc.so.6
#3  0x00002b81d1119b15 in qpid::broker::Connection::close ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#4  0x00002b81d1152715 in qpid::broker::Link::destroy () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#5  0x00002b81d1152fa1 in qpid::broker::Link::ManagementMethod ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#6  0x00002b81d10dca04 in qmf::org::apache::qpid::broker::Link::doMethod ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#7  0x00002b81d11e15ee in qpid::management::ManagementAgent::handleMethodRequestLH ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#8  0x00002b81d11e5183 in qpid::management::ManagementAgent::dispatchAgentCommandLH ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#9  0x00002b81d11e54bb in qpid::management::ManagementAgent::dispatchCommand ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#10 0x00002b81d11ea3c8 in qpid::broker::ManagementExchange::route ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
---Type <return> to continue, or q <return> to quit---
#11 0x00002b81d11a200d in qpid::broker::SemanticState::route ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#12 0x00002b81d11a2de1 in qpid::broker::SemanticState::handle ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#13 0x00002b81d11c746e in qpid::broker::SessionState::handleContent ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#14 0x00002b81d11c7932 in qpid::broker::SessionState::handleIn ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#15 0x00002b81d160256a in qpid::amqp_0_10::SessionHandler::handleIn ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#16 0x00002b81d111a172 in qpid::broker::Connection::received ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#17 0x00002b81d10fba06 in qpid::amqp_0_10::Connection::decode ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#18 0x00002b81d162db67 in qpid::sys::AsynchIOHandler::readbuff ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#19 0x00002b81d11ec478 in boost::detail::function::function_obj_invoker2<boost::_bi::bind_t<bool, boost::_mfi::mf2<bool, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, bool, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#20 0x00002b81d156aa8f in boost::function2<bool, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*, std::allocator<boost::function_base> >::operator() () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#21 0x00002b81d1568c7c in qpid::sys::posix::AsynchIO::readable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#22 0x00002b81d1632def in boost::function1<void, qpid::sys::DispatchHandle&, std::allocator<boost::function_base> >::operator() () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#23 0x00002b81d1631a8b in qpid::sys::DispatchHandle::processEvent ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#24 0x00002b81d15763e8 in qpid::sys::Poller::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#25 0x00002b81d156cc5a in qpid::sys::(anonymous namespace)::runRunnable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#26 0x00002b81d22d6367 in start_thread () from /lib64/libpthread.so.0
#27 0x00002b81d204c09d in clone () from /lib64/libc.so.6

Thread 3 (process 2137):
#0  0x00002b81d204c488 in epoll_wait () from /lib64/libc.so.6
#1  0x00002b81d1575aa3 in qpid::sys::Poller::wait () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#2  0x00002b81d15763f7 in qpid::sys::Poller::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
---Type <return> to continue, or q <return> to quit---
#3  0x00002b81d156cc5a in qpid::sys::(anonymous namespace)::runRunnable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#4  0x00002b81d22d6367 in start_thread () from /lib64/libpthread.so.0
#5  0x00002b81d204c09d in clone () from /lib64/libc.so.6

Thread 2 (process 2139):
#0  0x00002b81d204c488 in epoll_wait () from /lib64/libc.so.6
#1  0x00002b81d1575aa3 in qpid::sys::Poller::wait () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#2  0x00002b81d15763f7 in qpid::sys::Poller::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#3  0x00002b81d156cc5a in qpid::sys::(anonymous namespace)::runRunnable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#4  0x00002b81d22d6367 in start_thread () from /lib64/libpthread.so.0
#5  0x00002b81d204c09d in clone () from /lib64/libc.so.6

Thread 1 (process 2138):
#0  0x00002b81d22cb229 in main_arena () from /lib64/libc.so.6
#1  0x00002b81d11c36c5 in qpid::broker::SessionState::enqueued ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#2  0x00002b81d11c74cf in qpid::broker::SessionState::handleContent ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#3  0x00002b81d11c7932 in qpid::broker::SessionState::handleIn ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#4  0x00002b81d160256a in qpid::amqp_0_10::SessionHandler::handleIn ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#5  0x00002b81d111a172 in qpid::broker::Connection::received ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#6  0x00002b81d10fba06 in qpid::amqp_0_10::Connection::decode ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#7  0x00002b81d162db67 in qpid::sys::AsynchIOHandler::readbuff ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#8  0x00002b81d11ec478 in boost::detail::function::function_obj_invoker2<boost::_bi::bind_t<bool, boost::_mfi::mf2<bool, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, bool, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidbroker.so.2
#9  0x00002b81d156aa8f in boost::function2<bool, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*, std::allocator<boost::function_base> >::operator() () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#10 0x00002b81d1568c7c in qpid::sys::posix::AsynchIO::readable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
---Type <return> to continue, or q <return> to quit---
#11 0x00002b81d1632def in boost::function1<void, qpid::sys::DispatchHandle&, std::allocator<boost::function_base> >::operator() () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#12 0x00002b81d1631a8b in qpid::sys::DispatchHandle::processEvent ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#13 0x00002b81d15763e8 in qpid::sys::Poller::run () from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#14 0x00002b81d156cc5a in qpid::sys::(anonymous namespace)::runRunnable ()
   from /var/lib/ptolemy/sources/qpid/cpp/src/.libs/libqpidcommon.so.2
#15 0x00002b81d22d6367 in start_thread () from /lib64/libpthread.so.0
#16 0x00002b81d204c09d in clone () from /lib64/libc.so.6


"
Bug,QPID-1461,12408449,QMF Events:  Some are not generated,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The events associated with connect/disconnect are not generated by the broker.
"
Bug,QPID-1546,12411098,M4 RC5 Windows Visual Studio files munged,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The Visual Studio project files for the C++ build had some licensing inserted and the line endings changed to Unix. These made them unusable by Visual Studio, so they won't load. I can change the line endings to DOS easily enough, but does the Apache license have to be included in the project files (*.vcproj)? If so, can it go further down the file (right now it's right at the top and Visual Studio screams about it).

I'll fix these things Monday 22-Dec-08 if I can get clarification about the license placement."
Bug,QPID-3394,12517951,"Broker ""leaks"" messages that require async completion.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The fix for QPID-3252 introduced a bug where messages that require async completion (ie. durable, or flow controlled) are incorrectly stored by the broker until the sender sends an explicit flush.  This can cause a excessive amount of memory to be consumed by the broker."
Bug,QPID-1984,12430356,Poller assertion when running reliable_replication_test,astitcher,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The reliable_replication_test has started failing (run under make check-long) due to the source broker crashing with the following assertion:

Core was generated by `/home/gordon/qpid/cpp/src/.libs/lt-qpidd --daemon --port 0 --no-data-dir --no-m'.
Program terminated with signal 6, Aborted.
[New process 14736]
[New process 14739]
[New process 14738]
[New process 14737]
[New process 14735]
[New process 14734]
[New process 14733]
[New process 14732]
#0  0x0000003c52e30215 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x0000003c52e30215 in raise () from /lib64/libc.so.6
#1  0x0000003c52e31cc0 in abort () from /lib64/libc.so.6
#2  0x0000003c52e29696 in __assert_fail () from /lib64/libc.so.6
#3  0x00002ad43a236ebe in qpid::sys::DispatchHandle::processEvent (
    this=0x104f50b8, type=qpid::sys::Poller::DISCONNECTED)
    at qpid/sys/DispatchHandle.cpp:260
#4  0x00002ad43a1ecb98 in qpid::sys::Poller::run (this=0x104e8770)
    at ./qpid/sys/Poller.h:123
#5  0x00002ad43a1e394a in runRunnable (p=0x398c)
    at qpid/sys/posix/Thread.cpp:35
#6  0x0000003c53a06367 in start_thread () from /lib64/libpthread.so.0
#7  0x0000003c52ed30ad in clone () from /lib64/libc.so.6
(gdb) frame 3
#3  0x00002ad43a236ebe in qpid::sys::DispatchHandle::processEvent (
    this=0x104f50b8, type=qpid::sys::Poller::DISCONNECTED)
    at qpid/sys/DispatchHandle.cpp:260
260             assert(state!=CALLING);
(gdb) print state
$1 = qpid::sys::DispatchHandle::CALLING
(gdb)
"
Bug,QPID-3197,12503932,C++ Broker crashes on persistence-based stress tests.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"While running under our persistence stress test suite, the C++ broker will occasionally crash with:

  Thread 1 (process 29629):
  #0  qpid::broker::SessionHandler::getConnection (this=0x0) at
qpid/broker/SessionHandler.cpp:62
  #1  0x0000002a958037e4 in
qpid::broker::SessionState::AsyncCommandCompleter::scheduleMsgCompletion
(this=Variable ""this"" is not available.
  ) at ./qpid/RefCounted.h:42
  #2  0x0000002a95803b79 in
qpid::broker::SessionState::IncompleteIngressMsgXfer::completed
(this=0x2a9d8fc490, sync=Variable ""sync"" is not available.
  )
<persistence code completes message enqueue>

It appears that there is a window where the session is detached when the completion occurs, which results in a null pointer reference.
"
Bug,QPID-2320,12444617,Failed acquire on LVQ causes broker crash,astitcher,gsim,Closed,Fixed,2010-01-28 15:16,C++,C++ Broker,,,,,,,"If an acquire fails for an LVQ because the message has already been acquired by some other subscriber, the failed attempt causes the broker to crash. This is due to lack of proper bounds checking in Queue::acquire() for the LVQ case and was I believe introduced by http://svn.apache.org/viewvc?view=revision&revision=834172.
"
Bug,QPID-7893,13096466,compilation failure on Fedora 26,jross,robbie,Resolved,Fixed,2021-02-01 11:54,C++,C++ Broker,C++ Build,C++ Client,,,,,"When trying to compile qpid-cpp master (commit 55d4171a8155d9f6a07a48507e33d43b8cb6d904) on Fedora 26, I get some 'maybe-uninitialized' related complication failures (see attachment). 

Adding ""-DCMAKE_CXX_FLAGS=-Wno-error=maybe-uninitialized"" to the initial cmake run seemed to get things going though obviously might not be correct.
"
Bug,QPID-7991,13112433,Segfault in broker while processing active bridges,aconway,chris.richardson,Resolved,Fixed,2017-11-22 10:10,C++,C++ Broker,,,,,,,"Segfault occurs on a brackground thread within about 5-10 seconds of broker startup at src/qpid/broker/Link.cpp:465. [^segfault stack trace] attached, frames #3 and #5 are of particular relevance.
The unchecked Bridge::shared_ptr derived from the iterator is null and the invocation of bridge->closed() triggers the segfault. Adding a simple null check (as per attached [^segfault-fix.patch]) fixes the segfault but not the underlying reason for the null pointer. 

The segfault appears to be related to how a second broker (henceforth ""broker1"") is configured; this is the one to which the links are established. Without broker1, the ""segfaulting broker"" (aka ""broker2"") does not do its thing. It may be that broker1 returns invalid data to broker2 but this is not in the scope of this bug report, which focuses on the segfault. 

h2. Reproduce
Unfortunately the steps to  arrive at this situation are not clear so the reproduce is a bit hacky - the data directory, config file and some certs for the two brokers are attached as a tarball in the hope that they can be arranged in such a way as to provide a reproduce in lieu of a purely step-based procedure.
Steps to reproduce:
* Temporarily add a DNS alias to the local machine of ""octopussy"" (necessary due to cert config and durable link config in broker2's data store)
* Extract the attached [^segfault-repoduce.tar.gz] to an empty directory (assumed to be cwd)
* Start broker1 with ""qpidd --config broker1/qpidd.conf""
* In another shell with the same cwd, start broker2 with ""qpidd --config broker2/qpidd.conf""
* Observe segfault in broker2 after 5-10 seconds.
"
Bug,QPID-6470,12787068,FieldValue::getFloatingPointValue() converts endian each time it is called,aconway,pokutnev,Closed,Fixed,2016-09-08 10:26,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"When calling getFloatingPointValue multiple times, the octets are endian-converted each time.
Actually we need to make a copy first and then call convertIfRequired()."
Bug,QPID-5900,12727724,Qpid High Availability cannot be installed on EL6,mcpierce,bmbouter,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"The high availability configuration of Qpid is provided by the package qpid-cpp-server-ha which is produced from SRPM qpid-cpp. Pulp includes and delivers all qpid-cpp SRPM bits for EL6 from koji so a recent version of Qpid is available on EL6. The qpid-cpp-server-ha package is missing a dependency called 'systemd-units' that is not available in base EL6 or EPEL.

Error: Package: qpid-cpp-server-ha-0.26-7.el6.x86_64 (pulp-v2)
           Requires: systemd-units

EL6 doesn't use systemd so the only solution I can think of is to rework the dependencies of qpid-cpp-server-ha to not require systemd-units."
Bug,QPID-6427,12778845,Problem building trunk qpid cpp on RHEL 5,aconway,iboverma,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"...
[ 46%] Building CXX object src/CMakeFiles/qpidbroker.dir/qmf/org/apache/qpid/broker/EventQueueThresholdExceeded.cpp.o
cd /root/iboverma/rh-qpid-trunk/qpid/cpp/build/src && /usr/bin/c++   -Dqpidbroker_EXPORTS -D_IN_QPID_BROKER -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -fPIC -I/root/iboverma/rh-qpid-trunk/qpid/cpp/src -I/root/iboverma/rh-qpid-trunk/qpid/cpp/src/../include -I/root/iboverma/rh-qpid-trunk/qpid/cpp/build/src -I/root/iboverma/rh-qpid-trunk/qpid/cpp/build/src/../include -I/usr/include/nss3 -I/usr/include/nspr4   -pthread -o CMakeFiles/qpidbroker.dir/qmf/org/apache/qpid/broker/EventQueueThresholdExceeded.cpp.o -c /root/iboverma/rh-qpid-trunk/qpid/cpp/build/src/qmf/org/apache/qpid/broker/EventQueueThresholdExceeded.cpp
cc1plus: warnings being treated as errors
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/SenderContext.h:50: warning: ?쁟lass qpid::messaging::amqp::SenderContext??has virtual functions but non-virtual destructor
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/Transaction.h:43: warning: ?쁟lass qpid::messaging::amqp::Transaction??has virtual functions but non-virtual destructor
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp: In member function ?쁵oid qpid::messaging::amqp::ConnectionContext::close()??
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:233: error: ?쁟lass boost::intrusive_ptr<qpid::sys::TimerTask>??has no member named ?쁱eset??/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp: In member function ?쁵oid qpid::messaging::amqp::ConnectionContext::startTxSession(boost::shared_ptr<qpid::messaging::amqp::SessionContext>)??
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:1239: error: call of overloaded ?쁝ttach(boost::shared_ptr<qpid::messaging::amqp::SessionContext>&, boost::shared_ptr<qpid::messaging::amqp::Transaction>&)??is ambiguous
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:419: note: candidates are: void qpid::messaging::amqp::ConnectionContext::attach(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::SenderContext>)
/root/iboverma/rh-qpid-trunk/qpid/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:429: note:                 void qpid::messaging::amqp::ConnectionContext::attach(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::ReceiverContext>)
make[2]: *** [src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/ConnectionContext.cpp.o] Error 1

"
Bug,QPID-5651,12704230,[C++ broker] segfault in qpid::linearstore::journal::jdir::clear_dir when declaring durable queue,pmoravec,pmoravec,Closed,Fixed,2014-04-09 15:49,C++,C++ Broker,,,,,,,"Affected version: 0.28 / current upstream (svn revision 1582719).

Creating a durable queue / linear store journal for it, I get segfault.

Trivial reproducer:
1) rm -rf ~/.qpidd
2) qpidd --load-module=src/linearstore.so
3) qpid-receive -a ""myQueue; {create:always, node:{durable:true}}""

backtrace is:

#0  0x00000032c44a8a79 in readdir64 () from /lib64/libc.so.6
#1  0x00007ffff6d138fa in qpid::linearstore::journal::jdir::clear_dir(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#2  0x00007ffff6d13125 in qpid::linearstore::journal::jdir::clear_dir(bool) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#3  0x00007ffff6d10baf in qpid::linearstore::journal::jcntl::initialize(qpid::linearstore::journal::EmptyFilePool*, unsigned short, unsigned int, qpid::linearstore::journal::aio_callback*) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#4  0x00007ffff6d44a41 in qpid::linearstore::JournalImpl::initialize(qpid::linearstore::journal::EmptyFilePool*, unsigned short, unsigned int, qpid::linearstore::journal::aio_callback*) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#5  0x00007ffff6d692fe in qpid::linearstore::JournalImpl::initialize(qpid::linearstore::journal::EmptyFilePool*, unsigned short, unsigned int) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#6  0x00007ffff6d5a986 in qpid::linearstore::MessageStoreImpl::create(qpid::broker::PersistableQueue&, qpid::framing::FieldTable const&) () from /data_xfs/qpid/cpp/BLD/src/linearstore.so
#7  0x00007ffff7bdb413 in qpid::broker::MessageStoreModule::create(qpid::broker::PersistableQueue&, qpid::framing::FieldTable const&)
    () from /data_xfs/qpid/cpp/BLD/src/libqpidbroker.so.2
#8  0x00007ffff7b529e1 in qpid::broker::Queue::create() () from /data_xfs/qpid/cpp/BLD/src/libqpidbroker.so.2
#9  0x00007ffff7beb81d in qpid::broker::QueueRegistry::declare(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, qpid::broker::QueueSettings const&, boost::shared_ptr<qpid::broker::Exchange>, bool, qpid::broker::OwnershipToken const*, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >) () from /data_xfs/qpid/cpp/BLD/src/libqpidbroker.so.2

"
Bug,QPID-5417,12684086,ClassCastException when using amqp-1-0-jms-0.24 client,,uromahn,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"I have installed a qpid-cpp broker (via source) on my CentOS machine and successfully started.
I have then created a simple (but more extended) test application using the amqp-1-0-jms client library.
I can successfully connect to an ActiveMQ 5.9 as well as a qpid-java 0.24 broker and exchange messages via a configured queue.
However, when I connect to my qpid-cpp broker (also 0.24 with proton 0.4), I can send messages to a queue, but when trying to read from the queue I am getting the following error message:

Exception in thread ""Thread-7"" java.lang.ClassCastException: org.apache.qpid.amqp_1_0.type.Symbol cannot be cast to org.apache.qpid.amqp_1_0.type.Section
        at org.apache.qpid.amqp_1_0.messaging.SectionDecoderImpl.parseAll(SectionDecoderImpl.java:49)
        at org.apache.qpid.amqp_1_0.client.Receiver.receive(Receiver.java:280)
        at org.apache.qpid.amqp_1_0.jms.impl.MessageConsumerImpl.receive0(MessageConsumerImpl.java:286)
        at org.apache.qpid.amqp_1_0.jms.impl.SessionImpl$Dispatcher.run(SessionImpl.java:859)
        at java.lang.Thread.run(Thread.java:744)
Please note: I also re-compiled my test app using the latest 0.26-SNAPSHOT jms client from source with the exact same error - in fact, the stack trace above comes from this version, in case anybody was wondering.

Also, to verify my installations are all correct, I tried a similar test using the Java example coming with qpid-proton 0.5 and could successfully connect and exchange messages with any broker speaking AMQP 1-0 (qpid-cpp, qpid-java, ActiveMQ, and Apache Apollo)! 

I believe the issue is not actually in the subscriber, but in how the message gets put into the queue.
I ran the following test as well:
1. I put a message into my queue using a simple test application with the amqp-1-0-jms client library.
2. I then used the proton-j Recv.java test application to connect to this queue (which is setup as ""durable""). The proton-j 0.5 client now threw the exact same ClassCastException. "
Bug,QPID-1414,12407506,Assertion from boost variant visitation,gsim,gsim,Closed,Fixed,2013-08-21 10:45,C++,C++ Broker,,,,,,,"008-oct-23 18:30:29 warning SASL: No Authentication Performed
qpidd: /usr/include/boost/variant/detail/visitation_impl.hpp:203: typename
Visitor::result_type boost::detail::variant::visitation_impl(int, int,
Visitor&, VPCV, mpl_::true_, NBF, W*, S*) [with W = mpl_::int_<20>, S =
boost::detail::variant::visitation_impl_step<boost::mpl::l_iter<boost::mpl
::l_end>, boost::mpl::l_iter<boost::mpl::l_end> >, Visitor =
boost::detail::variant::destroyer, VPCV = void*, NBF =
boost::variant<qpid::TcpAddres
s, boost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::vari
ant::void_, boost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::variant::void_, boost::detail::variant::void_, boost::det
ail::variant::void_, boost::detail::variant::void_,
boost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::variant::void_, b
oost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::variant::void_, boost::detail::variant::void_,
boost::detail::variant:
:void_>::has_fallback_type_]: Assertion `false' failed."
Bug,QPID-4672,12639304,C++ Broker deadlock detaching XmlExchange sessions,,chug,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Self test federation.FederationTests.test_dynamic_topic locks up. Pstack shows three threads with the same trace:

#0  pthread_rwlock_wrlock ()
#1  qpid::broker::XmlExchange::unbind()
#2  qpid::broker::XmlExchange::fedUnbind()
#3  qpid::broker::XmlExchange::bind()
#4  qpid::broker::Queue::bind()
#5  qpid::broker::Broker::bind()
#6  qpid::broker::SemanticState::unbindSessionBindings()
#7  qpid::broker::SemanticState::closed()
#8  qpid::broker::SessionState::~SessionState()
#9  qpid::broker::SessionState::~SessionState()
#10 qpid::broker::SessionHandler::handleDetach()
#11 qpid::amqp_0_10::SessionHandler::detach()

The lock occurs because there are two simultaneous session detach calls going on. Each takes out the Rlock and then tries to take out the Wlock. Neither will get the Wlock until everyone else releases their Rlock. Subsequent detach calls fall into the same catch as they get the Rlock but not the Wlock.

This condition is present in both the XmlExchange and DirectExchange. I'll have a patch for review shortly.

"
Bug,QPID-4049,12559899,Linux C++ broker crashes when Windows client connects SSL with expired certificate,astitcher,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Testing Windows client -> Linux broker SSL connections. The SSL cert is expired and this results in the following on Linux:

2012-06-08 17:08:12 error Error reading socket: Encountered end of file [-5938]
2012-06-08 17:08:14 error Connection 192.168.10.4:5671-192.168.10.40:60748 No protocol received closing

Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x40a00940 (LWP 15265)]
0x00002aaaac0d9164 in qpid::sys::ssl::ProtocolTimeoutTask::fire() ()
   from /qpidbuilds/trunk/qpid/cpp/rhel5/src/ssl.so
(gdb) where
#0  0x00002aaaac0d9164 in qpid::sys::ssl::ProtocolTimeoutTask::fire() ()
   from /qpidbuilds/trunk/qpid/cpp/rhel5/src/ssl.so
#1  0x00002aaaab51c7bc in qpid::sys::TimerTask::fireTask() ()
   from /qpidbuilds/trunk/qpid/cpp/rhel5/src/libqpidcommon.so.2.0.0
#2  0x00002aaaab51c952 in qpid::sys::Timer::fire(boost::intrusive_ptr<qpid::sys::TimerTask>) ()
   from /qpidbuilds/trunk/qpid/cpp/rhel5/src/libqpidcommon.so.2.0.0
#3  0x00002aaaab51d22d in qpid::sys::Timer::run() ()
   from /qpidbuilds/trunk/qpid/cpp/rhel5/src/libqpidcommon.so.2.0.0
#4  0x00002aaaab4a9e74 in qpid::sys::(anonymous namespace)::runRunnable(void*)
    () from /qpidbuilds/trunk/qpid/cpp/rhel5/src/libqpidcommon.so.2.0.0
#5  0x000000318f60677d in start_thread () from /lib64/libpthread.so.0
#6  0x000000318eed325d in clone () from /lib64/libc.so.6
(gdb) 

On Windows, this error looks like:

2012-06-08 17:07:06 notice SSL negotiation failed to smokey:5671: The received certificate has expired.
2012-06-08 17:07:06 warning Connect failed: The received certificate has expired
.  (..\..\..\..\cpp\src\qpid\client\windows\SslConnector.cpp:111)
2012-06-08 17:07:06 warning Connection [192.168.10.40:60748-smokey:5671] closed

Connection [192.168.10.40:60748-smokey:5671] closed
E:\
"
Bug,QPID-2630,12465547,"Repeated declarations and deletions of the queue, broker's memory increased(NEVER decreased)",gsim,yutax77,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The more I run Java test code which is simply declare/delete queue and
check the queue existence by queuequery(please see atatched Java file), the more
C++ broker memory size increase(NEVER decrease).
Every times, the test code is successful.

In test code, it's repeated declarations and deletions of the queue 10,000 times.

Here is run summary.
A run represent one iteration through the whole test.
i.e. each run has done declarations and deletions of the queue 10,000 times and totally 100,000 times in this case.


             |   broker memory size
Run #  |   (MB)
----------|------------------------------
initial   |    3
#1       |   23
#2       |   42
#3       |   50
#4       |   52
#5       |   65
#6       |   64
#7       |   72
#8       |   77
#9       |   81
#10     |   88"
Bug,QPID-1618,12413402,unacked persistent messages don't get to messageStore of newbie cluster broker.,aconway,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"
When a new broker is added to a cluster, persistent messages that have not yet been ACKed do not get stored in the new brokers messageStore.


How to reproduce:   ( this is overview -- actual scripts follow )
========================================================

1. kill any MY_CLUSTER brokers from previous test

2. remove data dirs from previous test, and recreate

3. start node 1 as first member of MY_CLUSTER

4  declare the MY_CLUSTER queue -- durable

5. connect to it with receiver -- use ack frequency of 10;

6. connect with ""publish"" send only 5 persistent msgs, receiver
   will get them but not ack.

7. start second node

8. when the state transfer completes kill both nodes.
   (receiver should also perish)

9. start up the second node only, as new first member of MY_CLUSTER.
   ( I.e. use 2nd broker's data dir path. )

10. start and attach a new receiver

    PREVIOUS RESULT -- nothing.  messages were never stored in broker2's
                       messageStore.

    RESULT -- new receiver now gets 5 messages.
              durable queue says that ""sender confirmed point moved to (5+0)""




==============================================
Scripts for reproducing problem.
==============================================


###################################################################
#############                step  1                 ##############
###################################################################
#! /bin/bash

echo ""------------------------------------------------""
echo ""Step 1: Kill any brokers already running in the MY_CLUSTER cluster""
echo ""------------------------------------------------""
kill -9 `pgrep -f MY_STORE`

echo ""There should be no remaining brokers.  Here they are: ""
ps -aef | grep qpidd | grep -v grep


###################################################################
#############                step  2                 ##############
###################################################################
#! /bin/bash

echo ""------------------------------------------------""
echo ""Step 2: remove and rebuild the store data dirs.""
echo ""------------------------------------------------""
rm -rf ./data
mkdir -p ./data/1 ./data/2

###################################################################
#############                step  3                 ##############
###################################################################
#! /bin/bash


echo ""------------------------------------------------""
echo ""Step 3: Start the first broker in a cluster, using Store in ./data/1 .""
echo ""------------------------------------------------""
rm broker_1.log
$QPID_ROOT/cpp/src/qpidd --no-module-dir            \
  --load-module $QPID_ROOT/cpp/src/.libs/cluster.so \
  --load-module $STORE_ROOT/cpp/lib/.libs/msgstore.so \
  --cluster-name MY_CLUSTER -p 5813             \
  --auth=no --mgmt-enable=no                        \
  --log-enable debug --log-to-file ./broker_1.log   \
  --data-dir ./data/1

###################################################################
#############                step  4                 ##############
###################################################################
#! /bin/bash

echo ""Step 4: Declaring queue.""
$QPID_ROOT/cpp/examples/direct/declare_queues

# !!  NOTE  !!
#         edit declare_queues.cpp to do port 5813
#         in call to session.queueDeclare use arg::durable=true
#         and     arg::queue=""MY_QUEUE"",
#         edit exchangeBind call to use:
#                 arg::queue = ""MY_QUEUE"",






###################################################################
#############                step  5                 ##############
###################################################################
#! /bin/bash
echo ""Step 5:  Starting receiver...""

$QPID_ROOT/cpp/src/tests/receiver     \
-p 5813                               \
--queue MY_QUEUE                      \
--messages 10                         \
--ack-frequency 10

###################################################################
#############                step  6                 ##############
###################################################################
#! /bin/bash

echo ""Publish only 5 messages, so the receiver will not yet ack.""

$QPID_ROOT/cpp/src/tests/publish \
-p 5813                          \
--count 5                        \
--durable yes                    \
--destination amq.direct         \
--routing-key routing_key        \
--log-enable debug
#! /bin/bash




###################################################################
#############                step  7                 ##############
###################################################################
rm ./broker_2.log

echo ""------------------------------------------------""
echo ""Step 7: Start second node, using Store in ./data/2 .""
echo ""   note!  you should see correct store dirs replicated to this broker.""
echo ""------------------------------------------------""

$QPID_ROOT/cpp/src/qpidd --no-module-dir            \
  --load-module $QPID_ROOT/cpp/src/.libs/cluster.so \
  --load-module $STORE_ROOT/cpp/lib/.libs/msgstore.so \
  --cluster-name MY_CLUSTER -p 5814                   \
  --auth=no --mgmt-enable=no                          \
  --log-enable debug --log-to-file ./broker_2.log     \
  --data-dir ./data/2


###################################################################
#############                step  8                 ##############
###################################################################
#! /bin/bash

echo ""When the second node is up and synced, kill both nodes.""
echo ""   note:  receiver should now die also.""

kill -9 `pgrep -f MY_CLUSTER`

ps -aef | grep qpidd | grep -v grep



###################################################################
#############                step  9                 ##############
###################################################################
#! /bin/bash
echo ""------------------------------------------------""
echo ""Step 9: Start second node, using Store in ./data/2 .""
echo ""------------------------------------------------""
$QPID_ROOT/cpp/src/qpidd --no-module-dir            \
  --load-module $QPID_ROOT/cpp/src/.libs/cluster.so \
  --load-module $STORE_ROOT/cpp/lib/.libs/msgstore.so \
  --cluster-name MY_CLUSTER -p 5813             \
  --auth=no --mgmt-enable=yes                       \
  --log-enable debug --log-to-file ./broker_3.log   \
  --data-dir ./data/2



###################################################################
#############                step  10                ##############
###################################################################
#! /bin/bash

echo "" ""
echo ""Start final receiver -- it should get unacked messages.""
echo "" ""
$QPID_ROOT/cpp/src/tests/receiver     \
-p 5813                               \
--queue MY_QUEUE                      \
--messages 10                         \
--ack-frequency 5









"
Bug,QPID-2702,12468127,#NAME?,aconway,lujah,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"On Linux ,when start borker(qpidd) with --cluster-name,then --max-connections option not work."
Bug,QPID-1725,12416622,Deadlock between ManagementBroker::userLock and LinkRegistry::lock,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Dispatching a management method holds the userLock in ManagementBroker; it may then require the lock in the LinkRegistry if it is to declare a link or bridge.

Linkregistry::notifyConnection() firsttakes the Linkregistry lock, then as part of establishing the connection it raises a management event which requires the managementBrokers userLock.

Thread 5 (Thread -1208362080 (LWP 28312)):
#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45f0b97e in __lll_mutex_lock_wait () from /lib/libpthread.so.0
#2  0x45f08247 in _L_mutex_lock_340 () from /lib/libpthread.so.0
#3  0x45f0819f in pthread_mutex_lock () from /lib/libpthread.so.0
#4  0x45c7dd29 in pthread_mutex_lock () from /lib/libc.so.6
#5  0x00edf33d in qpid::management::ManagementBroker::periodicProcessing ()
#6  0x00ee00a6 in qpid::management::ManagementBroker::Periodic::fire ()
#7  0x00eceafb in qpid::broker::Timer::run ()
#8  0x00a01c11 in qpid::sys::(anonymous namespace)::runRunnable ()
#9  0x45f0640b in start_thread () from /lib/libpthread.so.0
#10 0x45c71b7e in clone () from /lib/libc.so.6
Thread 4 (Thread -1218851936 (LWP 28313)):
#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45f0b97e in __lll_mutex_lock_wait () from /lib/libpthread.so.0
#2  0x45f08247 in _L_mutex_lock_340 () from /lib/libpthread.so.0
#3  0x45f0819f in pthread_mutex_lock () from /lib/libpthread.so.0
#4  0x45c7dd29 in pthread_mutex_lock () from /lib/libc.so.6
#5  0x00e715cb in qpid::broker::LinkRegistry::periodicMaintenance ()
#6  0x00e71fa8 in qpid::broker::LinkRegistry::Periodic::fire ()
#7  0x00eceafb in qpid::broker::Timer::run ()
#8  0x00a01c11 in qpid::sys::(anonymous namespace)::runRunnable ()
#9  0x45f0640b in start_thread () from /lib/libpthread.so.0
#10 0x45c71b7e in clone () from /lib/libc.so.6
Thread 3 (Thread -1229341792 (LWP 28314)):
#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45f0967c in pthread_cond_timedwait@@GLIBC_2.3.2 ()
#2  0x45c7dbf4 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x00ecebf0 in qpid::broker::Timer::run ()
#4  0x00a01c11 in qpid::sys::(anonymous namespace)::runRunnable ()
#5  0x45f0640b in start_thread () from /lib/libpthread.so.0
#6  0x45c71b7e in clone () from /lib/libc.so.6
Thread 2 (Thread -1239831648 (LWP 28317)):
#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45f0b97e in __lll_mutex_lock_wait () from /lib/libpthread.so.0
#2  0x45f08247 in _L_mutex_lock_340 () from /lib/libpthread.so.0
#3  0x45f0819f in pthread_mutex_lock () from /lib/libpthread.so.0
#4  0x45c7dd29 in pthread_mutex_lock () from /lib/libc.so.6
#5  0x00e6f1bc in qpid::broker::LinkRegistry::declare ()                 <--- LinkRegistry::lock required
#6  0x00e6b2d1 in qpid::broker::Link::ManagementMethod ()
#7  0x00dd9ae5 in qmf::org::apache::qpid::broker::Link::doMethod ()
#8  0x00ede600 in qpid::management::ManagementBroker::handleMethodRequestLH ()
#9  0x00ee811c in qpid::management::ManagementBroker::dispatchAgentCommandLH ()
#10 0x00ee8650 in qpid::management::ManagementBroker::dispatchCommand () <--- ManagementBroker::userLock held
#11 0x00eebbf3 in qpid::broker::ManagementExchange::route ()
#12 0x00eaab9d in qpid::broker::SemanticState::route ()
#13 0x00eabeea in qpid::broker::SemanticState::handle ()
#14 0x00ec3412 in qpid::broker::SessionState::handleContent ()
#15 0x00ec3a03 in qpid::broker::SessionState::handleIn ()
#16 0x00ec73eb in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qp id::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::f raming::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid: :framing::AMQFrame&))>::handle ()
#17 0x00a2ddaf in qpid::amqp_0_10::SessionHandler::handleIn ()
#18 0x00ec73eb in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qp id::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::f raming::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid: :framing::AMQFrame&))>::handle ()
#19 0x00e384ac in qpid::broker::Connection::received ()
#20 0x00bc3602 in ?? ()
#21 0xb380134c in ?? ()
#22 0x09d82608 in ?? ()
#23 0x09d851b8 in ?? ()
#24 0x45c7dd55 in pthread_mutex_unlock () from /lib/libc.so.6
#25 0x00ba3773 in ?? ()
#26 0xb38012a8 in ?? ()
#27 0x09d825f8 in ?? ()
#28 0x09d825f8 in ?? ()
#29 0xb6199dd8 in ?? ()
#30 0x000000c1 in ?? ()
#31 0x00ba47fd in ?? ()
#32 0x09d80568 in ?? ()
#33 0x09d825f8 in ?? ()
#34 0x00000002 in ?? ()
#35 0x00000001 in ?? ()
#36 0xb6199e68 in ?? ()
#37 0x00bac664 in ?? ()
#38 0x09d815e0 in ?? ()
#39 0x09d825f8 in ?? ()
#40 0xb6199e48 in ?? ()
#41 0x45c7dd55 in pthread_mutex_unlock () from /lib/libc.so.6
Thread 1 (Thread -1208158480 (LWP 28311)):
#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45f0b97e in __lll_mutex_lock_wait () from /lib/libpthread.so.0
#2  0x45f08247 in _L_mutex_lock_340 () from /lib/libpthread.so.0
#3  0x45f0819f in pthread_mutex_lock () from /lib/libpthread.so.0
#4  0x45c7dd29 in pthread_mutex_lock () from /lib/libc.so.6
#5  0x00ee012a in qpid::management::ManagementBroker::raiseEvent () <--- ManagementBroker::userLock required
#6  0x00e6ac23 in qpid::broker::Link::established ()
#7  0x00e70805 in qpid::broker::LinkRegistry::notifyConnection ()   <--- LinkRegistry::lock held
#8  0x00e3b57d in qpid::broker::Connection::Connection ()
#9  0x00bc80ee in ?? ()
#10 0x09d84dcc in ?? ()
#11 0x09d84d68 in ?? ()
#12 0x09d7ef88 in ?? ()
#13 0x09d85b24 in ?? ()
#14 0x00000001 in ?? ()
#15 0x00000000 in ?? ()
"
Bug,QPID-1611,12413029,queue durability is lost on broker-newbie sync.,,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"
queue durability does not survive cluster broker newbie sync.

When a new broker is syncing up with a cluster, it gets all the information it needs to preserve queue durability, 
But the code pathway that we go through in that case does not tell the journaling code to create a journal.
This has the effect of making the queue not durable after all.


!  catch attached patch !



"
Bug,QPID-2296,12443758,Cluster errors when using acquire-mode-not-acquired,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Adding a new broker to a cluster while there are clients using not-acquired mode (aka ""browse"" mode) to retrieve messages without dequeing them  can cause inconsistencies that will cause cluster members to abort. Examples of errors that may be seen as a result of this bug:

2009-12-18 10:29:04 critical cluster(20.0.100.32:23782 READY/error) local error 906715 did not occur on member 20.0.100.33:16960: resource-limit-exceeded: Policy exceeded on A_1, poli\
cy: size: max=104857600, current=952489; count: max=20000, current=20000; type=reject (../../cpp/src/qpid/broker/QueuePolicy.cpp:83)

2009-12-21 12:22:07 error Error delivering frames: local error did not occur on all cluster members : invalid-argument: anonymous.a6e88ed1-e69b-4549-b\
32d-5168f068974d: confirmed < (103+0) but only sent < (99+0) (../../cpp/src/qpid/SessionState.cpp:151) (../../cpp/src/qpid/cluster/ErrorCheck.cpp:89)


See https://bugzilla.redhat.com/show_bug.cgi?id=541927 for more details."
Bug,QPID-1417,12407509,Seg fault caused by bad pointer in AggregateOutputControl,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If perftest is configured to cause a store ""Enqueue capacity threshold
exceeded"" error, the broker fails with a SIGSEV.

To reproduce, start the broker with (adjust paths):
./qpidd --load-module /home/kpvdr/mrg/store.ref/cpp/lib/.libs/msgstore.so
--auth no --log-enable info+ --data-dir /tmp

At the time of filing, perftest used with --sub-tx option causes the sub to run
slowly and thus cuase the pubs to overflow the journal (a known bug). Using
this flaw, start perftest with:
./perftest --durable yes --tcp-nodelay --npubs 4 --nsubs 4 --sub-tx 10

The broker cores almost immediately after printing a lot of error messages:
2008-oct-24 14:00:53 info Listening on TCP port 5672
[New Thread 0x43f09950 (LWP 16648)]
[New Thread 0x415a5950 (LWP 16649)]
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 notice Journal ""perftest0"": Created
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning SASL: No Authentication Performed
2008-oct-24 14:01:01 warning Journal ""perftest0"": Enqueue capacity threshold
exceeded on queue ""perftest0"".
2008-oct-24 14:01:01 error Unexpected exception: Enqueue capacity threshold
exceeded on queue ""perftest0"". (JournalImpl.cpp:501)
2008-oct-24 14:01:01 warning Journal ""perftest0"": Enqueue capacity threshold
exceeded on queue ""perftest0"".
2008-oct-24 14:01:01 error Connection 127.0.0.1:42680 closed by error: Enqueue
capacity threshold exceeded on queue ""perftest0"". (JournalImpl.cpp:501)(501)
2008-oct-24 14:01:01 error Unexpected exception: Enqueue capacity threshold
exceeded on queue ""perftest0"". (JournalImpl.cpp:501)
2008-oct-24 14:01:01 error Connection 127.0.0.1:42678 closed by error: Enqueue
capacity threshold exceeded on queue ""perftest0"". (JournalImpl.cpp:501)(501)
2008-oct-24 14:01:01 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)
2008-oct-24 14:01:01 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)
2008-oct-24 14:01:01 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)
<snip>
...
</snip>
2008-oct-24 14:01:02 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)
2008-oct-24 14:01:02 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)
2008-oct-24 14:01:02 error Channel exception: not-attached: Channel 2 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:56)

Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x415a5950 (LWP 16649)]
0x00007f83c3b96b74 in qpid::sys::AggregateOutput::doOutput (this=0xa1b0a0) at
qpid/sys/AggregateOutput.cpp:49
49             result = tasks[next++]->doOutput();
(gdb) bt full
#0  0x00007f83c3b96b74 in qpid::sys::AggregateOutput::doOutput (this=0xa1b0a0)
at qpid/sys/AggregateOutput.cpp:49
 result = <value optimized out>
#1  0x00007f83c3f2b299 in qpid::broker::Connection::doOutput (this=0xa1b030) at
qpid/broker/Connection.cpp:217
No locals.
#2  0x00007f83c3f02776 in qpid::amqp_0_10::Connection::encode (this=0xa1c320,
buffer=0x9faba0 ""\017"", size=<value optimized out>)
    at qpid/amqp_0_10/Connection.cpp:86
 out = {size = 65536, data = 0x9faba0 ""\017"", position = 98, r_position = 0}
 frameSize = 98
 __PRETTY_FUNCTION__ = ""virtual size_t
qpid::amqp_0_10::Connection::encode(const char*, size_t)""
 stmt_ = {enabled = false, file = 0x7f83c3fb3e23
""qpid/amqp_0_10/Connection.cpp"", line = 78, 
  function = 0x7f83c3fb4060 ""virtual size_t
qpid::amqp_0_10::Connection::encode(const char*, size_t)"", level =
qpid::log::trace}
 init_ = {statement = @0x7f83c4210b80}
 stmt_ = {enabled = false, file = 0x7f83c3fb3e23
""qpid/amqp_0_10/Connection.cpp"", line = 83, 
  function = 0x7f83c3fb4060 ""virtual size_t
qpid::amqp_0_10::Connection::encode(const char*, size_t)"", level =
qpid::log::trace}
 init_ = {statement = @0x7f83c4210b40}
#3  0x00007f83c3b97aa9 in qpid::sys::AsynchIOHandler::idle (this=0xa1eee0) at
qpid/sys/AsynchIOHandler.cpp:166
 buff = <value optimized out>
 encoded = 7301231304930963497
#4  0x00007f83c3b4ca47 in boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> >::operator() (this=<value optimized out>, 
    a0=@0xa1b970) at /usr/include/boost/function/function_template.hpp:692
No locals.
#5  0x00007f83c3b4a317 in qpid::sys::posix::AsynchIO::writeable (this=0x9da440,
h=@0x9da448) at qpid/sys/posix/AsynchIO.cpp:530
 writeTotal = 0
 __PRETTY_FUNCTION__ = ""void
qpid::sys::posix::AsynchIO::writeable(qpid::sys::DispatchHandle&)""
#6  0x00007f83c3b9a7f7 in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=<value optimized out>, 
    a0=@0xa1b970) at /usr/include/boost/function/function_template.hpp:692
No locals.
#7  0x00007f83c3b9a5b0 in qpid::sys::DispatchHandle::processEvent
(this=0x9da448, type=qpid::sys::Poller::READ_WRITABLE) at
qpid/sys/DispatchHandle.cpp:360
 __PRETTY_FUNCTION__ = ""virtual void
qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType)""
#8  0x00007f83c3b98e18 in qpid::sys::Dispatcher::run (this=0x7fffcc212e80) at
qpid/sys/Poller.h:105
 event = {handle = 0x9da448, type = qpid::sys::Poller::READ_WRITABLE}
 __PRETTY_FUNCTION__ = ""virtual void qpid::sys::Dispatcher::run()""
#9  0x00007f83c3b4e98a in runRunnable (p=0xc2cc78) at
qpid/sys/posix/Thread.cpp:35
No locals.
#10 0x000000379880729a in start_thread (arg=<value optimized out>) at
pthread_create.c:297
 __res = <value optimized out>
 pd = <value optimized out>
 unwind_buf = Could not find the frame base for ""start_thread""."
Bug,QPID-2842,12473116,references to other objects in qpid-tool use id that doesn't match anything else,tross,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Tools,QMF,,,,,"E.g. in the following qpid-tool session it is impossible to accurately identify the session for a given subscription:

qpid: list subscription
Object Summary:
    ID   Created   Destroyed  Index
    =================================================================
    128  08:07:24  -          0-1447-1-0-13:0-1447-1-0-25:v2TopicHB
    129  08:07:24  -          0-1447-1-0-13:0-1447-1-0-23:v2TopicUI
    130  08:07:24  -          0-1447-1-0-13:0-1447-1-0-14:rdest
    131  08:07:24  -          0-1447-1-0-13:0-1447-1-0-18:tdest
    138  08:07:37  -          0-1447-1-0-35:0-1447-1-0-36:my-queue
    127  08:07:24  -          0-1447-1-0-13:0-1447-1-0-21:v2dest
qpid: show 138
Object of type: org.apache.qpid.broker:subscription:_data(7cc0ee44-57d4-2ed7-1a4b-3156ed9a4343)
    Attribute     138
    =============================
    sessionRef    0-1447-1-0-35
    queueRef      0-1447-1-0-36
    name          u'my-queue'
    browsing      False
    acknowledged  True
    exclusive     False
    creditMode    u'CREDIT'
    arguments     {}
    delivered     0

The session ref is shown as 0-1447-1-0-35, but this doesn't help me identify the session...

qpid: list session
Object Summary:
    ID   Created   Destroyed  Index
    ==========================================================================
    137  08:07:37  -          0-0-1-0-3:7c777430-1622-4ad2-923e-40e7074f1df4
    126  08:07:24  -          0-0-1-0-3:GRST500.4398.1
qpid: show 137
Object of type: org.apache.qpid.broker:session:_data(9a57d0d2-8b17-8c84-4fac-5c9a96c2cf75)
    Attribute          137
    ============================================================
    vhostRef           0-0-1-0-3
    name               u'7c777430-1622-4ad2-923e-40e7074f1df4'
    channelId          1
    connectionRef      0-1447-1-0-34
    detachedLifespan   0
    attached           True
    expireTime         None
    maxClientRate      None
    framesOutstanding  0
    TxnStarts          0
    TxnCommits         0
    TxnRejects         0
    TxnCount           0
    clientCredit       0
qpid: show 126
Object of type: org.apache.qpid.broker:session:_data(9a57d0d2-8b17-8c84-4fac-5c9a96c2cf75)
    Attribute          126
    ======================================
    vhostRef           0-0-1-0-3
    name               u'GRST500.4398.1'
    channelId          1
    connectionRef      0-1447-1-0-12
    detachedLifespan   0
    attached           True
    expireTime         None
    maxClientRate      None
    framesOutstanding  0
    TxnStarts          0
    TxnCommits         0
    TxnRejects         0
    TxnCount           0
    clientCredit       0
qpid: 

...as neither the list nor the detail view for sessions use the id of that form.
"
Bug,QPID-1280,12404006,Performance degradation on shared queue with multiple consumers (and single producer),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Caused by fix to QPID-1261, r693518."
Bug,QPID-4036,12558899,Failed client connections permanently exhaust broker's max connections limit,,pcolby,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"I'm running a set of Qpid 0.16 C++ brokers with configuration like:

{code}
cluster-name=""mm-queue-cluster""
cluster-cman=yes
cluster-mechanism=PLAIN
cluster-username=broker
cluster-password=abc123
cluster-url=ssl:gateway02:5671

auth=yes

ssl-cert-db=/etc/qpid/certs/broker
ssl-cert-password-file=/etc/qpid/certs/pass.txt
ssl-cert-name=broker.messagemedia.com.au
require-encryption=yes
{code}

ie the broker is requiring both encryption and authentication (configured SASL mech list is CRAM-MD5 DIGEST-MD5 EXTERNAL PLAIN).

Now, if a client (let's use {{qpid-stat}} for example) connects via SSL (amqps) and authenticates successfully, then everything is happy.

However, if a client repeatedly fails to use SSL and/or fails to provide credentials, then the broker loses one of it's configured max connections every time!

So, for example, if we start the broker using the configuration shown above, then do this:

{code}for i in `seq 1 550`; do echo $i; qpid-stat -q ; done{code}

The above loop will report ~ 500 {{AuthenticationFailure}} errors, then switch to {{ConnectionError}} errors.  Once the {{ConnectionError}} errors begin, all further connections to the broker will be rejected - permanently (until the broker is restarted), with the broker logging:

{code}error Client max connection count limit exceeded: 500 connection refused{code}

From my testing, the following loops never cause an issue (with this configuration):

{code:none}
for i in `seq 1 550`; do echo $i; qpid-stat -b amqps://guest/guest@localhost -q ; done # Works as expected.
for i in `seq 1 550`; do echo $i; qpid-stat -b amqps://guest/wrong@localhost -q ; done # AuthenticationFailure as expected.
{code}

Whereas any of the following will break the broker:
{code:none}
for i in `seq 1 550`; do echo $i; qpid-stat -b amqp://guest/guest@localhost -q ; done # AuthenticationFailure, then ConnectionError.
for i in `seq 1 550`; do echo $i; qpid-stat -b amqp://guest/wrong@localhost -q ; done # AuthenticationFailure, then ConnectionError.
for i in `seq 1 550`; do echo $i; qpid-stat -b amqp://localhost -q ; done             # AuthenticationFailure, then ConnectionError.
for i in `seq 1 550`; do echo $i; qpid-stat -b amqps://localhost -q ; done            # AuthenticationFailure, then ConnectionError.
{code}"
Bug,QPID-1415,12407507,Seg fault detected under stress test,astitcher,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"==9801== Process terminating with default action of signal 11 (SIGSEGV)
==9801==  Access not within mapped region at address 0x74588C3C2
==9801==    at 0x3897443704: vfprintf (in /lib64/libc-2.5.so)
==9801==    by 0x38974693C9: vsnprintf (in /lib64/libc-2.5.so)
==9801==    by 0x389744D052: snprintf (in /lib64/libc-2.5.so)
==9801==    by 0x38974E6F6A: inet_ntoa (in /lib64/libc-2.5.so)
==9801==    by 0x538A19A: qpid::sys::SystemInfo::getLocalIpAddresses(unsigned
short, std::vector<qpid::Address, std::allocator<qpid::Address> >&) (in
/root/mrg_installed/lib/libqpidcommon.so.0.1.0)
==9801==    by 0x53A748B: qpid::Url::getIpAddressesUrl(unsigned short) (in
/root/mrg_installed/lib/libqpidcommon.so.0.1.0)
==9801==    by 0x4DAF874: qpid::broker::Broker::getKnownBrokersImpl() (in
/root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801==    by 0x4DBAC47: boost::_mfi::mf0<std::vector<qpid::Url,
std::allocator<qpid::Url> >,
qpid::broker::Broker>::operator()(qpid::broker::Broker*) const (in
/root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801==    by 0x4DBACF6: std::vector<qpid::Url, std::allocator<qpid::Url> >
boost::_bi::list1<boost::_bi::value<qpid::broker::Broker*>
>::operator()<std::vector<qpid::Url, std::allocator<qpid::Url> >,
boost::_mfi::mf0<std::allocator<qpid::Url>, qpid::broker::Broker>,
boost::_bi::list0>(boost::_bi::type<boost::_mfi::mf0<std::allocator<qpid::Url>,
qpid::broker::Broker> >, boost::_mfi::mf0<std::allocator<qpid::Url>,
qpid::broker::Broker>&, boost::_bi::list0&, long) (in
/root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801==    by 0x4DBAD43: boost::_bi::bind_t<std::vector<qpid::Url,
std::allocator<qpid::Url> >, boost::_mfi::mf0<std::vector<qpid::Url,
std::allocator<qpid::Url> >, qpid::broker::Broker>,
boost::_bi::list1<boost::_bi::value<qpid::broker::Broker*> > >::operator()()
(in /root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801==    by 0x4DBAD71:
boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<std::vector<qpid::Url,
std::allocator<qpid::Url> >, boost::_mfi::mf0<std::vector<qpid::Url,
std::allocator<qpid::Url> >, qpid::broker::Broker>,
boost::_bi::list1<boost::_bi::value<qpid::broker::Broker*> > >,
std::vector<qpid::Url, std::allocator<qpid::Url> >
>::invoke(boost::detail::function::any_pointer) (in
/root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801==    by 0x4DEA6FF: boost::function0<std::vector<qpid::Url,
std::allocator<qpid::Url> >, std::allocator<void> >::operator()() const (in
/root/mrg_installed/lib/libqpidbroker.so.0.1.0)
==9801== 
==9801== ERROR SUMMARY: 30 errors from 15 contexts (suppressed: 36 from 1)
==9801== "
Bug,QPID-3893,12546004,C++ broker appears to segfault during MultipleTransactedBatchProducerTest,astitcher,robbie,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"The C++ broker appears to segfault during MultipleTransactedBatchProducerTest. Several instances can be found in the history from our CI jobs:

https://builds.apache.org/job/Qpid-Java-Cpp-Test/496/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/494/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/493/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/491/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/486/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/484/
https://builds.apache.org/job/Qpid-Java-Cpp-Test/482/

During course of the latest test failure in #496 (logs attached), the broker logged receiving yet another TxCommit command:

{noformat}
BROKER: 2012-03-11 16:55:15 trace RECV [127.0.0.1:15672-127.0.0.1:34582]: Frame[BEbe; channel=0; {TxCommitBody: }] )
{noformat}

After this nothing else is ever logged from the broker process, but exceptions start flying from the client indicating the connections were reset:

{noformat}
IoReceiver - localhost/127.0.0.1:15672 2012-03-11 16:55:15,313 ERROR [apache.qpid.client.AMQConnectionDelegate_0_10] previous exception
org.apache.qpid.transport.ConnectionException: Connection reset
	at org.apache.qpid.transport.Connection.exception(Connection.java:512)
	at org.apache.qpid.transport.network.Assembler.exception(Assembler.java:107)
	at org.apache.qpid.transport.network.InputHandler.exception(InputHandler.java:199)
	at org.apache.qpid.transport.network.io.IoReceiver.run(IoReceiver.java:169)
	at java.lang.Thread.run(Thread.java:662)
Caused by: java.net.SocketException: Connection reset
	at java.net.SocketInputStream.read(SocketInputStream.java:168)
	at org.apache.qpid.transport.network.io.IoReceiver.run(IoReceiver.java:147)
	... 1 more
{noformat}

{noformat}
IoSender - localhost/127.0.0.1:15672 2012-03-11 16:55:15,313 ERROR [transport.network.io.IoSender] error in write thread
java.net.SocketException: Connection reset
	at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:96)
	at java.net.SocketOutputStream.write(SocketOutputStream.java:136)
	at org.apache.qpid.transport.network.io.IoSender.run(IoSender.java:313)
	at java.lang.Thread.run(Thread.java:662)
{noformat}

When the test tearDown occurs, it is logged that the broker process exited with an abnormal looking exit code, which a quick google suggests is the result of a segfault:
{noformat}
main 2012-03-11 16:56:29,949 INFO [qpid.test.utils.QpidBrokerTestCase] stopping broker on port : 15672
main 2012-03-11 16:56:29,949 INFO [qpid.test.utils.SpawnedBrokerHolder] Destroying broker process
main 2012-03-11 16:56:29,949 INFO [qpid.test.utils.SpawnedBrokerHolder] broker exited: 139
{noformat}

The test fails after 75sec, which is the exact time the test itself allows for the process undertaken to complete (artificially high to allow for extreme slowdowns on the CI nodes which happened occasionally in the past and also the C++ broker being slower at the test due to use of client side selectors; passing results show this usually takes 1-3sec on the Java broker and <10sec on the [transient] C++ broker), however the test harness tries to clean up the connections use in the test during tearDown and actually ends up reporting issues cleaning those up rather than the fact that the CountDownLatch used in the test wasnt decremented enough times.
"
Bug,QPID-986,12395058,Need to link libuuid.a to libqpidbroker.so and libqpidclient.so in Qpid/C++,,danushka,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"When I try to compile a repository working copy of Qpid/C++ I get a build error saying that there are undefined references to ""uuid_generate"" in both libqpidbroker.so and libqpidclient.so. When I was going through the makefile I found that libuuid.a is not linked to these two libs and I could easily get rid of the issue simply by modifying the makefile to link libuuid.a to these two libs."
Bug,QPID-488,12369102,Concurrent access to apr_pools (which are not thread safe),astitcher,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,The c++ codebase is now set to share an apr pool per process which is a problem as apr_pools are not thread safe.
Bug,QPID-4229,12603449,Durable subscription fails due to exclusiveness,,night,Closed,Fixed,2012-08-14 14:54,C++,C++ Broker,JMS AMQP 0-x,,,,,,"I want to run a test case where 20 subscribers register to a number of topics that 5 publishers publish to. This baseline test works and now I want to modify it to check whether durability works properly in QPID. The order is as follows:
1) Broker starts up
2) Subscribers announce a durable subscription and then terminate
3) Publishers send their messages and terminate
4) Broker restarts
5) Subscribers connect again and read their messages (without announcing the durable subscription again)

Once again I try to be JMS compliant and I am using ""Session.createDurableSubscriber(..)"". However, when I do that I get an error, because the subscriber wants to have an exclusive subscription to a wildcard queue:
javax.jms.JMSException: Error registering consumer: org.apache.qpid.AMQException: ch=0 id=2 ExecutionException(errorCode=RESOURCE_LOCKED, commandId=4, classCode=8, commandCode=1, fieldIndex=0, description=resource-locked: Cannot grant exclusive access to queue clientId:T.# (qpid/broker/SessionAdapter.cpp:332), errorInfo={}) [error code 405: Already exists]

But this is weird since I never specified exclusiveness and even trying to disable it does not work (I tried adding ""exclusive='false'"" in the connectionFactory string as well as ""; {exclusive: False}"" after the Destination address string."
Bug,QPID-8527,13379522,Hang in qpidd failing to resume read activity on TLS connections.,cliffjansen,cliffjansen,Resolved,Fixed,2021-05-20 14:38,C++,C++ Broker,,,,,,,"The Posix AsynchIO implementation imposes a timeslice on read and write activity to promote resource fairness between AMQP connections.

This mechanism relies on the poller to reschedule the suspended read activity which it does when it sees unread bytes on the socket. This works for normal TCP sockets. It can fail for TLS connections if the TLS layer (libnss) has buffered bytes that are ""hidden"" from the poller.

The write side doesn't get starved or fail to notice when a socket is unblocked for writing in the TLS case.

Posix only. The Windows implementation relies on the read and write completions being fairly evenly distributed between connections."
Bug,QPID-8430,13292947,[qpid-cpp] Excessive memory use when rerouting messages,kpvdr,kpvdr,Closed,Fixed,2021-03-31 0:06,C++,C++ Broker,,,,,,,"When a message is rerouted several times, the broker's used memory increases rapidly. This is counter-intuitive, considering that the messages themselves are only passing from one queue to another. There is no evidence of a leak, however, only a large growth in consumed memory.

An investigation has shown that the process of clearing traces from the message when rerouting (whether they exist or not) causes the message and its frames to be copied (for reasons of avoiding locks on the message, which can affect performance)."
Bug,QPID-8425,13290829,[qpid-cpp] Channel leak on federation links,kpvdr,kpvdr,Resolved,Fixed,2021-03-31 0:06,C++,C++ Broker,,,,,,,"If a broker is repeatedly killed and restarted when it is federated to another broker, the second broker will run out of channels with a ""channel pool is empty"" message. The channel being used for the federation link is not being returned to the channel pool, and eventually (after ~32k restarts), the channel pool becomes exhausted.

A reproducer is contained in the attached file ""channel_test.sh"". If a small change is made to the Link.cpp constructor which shrinks the channel pool to 5 (see the diff below), then this test will show the error without having to wait hours for ~32k restarts. The test does 10 restarts.
{noformat}
diff --git a/src/qpid/broker/Link.cpp b/src/qpid/broker/Link.cpp
index 14737e730..790c8ac5e 100644
--- a/src/qpid/broker/Link.cpp
+++ b/src/qpid/broker/Link.cpp
@@ -149,7 +149,7 @@ Link::Link(const string& _name,
 currentInterval(1),
 reconnectNext(0), // Index of next address for reconnecting in url.
 nextFreeChannel(1),
- freeChannels(1, framing::CHANNEL_MAX),
+ freeChannels(1, 6),
 connection(0),
 agent(0),
 listener(l),
{noformat}

Running the test with the above temporary patch, the following is observed:

{noformat}
Channel allocations from broker 6001:
3377:2020-03-06 13:29:36 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 1
3538:2020-03-06 13:29:36 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 2
3739:2020-03-06 13:29:39 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 3
3934:2020-03-06 13:29:43 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 4
4022:2020-03-06 13:29:47 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 5
4110:2020-03-06 13:29:51 [System] debug Exception constructed: Link qpid.tcp:localhost:5001 channel pool is empty
4111:2020-03-06 13:29:51 [System] error Link qpid.tcp:localhost:5001 channel pool is empty
4154:2020-03-06 13:29:52 [System] debug Exception constructed: Link qpid.tcp:localhost:5001 channel pool is empty
4155:2020-03-06 13:29:52 [System] error Link qpid.tcp:localhost:5001 channel pool is empty
4253:2020-03-06 13:29:55 [System] debug Exception constructed: Link qpid.tcp:localhost:5001 channel pool is empty
4254:2020-03-06 13:29:55 [System] error Link qpid.tcp:localhost:5001 channel pool is empty
4297:2020-03-06 13:29:56 [System] debug Exception constructed: Link qpid.tcp:localhost:5001 channel pool is empty
4298:2020-03-06 13:29:56 [System] error Link qpid.tcp:localhost:5001 channel pool is empty
...
(repeated several times more)
{noformat}
혻
A fix which returns the channels on links that are closing to the channel pool is suggested in attached patch BZ1748054.patch. With this patch applied (together with the temporary pool-shrink patch above), the following is now observed:

{noformat}
Channel allocations from broker 6001:
2020-03-06 12:20:59 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 1
2020-03-06 12:20:59 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 2
2020-03-06 12:21:02 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 3
2020-03-06 12:21:06 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 4
2020-03-06 12:21:10 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 5
2020-03-06 12:21:14 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 1
2020-03-06 12:21:18 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 3
2020-03-06 12:21:22 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 4
2020-03-06 12:21:26 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 5
2020-03-06 12:21:30 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 1
2020-03-06 12:21:34 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 3
2020-03-06 12:21:38 [Broker] debug Link qpid.tcp:localhost:5001 allocates channel: 4
{noformat}

Channel 2 is used by a bridge which remains open (qpid.bridge_session_amq.fanout). The channels are re-used in a cyclical pattern, which I think is the intention."
Bug,QPID-7709,13055938,Problem building on Fedora rawhide,astitcher,iboverma,Resolved,Fixed,2021-03-02 3:44,C++,C++ Broker,,,,,,,"Fails to build in Fedora rawhide:
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/Selector.cpp: In member function 'const qpid::broker::Value qpid::broker::MessageSelectorEnv::specialValue(const string&) const':
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/Selector.cpp:169:11: error: 'v' may be used uninitialized in this function [-Werror=maybe-uninitialized]
         v = Value();
         ~~^~~~~~~~~
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp: In member function 'qpid::broker::Expression* qpid::broker::Parse::orExpression(qpid::broker::Tokeniser&)':
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
cc1plus: all warnings being treated as errors
make[2]: *** [src/CMakeFiles/qpidbroker.dir/build.make:3234: src/CMakeFiles/qpidbroker.dir/qpid/broker/Selector.cpp.o] Error 1
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp: In member function 'qpid::broker::Expression* qpid::broker::Parse::unaryArithExpression(qpid::broker::Tokeniser&)':
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/broker/SelectorExpression.cpp:1041:13: error: '*((void*)& s +17)' may be used uninitialized in this function [-Werror=maybe-uninitialized]
     if (s[1]=='b' || s[1]=='B') {
cc1plus: all warnings being treated as errors
make[2]: *** [src/CMakeFiles/qpidbroker.dir/build.make:3258: src/CMakeFiles/qpidbroker.dir/qpid/broker/SelectorExpression.cpp.o] Error 1"
Bug,QPID-5285,12677026,[AMQP 1.0] timestamped messages not supported,gsim,gsim,Resolved,Fixed,2020-09-23 9:58,C++,C++ Broker,,,,,,,"There is a timestamping feature in qpidd that if enabled sets the timestamp field of the AMQP 0-10 delivery-properties when a message arrives at the broker.

There is no equivalent field defined in the AMQP 1.0 specification. Thus this feature is at present not supported over 1.0 (i.e. messages delivered over 1.0 will not have the timestamp set).

An annotation could be defined to convey the timestamp for 1.0 messages. This could also be used in translating between 0-10 and 1.0 formats."
Bug,QPID-8186,13158424,Incorrect exception handling fails to build on GCC 8,jross,crichardson,Closed,Fixed,2019-12-14 23:30,C++,C++ Broker,,,,,,,"[ 22%] Building CXX object src/CMakeFiles/qpidcommon.dir/qpid/sys/ssl/check.cpp.o
/home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/sys/posix/SocketAddress.cpp: In member function ?쁞ool qpid::sys::SocketAddress::isComparable(const qpid::sys::SocketAddress&) const??
/home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/sys/posix/SocketAddress.cpp:208:18: error: catching polymorphic type ?쁟lass qpid::Exception??by value [-Werror=catch-value=]
 } catch (Exception) {
 ^~~~~~~~~
/home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/sys/posix/SocketAddress.cpp:212:14: error: catching polymorphic type ?쁟lass qpid::Exception??by value [-Werror=catch-value=]
 } catch (Exception) {
 ^~~~~~~~~

혻

혻

these ""catch (Exception)"" statements would better be const ref, which would also fix the build failure."
Bug,QPID-8187,13158428,Incompatible callback function pointer casts fail to build on GCC 8,jross,crichardson,Closed,Fixed,2019-12-14 23:29,C++,C++ Broker,,,,,,,"{quote}[ 22%] Building CXX object src/CMakeFiles/qpidcommon.dir/qpid/sys/epoll/EpollPoller.cpp.o
 /home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/SaslFactory.cpp: In constructor ?쁰pid::CyrusSasl::CyrusSasl(const string&, const string&, const string&, const string&, int, int, bool)??
 /home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/SaslFactory.cpp:215:46: error: cast between incompatible function types from ?쁦nt (*)(void*, int, const char**, unsigned int*)??to ?쁦nt (*)()??[-Werror=cast-function-type]
 callbacks[i].proc = (CallbackProc*) &getUserFromSettings;
 ^~~~~~~~~~~~~~~~~~~
 /home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/SaslFactory.cpp:223:50: error: cast between incompatible function types from ?쁦nt (*)(sasl_conn_t*, void*, int, sasl_secret_t**)??
Unknown macro: \{aka ?쁦nt (*)(sasl_conn*, void*, int, sasl_secret**)??
to ?쁦nt (*)()??[-Werror=cast-function-type]
 callbacks[i].proc = (CallbackProc*) &getPasswordFromSettings;
 ^~~~~~~~~~~~~~~~~~~~~~혻
{quote}
Given the constrains of the SASL library interface, the only obvious solution for this I can think of is to add ""-Wno-error=cast-function-type"" to the compiler settings."
Bug,QPID-6271,12761750,[AMQP 1.0] receivers never removed from sessions list,,gsim,Closed,Fixed,2019-10-02 19:21,C++,C++ Broker,,,,,,,"The amqp-1.0-client Session records every created Receiver in its private _receivers list. There is a package visible removeReceiver() method, but I can't find any use of that.

So even when a receiver is closed, it remains in the sessions list.  I came across this while investigating an apparent leak with a jms QueueBrowser, but just from inspection it looks slightly wider in applicability."
Bug,QPID-5084,12664400,Track durable queue ownership across broker restarts,,eallen,Closed,Fixed,2019-10-02 17:34,C++,C++ Broker,,,,,,,"When creating/deleting durable queues, their ""owner"" isn't tracked after restart. Therefore it is possible to exceed queue quotas after a restart.

Set ACL limit on a user to 10 queues
Create 10 durable queues for that user
Restart the broker
The 10 durable queues are automatically recovered 
The user can now create an additional 10 queues
"
Bug,QPID-7674,13043028,Broker bulid problem with GCC 7,aconway,aconway,Resolved,Fixed,2019-06-19 13:52,C++,C++ Broker,,,,,,,"Build fails with GCC 7 as described in 
https://bugzilla.redhat.com/show_bug.cgi?id=1421112

{noformat}
       case 0x01: out = in->getIntegerValue<int8_t>(); break;
       ^~~~
/builddir/build/BUILD/qpid-cpp-1.35.0/src/qpid/amqp_0_10/Codecs.cpp:111:33: error: this statement may fall through [-Werror=implicit-fallthrough=]
{noformat}"
Bug,QPID-8313,13233294,broker tries to send error message on connection-close that is longer than max str8,gsim,gsim,Resolved,Fixed,2019-05-14 17:58,C++,C++ Broker,,,,,,,"This is on the AMQP 0-10 path and results in errors like: closed by error: illegal-argument:
Value for replyText is too large"
Bug,QPID-8248,13190758,qpid-config lists deleted exchange,gsim,gsim,Closed,Fixed,2019-04-24 9:07,C++,C++ Broker,,,,,,,"In AMQP 0-10, the last exchange to which a message is sent is cached for improved performance. However this means that the exchange object will not be freed when deleted from the registry until all references to it are freed.

To reproduce:

혻{noformat}
 1. qpid-config add exchange foo
 2. qpid-send -a foo --content-stdin
 3. enter some text to send a message
 4. in another console qpid-config dell exchange foo
 5. qpid-config exchanges
{noformat}

Should not see the deleted exchange in step 5."
Bug,QPID-8155,13150124,Late changes to -Werror are broken in windows,jross,chug,Closed,Fixed,2019-04-24 9:07,C++,C++ Broker,,,,,,,"Commit 5d28224 2018-03-12 19:37:14 breaks windows build Visual Studio 2013, x64 with

{{Command line error D8021: invalid numeric argument '/Werror'}}

Every C++ project fails to compile.

Reverting just that commit allows the build to proceed.

혻"
Bug,QPID-7926,13105236,"[c++ broker] Windows build error ""cannot convert from 'int' to 'qpid::sys::PODMutex""",chug,chug,Closed,Fixed,2019-04-24 9:07,C++,C++ Broker,,,,,,,"{noformat}
1>------ Build started: Project: qpidcommon, Configuration: Debug x64 ------
1>  Logger.cpp
1>D:\Users\crolke\git\qpid-cpp\src\qpid\log\Logger.cpp(48): error C2440: 'initializing' : cannot convert from 'int' to 'qpid::sys::PODMutex'
1>          No constructor could take the source type, or constructor overload resolution was ambiguous
{noformat}

The issue is with the definition of QPID_MUTEX_INITIALIZER.
In Linux it is defined as PTHREAD_MUTEX_INITIALIZER which is a complex structure initializer.
In Windows it is a naked 0.

In a stand-alone windows program
{noformat}
std::is_pod<PODMutex>::value
{noformat}
returns false. In Linux the same statement in qpidd broker returns true."
Bug,QPID-8226,13177526,build up of 'unacknowledged' deliveries for browsing client,gsim,gsim,Closed,Fixed,2019-04-24 9:07,C++,C++ Broker,,,,,,,"A receiver with accept-mode=1 and acquire-mode=1 will cause the broker to keep accumulating delivery records.
"
Bug,QPID-8188,13158434,Invalid type qualifiers causes build failure on GCC 8,jross,crichardson,Closed,Fixed,2019-04-24 9:07,C++,C++ Broker,,,,,,,"[ 30%] Building CXX object src/CMakeFiles/qpidcommon.dir/qpid/sys/Dispatcher.cpp.o
/home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/log/Statement.cpp: In static member function ?쁲tatic qpid::log::Category qpid::log::CategoryFileNameHints::categoryOf(const char*)??
/home/chrisr/projects/qpid/qpid-cpp/source/src/qpid/log/Statement.cpp:121:50: error: type qualifiers ignored on cast result type [-Werror=ignored-qualifiers]
 if (strstr(fName, (const char* const)it->first) != 0) {"
Bug,QPID-8288,13223843,timeout on connection that is not writable does not cleanup on primary,gsim,gsim,Resolved,Fixed,2019-04-24 9:05,C++,C++ Broker,,,,,,,"If an incoming socket from a backup is not writable at the point it times out, then the sessions get cleaned up but the connection observers are not notified of the closed connection (as the code used by the io layer is not yet deleted; it is only deleted when the socket is writable). 

For the primary in an ha cluster this means it does not fully handle the lost connection."
Bug,QPID-8287,13223842,deadlock between queue cleaner and link io thread on ha backup,gsim,gsim,Resolved,Fixed,2019-04-24 9:05,C++,C++ Broker,,,,,,,"The queue cleaner and link io processing threads take the queue lock and queue replicator lock in different order, which can cause deadlocks."
Bug,QPID-8293,13225210,queue cleaning locks up connections,gsim,gsim,Resolved,Fixed,2019-04-24 9:05,C++,C++ Broker,,,,,,,"The queue cleaner thread currently holds the queue lock while purging all the expired messages. This can cause worker threads to be blocked waiting for this lock. Particularly when expired messages are logged, this can result in those threads being blocked for significant periods of time during which they are unable to handle heartbeating or even closing of the connection."
Bug,QPID-8209,13166041,qpidd segfault with huge backtrace when deleting autoDel queue just being auto-deleted,cliffjansen,pmoravec,Resolved,Fixed,2018-10-18 1:14,C++,C++ Broker,,,,,,,"Description of problem:
When below two actions happen concurrently on an auto-delete queue (without auto-del timeout), qpidd segfaults.

Two actions:
- detaching (latest) consumer of the auto-del queue
- deleting the queue in either way (i.e. via QMF or by sending proper AMQP performative)

cause that:

- segfaulting thread from the detach event has backtrace like:
#0  0x00007f9af745f40d in ScopedLock (this=0x7f9adc6c5a88, expectedVersion=1) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/sys/Mutex.h:33
#1  qpid::broker::Queue::tryAutoDelete (this=0x7f9adc6c5a88, expectedVersion=1) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1348
#2  0x00007f9af745eed4 in qpid::broker::Queue::scheduleAutoDelete (this=0x7f9adc6c5a88, immediate=false) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1339
#3  0x00007f9af745f524 in qpid::broker::Queue::tryAutoDelete (this=0x7f9adc6c5a88, expectedVersion=<value optimized out>) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1367
#4  0x00007f9af745eed4 in qpid::broker::Queue::scheduleAutoDelete (this=0x7f9adc6c5a88, immediate=false) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1339
..
#12012 0x00007f9af745eed4 in qpid::broker::Queue::scheduleAutoDelete (this=0x7f9adc6c5a88, immediate=false) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1339
#12013 0x00007f9af74601c6 in qpid::broker::Queue::cancel (this=0x7f9adc6c5a88, c=..., connectionId=""qpid.127.0.0.1:5672-127.0.0.1:56736"", userId=""anonymous"")
    at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:637
..

- other thread trying to delete the queue has bt like:

#0  0x000000343ee11016 in qpid::broker::Exchange::propagateFedOp (this=0x260ee30, routingKey=""autoDel_93"", tags="""", op=""U"", origin="""", extra_args=0x0)
    at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Exchange.cpp:344
#1  0x000000343ee66baf in qpid::broker::DirectExchange::unbind (this=0x260edd0, queue=..., routingKey=""autoDel_93"", args=<value optimized out>)
    at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/DirectExchange.cpp:159
#2  0x000000343eeac7c9 in qpid::broker::QueueBindings::unbind (this=<value optimized out>, exchanges=..., queue=...) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/QueueBindings.cpp:47
#3  0x000000343ee39b1d in qpid::broker::Queue::unbind (this=<value optimized out>, exchanges=<value optimized out>) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1208
#4  0x000000343ee39ca6 in qpid::broker::Queue::destroyed (this=0x7ff820308810) at /usr/src/debug/qpid-cpp-1.36.0/src/qpid/broker/Queue.cpp:1162
#5  0x000000343eeb1027 in qpid::broker::QueueRegistry::destroy (this=0x2606278, name=""autoDel_93"", connectionId=""qpid.127.0.0.1:5672-127.0.0.1:39240"", userId=""anonymous"")
..


The segfault happens since depth of the backtrace exceeds some limit.


Version-Release number of selected component (if applicable):
current upstream
1.36
1.38
How reproducible:
randomly, but 100% in 1 hour


Steps to Reproduce:
compile C++ program to delete a queue via QMF - attached at the botton
run below script with optionally updated parameters, such that numbers of ""resource-deleted"" (from qpid-receive) and ""Delete failed. No such queue"" (from delete_queue) errors are similar (i.e. the events to trigger the race condition happen usually at very similar time)


queues=125
slept=0.9922
for i in $(seq 1 $queues); do
        while true; do
                qpid-receive -a ""autoDel_${i}; \{create:always, node:{ x-declare:{auto-delete:True}}}"" --timeout=1 &
                sleep $slept
                delete_queue autoDel_${i}
                sleep 1
        done &
        sleep 0.1
done


Actual results:
within a hour, segfault with above backtraces


Expected results:
no segfault


Additional info:
delete_queue.cpp :

#include <cstdlib>
#include <iostream>

#include <sstream>

#include <qpid/messaging/Address.h>
#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Session.h>


using namespace qpid::messaging;
using namespace qpid::types;

using std::stringstream;
using std::string;

int main(int argc, char** argv) \{
    const char* queue_name = argc>1 ? argv[1] : ""queue_name"";
    const char* url = argc>2 ? argv[2] : ""amqp:tcp:127.0.0.1:5672"";

    Connection connection(url/*, connectionOptions*/);
    try {
        connection.open();
        Session session = connection.createSession();
        Sender sender = session.createSender(""qmf.default.direct/broker"");
        Address responseQueue(""#reply-queue; {create:always, node:{x-declare:{auto-delete:true}}}"");
        Receiver receiver = session.createReceiver(responseQueue);

        Message message;
        Variant::Map content;
	Variant::Map OID;
	Variant::Map arguments;
	OID[""_object_name""] = ""org.apache.qpid.broker:broker:amqp-broker"";
	arguments[""type""] = ""queue"";
	arguments[""name""] = queue_name;
	
        content[""_object_id""] = OID;
        content[""_method_name""] = ""delete"";
        content[""_arguments""] = arguments;
	
        encode(content, message);
	message.setReplyTo(responseQueue);
	message.setProperty(""x-amqp-0-10.app-id"", ""qmf2"");
	message.setProperty(""qmf.opcode"", ""_method_request"");

        sender.send(message, true);
	
	Message response;
	if (receiver.fetch(response,qpid::messaging::Duration(30000)) == true)
	\{
		qpid::types::Variant::Map recv_props = response.getProperties();
		if (recv_props[""x-amqp-0-10.app-id""] == ""qmf2"")
			if (recv_props[""qmf.opcode""] == ""_method_response"")
				std::cout << ""Response: OK"" << std::endl;
			else if (recv_props[""qmf.opcode""] == ""_exception"")
				std::cerr << ""Error: "" << response.getContent() << std::endl;
			else
				std::cerr << ""Invalid response received!"" << std::endl;
		else
			std::cerr << ""Invalid response not of qmf2 type received!"" << std::endl;
	}
	else
		std::cout << ""Timeout: No response received within 30 seconds!"" << std::endl;

        connection.close();
        return 0;
    } catch(const std::exception& error) \{
        std::cout << error.what() << std::endl;
        connection.close();
    }
    return 1;
}"
Bug,QPID-8184,13157701,[linearstore] Recovery intermittently produces JERR_EFP_BADEFPDIRNAME error followed by core,kpvdr,kpvdr,Resolved,Fixed,2018-05-15 14:06,C++,C++ Broker,,,,,,,"Some users are experiencing difficulty recovering the store, especially when there are a large혻 number of queues (several thousand). The log files show the following pattern:

{{JERR_EFP_BADEFPDIRNAME}} in which some arbitrary number which is not divisible by 4 is being used as the EFP file size (called EFP directory in the log), followed by a segfault:
{noformat}
May 4 18:55:00 somehostname qpidd[6240]: 2018-05-04 18:55:00 [Store] warning Linear Store: EmptyFilePool create failed: jexception 0x0d03 EmptyFilePool::fileSizeKbFromDirName() threw JERR_EFP_BADEFPDIRNAME: Bad Empty File Pool directory name (must be 'NNNk', where NNN is a number which is a multiple of 4) (Partition: 1; EFP directory: '9k')
May 4 18:55:00 somehostname kernel: qpidd[6240]: segfault at 10 ip 00007f4219af8e19 sp 00007ffc227a6350 error 4 in linearstore.so[7f4219ac4000+bd000]{noformat}
혻In the event that the random number _is_ divisible by 4, a randomly sized directory containing no files may appear in the partition EFP."
Bug,QPID-8118,13143280,qpidd crashes at startup in certain conditions,gsim,derUhu,Closed,Fixed,2018-04-03 23:23,C++,C++ Broker,,,,,,,On my debian/sid system qpidd crashed at startup. Quick investigation has shown that the problem was in deviceCount() function from rdma_wrap.cpp module. Patch with fix is attached.
Bug,QPID-7877,13091985,"[linearstore] Recent change to journal-flush-timeout parameter changed units, limited minimum value to 1ms",kpvdr,kpvdr,Closed,Fixed,2018-03-13 23:33,C++,C++ Broker,,,,,,,"A recent checkin for QPID-7666 changed the way the {{journal-flush-timeout}} parameter for the linearstore is handled. This change caused the value to be an integer millisecond value with a minimum of 1ms.  This means:
* A relatively arbitrary lower limit has been suddenly applied;
* Existing configuration files are no longer valid and would either cause the broker to stop with an error or could in some cases continue running with a different interpretation of the number (where the original timeout is an integer > 1).

This fix needs to be rolled back and the original handling of the parameter needs to be restored."
Bug,QPID-7676,13043313,[linearstore] Recent commit introduced C++11 dependency,kpvdr,kpvdr,Closed,Fixed,2018-03-13 23:32,C++,C++ Broker,,,,,,,"A recent commit to linearstore added a call to {{std::round(f)}} which is only supported in C++11.

Replace with {{std::floor(f + 0.5)}}"
Bug,QPID-7651,13039214,[linearstore] Using write page cache sizes of 1 and 2 (kiB) cause floating point exception on startup,kpvdr,kpvdr,Resolved,Fixed,2017-11-22 12:27,C++,C++ Broker,,,,,,,"The help for linearstore parameter wcache-page-size indicates that legal values are powers of 2 between 1 and 128. In addition, the validation for this parameter allows these values. However, the minimum value should be 4, and using either 1 or 2 as a value will cause a floating point exception when the broker is started."
Bug,QPID-7669,13042093,Unintended UI changes from switch to swigged Python client for management tools,aconway,jross,Resolved,Fixed,2017-11-22 9:54,C++,C++ Broker,C++ Client,,,,,,http://qpid.2158936.n2.nabble.com/Qpid-tools-with-python-vs-qpid-cpp-messaging-td7659017.html
Bug,QPID-8037,13118724,"Compile error on Windows, Visual Studio 2017",chug,chug,Resolved,Fixed,2017-11-16 0:20,C++,C++ Broker,,,,,,,"Compile error on Windows using Visual Studio 2017:
{noformat}
'auto_ptr' is not a member of 'std'
{noformat}
in project msclfs_store.

Other similar errors in the same module
"
Bug,QPID-7975,13110292,[linearstore] Sending durable messages using AMQP 1.0 and 0-10 concurrently causes high latency for 1.0 messages,kpvdr,kpvdr,Resolved,Fixed,2017-11-15 11:29,C++,C++ Broker,,,,,,,"When durable messages are sent to the same queue using both AMQP 1.0 and 0-10 concurrently, a condition is triggered where the store no longer flushes the 1.0 messages. When this condition is triggered, the 1.0 messages are flushed by the 0-10 activity on the queue, or if there is none, then the messages are never flushed."
Bug,QPID-7876,13091662,qpid-route does not properly consider src-local when matching bridges,gsim,chris.richardson,Resolved,Fixed,2017-09-29 21:32,C++,C++ Broker,,,,,,,"qpid-route does not properly consider src-local when matching bridges. The practical upshot of this is that it may consider routes to be duplicates when they are in fact not.

Take the following (slightly contrived) scenario:
Brokers A and B both have queues named ""test.queue"" and default exchanges named ""amq.direct"".
We would like a queue route to pull messages from B:test.queue to A:amq.direct and a src_local route to push messages from A:test.queue to B:amq.direct. Since qpid-route does not consider the src-local flag, it will regard the second route to be a duplicate and will not allow it to be added.
"
Bug,QPID-7895,13096781,[linearstore] Excessive CPU utilization for some kernel clocksources,kpvdr,kpvdr,Resolved,Fixed,2017-09-29 17:58,C++,C++ Broker,,,,,,,"For some kernel clocksources (eg acpi_pm), it has been observed that there is an excessively high CPU utilization which correlates with the linearstore's flush timeout being set to a very low value (100us).  This is a problem for some customers which require almost instant flush to obtain pseudo-synchronous store behavior (hence the 100us flush timer) and run many brokers (up to hundreds) on a single machine.  In these cases, the CPU is 100% utilized.

A check of the source shows that the flush timer is firing continuously, irrespective of whether any disk I/O has taken place.

It is proposed that a change to linearstore be made which will only run the timer when needed (ie while there is content in the write buffers that needs flushing)."
Bug,QPID-7788,13073090,Linearstore doesnt move to EFP latest journal files when deleting a durable queue,pmoravec,pmoravec,Resolved,Fixed,2017-05-18 11:27,C++,C++ Broker,,,,,,,"When deleting an empty durable queue, the last empty page that it held is not moved to EFP but dropped.

Even more, when deleting a non-empty durable queue where the queue content spans more than the last file, no such `jrnl` file is returned to EFP.

That makes `/var/lib/qpidd/.qpidd/qls/p001/efp/2048k/in_use` (or similar directory depending to configuration) growing over time."
Bug,QPID-7786,13073068,qpidd segfaults during startup when SSL certificate cant be read,pmoravec,pmoravec,Resolved,Fixed,2017-05-18 10:19,C++,C++ Broker,,,,,,,"When qpidd can't read NSS password file, or when SSL certificate name is not found / readable in the NSS database, qpidd segfaults at startup with backtrace:

{code}
(gdb) bt
#0  0x00007f3010a4f704 in qpid::sys::SocketAddress::nextAddress (this=this@entry=0x7ffe36dc0570) at /usr/src/debug/qpid-cpp-0.34/src/qpid/sys/posix/SocketAddress.cpp:321
#1  0x00007f301113ec17 in qpid::sys::SocketAcceptor::listen (this=this@entry=0x29bf500, interfaces=..., port=port@entry=5671, backlog=backlog@entry=10, factory=...)
    at /usr/src/debug/qpid-cpp-0.34/src/qpid/sys/SocketTransport.cpp:150
#2  0x00007f3010fdfdbb in qpid::sys::SslPlugin::initialize (this=0x7f3011407180 <qpid::sys::sslPlugin>, target=...) at /usr/src/debug/qpid-cpp-0.34/src/qpid/sys/SslPlugin.cpp:126
#3  0x00007f3010a876af in operator() (a1=..., p=<optimized out>, this=<synthetic pointer>) at /usr/include/boost/bind/mem_fn_template.hpp:165
#4  operator()<boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list1<qpid::Plugin* const&> > (a=<synthetic pointer>, f=<synthetic pointer>, 
    this=<synthetic pointer>) at /usr/include/boost/bind/bind.hpp:313
#5  operator()<qpid::Plugin*> (a1=@0x2488ce0: 0x7f3011407180 <qpid::sys::sslPlugin>, this=<synthetic pointer>) at /usr/include/boost/bind/bind_template.hpp:47
#6  for_each<__gnu_cxx::__normal_iterator<qpid::Plugin* const*, std::vector<qpid::Plugin*> >, boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > > (__f=..., __last=..., __first=<qpid::sys::sslPlugin>) at /usr/include/c++/4.8.2/bits/stl_algo.h:4417
#7  qpid::(anonymous namespace)::each_plugin<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > > (f=...) at /usr/src/debug/qpid-cpp-0.34/src/qpid/Plugin.cpp:73
#8  0x00007f3010a877a2 in qpid::Plugin::initializeAll (t=...) at /usr/src/debug/qpid-cpp-0.34/src/qpid/Plugin.cpp:91
#9  0x00007f3010ffc99a in qpid::broker::Broker::Broker (this=0x249bae0, conf=...) at /usr/src/debug/qpid-cpp-0.34/src/qpid/broker/Broker.cpp:376
#10 0x0000000000405c82 in qpid::broker::QpiddBroker::execute (this=this@entry=0x7ffe36dc284e, options=0x24909a0) at /usr/src/debug/qpid-cpp-0.34/src/posix/QpiddBroker.cpp:229
#11 0x0000000000409d04 in qpid::broker::run_broker (argc=3, argv=0x7ffe36dc2be8, hidden=<optimized out>) at /usr/src/debug/qpid-cpp-0.34/src/qpidd.cpp:108
#12 0x00007f300fb0db35 in __libc_start_main (main=0x404ce0 <main(int, char**)>, argc=3, ubp_av=0x7ffe36dc2be8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, 
    stack_end=0x7ffe36dc2bd8) at ../csu/libc-start.c:274
#13 0x0000000000404f51 in _start ()
(gdb) list
316	        (void) getAddrInfo(*this);
317	    }
318	}
319	
320	bool SocketAddress::nextAddress() const {
321	    bool r = currentAddrInfo->ai_next != 0;
322	    if (r)
323	        currentAddrInfo = currentAddrInfo->ai_next;
324	    return r;
325	}
(gdb) p currentAddrInfo
$2 = (addrinfo *) 0x0
(gdb) 
{code}

It is OK if the broker won't start, but it should not segfault."
Bug,QPID-6822,12909639,"Failure on: qpid-config add queue --durable ""queue-id""",kpvdr,peterlacko,Closed,Fixed,2017-03-20 17:32,C++,C++ Broker,,,,,,,"Attempt to create durable queue fails with:
{noformat}
$ qpid-config add queue --durable ""queue""
Failed: Exception: Exception from Agent: {u'error_code': 7, u'error_text': 
'Queue queue: create() failed: jexception 0x010c 
EmptyFilePool::createSymLink() threw JERR__SYMLINK: Symbolic link 
operation failed (file=/var/lib/qpidd/.qpidd/qls/p001/efp/2048k/in_use
/85570c5b-b2ca-4883-bf86-8df746ac6ee4.jrnl symlink=/var/lib/qpidd/.qpidd
/qls/jrnl2/queue/85570c5b-b2ca-4883-bf86-8df746ac6ee4.jrnl errno=13 
(Permission denied)) (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/linearstore
/MessageStoreImpl.cpp:425)'}
{noformat}
Queue is created succesfully without {{--durable}} parameter.
Problem occures after doing {{yum update}}. All qpid packages versions listed below, before and after performing update:
{noformat}
$ diff qpid-before-update.txt qpid-after-update.txt
1,10c1,10
< python-gofer-qpid.noarch   2.6.6-1.git.48.3141846.el7
< python-qpid.x86_64         0.32-3.el7          @epel
< python-qpid-common.x86_64  0.32-3.el7          @epel
< python-qpid-qmf.x86_64     0.28-29.el7         @epel
< qpid-cpp-client.x86_64     0.32-3.el7          @epel
< qpid-cpp-server.x86_64     0.32-3.el7          @epel
< qpid-cpp-server-store.x86_64
< qpid-proton-c.x86_64       0.9-3.el7           @epel
< qpid-qmf.x86_64            0.28-29.el7         @epel
< qpid-tools.x86_64          0.32-3.el7          @epel
---
> python-gofer-qpid.noarch   2.6.6-2.el7         @pulp-2.7-beta
> python-qpid.noarch         0.32-9.el7          @epel
> python-qpid-common.noarch  0.32-9.el7          @epel
> python-qpid-qmf.x86_64     0.32-1.el7          @epel
> qpid-cpp-client.x86_64     0.34-4.el7          @epel
> qpid-cpp-server.x86_64     0.34-4.el7          @epel
> qpid-cpp-server-linearstore.x86_64
> qpid-proton-c.x86_64       0.10-2.el7          @epel
> qpid-qmf.x86_64            0.32-1.el7          @epel
> qpid-tools.noarch          0.32-9.el7          @epel
{noformat}
"
Bug,QPID-3187,12503313,No exception handling for many timer tasks in broker,gsim,gsim,Closed,Fixed,2017-03-14 20:08,C++,C++ Broker,,,,,,,"The assumption in Timer appears to be that no thread will ever throw from TimerTask::fire(). In practice however few of the implementations of that method in the broker take any measures to ensure that is the case. If code called on a timer thread throws there is therefore the risk of the broker terminating (I have observed such a case for example on the management periodic processing).

It would probably be advisable to add some generic protection for this."
Bug,QPID-2102,12435628,Exceeding reject queue policy under a transaction causes broker crash ,,gsim,Closed,Fixed,2017-03-14 20:08,C++,C++ Broker,,,,,,,"To reproduce:

Start a broker.
Use qpid-tool to create a queue with a reject policy and a count limit of 5.
Enqueue 10 records under a single transaction to that queue.
Prepare and commit the transaction.
Broker crashes.
"
Bug,QPID-3363,12514432,broker allows unbind on default exchange,gsim,gsim,Closed,Fixed,2017-03-14 20:07,C++,C++ Broker,,,,,,,"Rule 'default-access' states ""The default exchange MUST NOT be accessible to the client except by specifying an empty exchange name in a content publish command (such as message.transfer). That is, the server must not let clients explicitly bind, unbind, delete, or make any other reference to this exchange."" 


However qpid-config unbind """" my-queue my-queue will delete the binding preventing the queue from being directly accessed."
Bug,QPID-3298,12509700,bindings with x-match:all on headers exchange do not work correctly with dynamic federation,gsim,gsim,Closed,Fixed,2017-03-14 20:07,C++,C++ Broker,,,,,,,"I believe the issue is that the arguments used in the binding include the extra control arguments for fed.origin etc and as these are not specified in the messages, they do not match the binding.

Using x-match:any works as expected."
Bug,QPID-3208,12504387,Exchanges make best effort to route messages if there is an error.,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Broker,,,,,,,"If multiple queues are bound to the same routing key,
then a failure to deliver to one of the queues (e.g. policy limit
error) could prevent delivery on some of the other queues.

The exchange should deliver to every queue that did not
have an error before raising an error.

"
Bug,QPID-3201,12504061,NullMessageStore not safe for concurrent DTX operations,gsim,gsim,Closed,Fixed,2017-03-14 20:07,C++,C++ Broker,,,,,,,...as the 'prepared' set is not protected from concurrent access by any locking. E.g. running qpid-txtest with --dtx true and several queues in a stress test against a broker with no store plugin will crash the broker.
Bug,QPID-1370,12406651,LVQ pointer containment / incomplete browse,,cctrieloff,Closed,Fixed,2017-03-14 20:02,C++,C++ Broker,,,,,,,"
It is not clear the way I reference the deque will be safe if stl updates. This jira is to make lvq insensitive to stl changes + update browse behavior."
Bug,QPID-5305,12677901,Valgrind reports uninitialised values sent to system call in legacystore,astitcher,astitcher,Closed,Fixed,2017-03-14 19:35,C++,C++ Broker,,,,,,,"Running the legacystore tests under valgrind highlight that it doesn't initialise all the values it sends to disk.

Even if these bytes are actually never used when the store is read, having this behaviour makes it hard to use valgrind to check that the store doesn't have other problems.

There is a compile time option to enable initialising of the full written buffer, I think it is wise to enable this option always, so that testing using valgrind is productive."
Bug,QPID-6924,12917381,Qpidd fails to compile against trunk 0.12-SNAPSHOT proton-c,astitcher,astitcher,Closed,Fixed,2017-03-14 19:32,C++,C++ Broker,,,,,,,"Compile failure:
{noformat}
/foo/qpid/qpid/cpp/src/qpid/broker/amqp/DataReader.cpp: In member function 'void qpid::broker::amqp::DataReader::readOne(pn_data_t*)':
/foo/qpid/qpid/cpp/src/qpid/broker/amqp/DataReader.cpp:76:12: error: enumeration value 'PN_INVALID' not handled in switch [-Werror=switch]
     switch (pn_data_type(data)) {
            ^
cc1plus: all warnings being treated as errors
make[2]: *** [src/CMakeFiles/amqp.dir/qpid/broker/amqp/DataReader.cpp.o] Error 1
{noformat}"
Bug,QPID-7494,13017863,Invocation of check_dependencies.py fails on CMake 2.8.11,jross,jross,Resolved,Fixed,2016-11-04 0:07,C++,C++ Broker,C++ Client,,,,,,"This annoying issue is discussed here: https://public.kitware.com/Bug/view.php?id=13887 .

It's a bug introduced in cmake 2.8.10 and resolved in 2.8.12.  RHEL 7's cmake version is 2.8.11."
Bug,QPID-7250,12964391,Durable message that exceeds page queue size prevents broker restart,gsim,gsim,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,,,,,,,"If you have a durable paged queue and send a durable message that is too large to fit in a single page, the broker rejects it which is expected based on current implementation. However it does so only after having written the message to disk. On attempting to recover that message then can't be brought into memory and the broker fails to recover."
Bug,QPID-7127,12947013,[C++ broker] Setting large idle timeout cause confuses timers in the C++ broker,pmoravec,scholzj,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,,,,,,,"I run into following problem. When I try to connect with SwiftMQ AMQP client (http://www.swiftmq.com/) to the Qpid C++ broker and don't specify idle timeout, it will use in64_max. The Qpid broker seems to be fine with it and opens the connection:

ConnectionDispatcher, , visit, po=[POOpen, containerId=356a476d-4678-4cfa-9680-8bf648b808d2@schojak, maxFrameSize=2147483647, maxChannel=255, idleTimeout=9223372036854775807]
ConnectionDispatcher, , visit, po=[POConnectionFrameReceived, frame=[Open containerId=91655fa5-80d3-4cd1-9a72-51b82e36de00, maxFrameSize=4294967295, channelMax=255, idleTimeOut=2147483647, offeredCapabilities=[ANONYMOUS-RELAY], properties=[product=qpid-cpp, platform=Linux, host=6a2d20e32f38, version=0.35]], sassl=false]

However, the timers in the broker get crazy from it and start raising milions of errors like this:
2016-03-04 15:55:40 [System] error ConnectionTicker couldn't setup next timer firing: 33.8867ms[0ns]
2016-03-04 15:55:40 [System] error ConnectionTicker couldn't setup next timer firing: 33.8937ms[0ns]
2016-03-04 15:55:40 [System] error ConnectionTicker couldn't setup next timer firing: 33.9006ms[0ns]
2016-03-04 15:55:40 [System] error ConnectionTicker couldn't setup next timer firing: 33.9076ms[0ns]

This seems to go on until the client disconnects or until the disk goes full. IT also seems to cause some secondary problems (perfomance, the affected client cannot close producer etc.)

The int64 idle timeout seems to be bug in the SwiftMQ client. But Qpid should definitely handle this better:
- Not open the connection when the indle timeout is invalid
- Make sure that the timer errors don't appear

The problem seems to be present in both 0.34 as well as in trunk."
Bug,QPID-7357,12990459,c++ HA Backup crash during re-connect in failover,aconway,aconway,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,C++ Clustering,,,,,,"A backup creates an UpdateTracker to delete non-existent queues at the end of an update, in the UpdateTracker destructor. However if an update is interrupted, it can leave a partially-used UpdateTracker behind. When the next update starts this can incorrectly delete queues at a sensitive moment and cause a crash.

See also https://bugzilla.redhat.com/show_bug.cgi?id=1333767"
Bug,QPID-6639,12844695,"Incoming connection using ""cut-through"" ANONYMOUS SASL fails",gsim,tross,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,,,,,,,"When connecting an AMQP 1.0 connection to the broker using SASL ANONYMOUS, the following exchange occurs:
{noformat}
  Client            Broker
        init(SASL) ->
        sasl.init (ANON) ->
        init(AMQP) ->
        open ->
     <- init(SASL)
     <- sasl.mechanisms
     <- sasl.outcome(OK)
     socket closed by broker after timeout
{noformat}
It appears the the broker doesn't process the open frame."
Bug,QPID-7373,12994201,memory leak in broker with idle worker threads,cliffjansen,cliffjansen,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,,,,,,,"If a C++ broker is lightly loaded with many short lived connections such that at least one worker thread remains unwoken from the epoll_wait, its DeletionManager::ThreadStatus::handles grows without bound and the associated handles retain a shared_ptr ref and never go away.

To reproduce check RSS from ps (or malloc_stats) when running a simple program that creates a connection and nothing else:


hex5:  cat foo.cpp
{code}
#include <qpid/messaging/Connection.h>
#include <iostream>
using namespace qpid::messaging;
int main(int argc, char** argv) {
    std::string broker = argc > 1 ? argv[1] : ""127.0.0.1:5672"";
    Connection connection(broker);
    try {
        connection.open();
        connection.close();
        return 0;
    } catch(const std::exception& error) {
        std::cerr << error.what() << std::endl;
        connection.close();
        return 1;   
    }
}
{code}
hex5:  while true; do LD_LIBRARY_PATH=../rt/b/amqp/b/q35x/rt/lib64 ./foo ; done
"
Bug,QPID-6966,12924892,C++ broker and client to support TLS1.1 and TLS1.2 by default,pmoravec,pmoravec,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"Description of problem:
Currently, neither C++ client or broker allows TLS1.1 or TLS1.2 protocol versions. Please enable it, esp. since Java client 6.1 will disable TLS1.0 and use 1.1 and 1.2 only.


Version-Release number of selected component (if applicable):
qpid-cpp-server-0.34-5.el6.x86_64
qpid-cpp-client-0.34-5.el6.x86_64


How reproducible:
100%


Steps to Reproduce:
1. Start qpid broker with SSL configured
2. openssl s_client -tls1_1 -connect localhost:5671
3. openssl s_client -tls1_2 -connect localhost:5671


Actual results:
Both 2 and 3 fails with:

{noformat}
139817551390536:error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number:s3_pkt.c:337:
{noformat}


Expected results:
Both should return something like:

{noformat}
CONNECTED(00000003)
depth=0 CN = localhost
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = localhost
verify return:1
140319888385864:error:14094412:SSL routines:SSL3_READ_BYTES:sslv3 alert bad certificate:s3_pkt.c:1256:SSL alert number 42
140319888385864:error:1409E0E5:SSL routines:SSL3_WRITE_BYTES:ssl handshake failure:s3_pkt.c:596:
---
Certificate chain
 0 s:/CN=localhost
   i:/CN=localhost
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIBoDCCAQmgAwIBAgIFAKUDcMswDQYJKoZIhvcNAQEFBQAwFDESMBAGA1UEAxMJ
bG9jYWxob3N0MB4XDTE1MTIzMDExMDYwN1oXDTE2MDMzMDExMDYwN1owFDESMBAG
A1UEAxMJbG9jYWxob3N0MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCgCq6w
o6FW7gIpAQu8y74wuREH6aGo6hc6YVfATz503o7dxqmUUKs6+DkqbEiDu43r51QL
Sb7oduLMmrvC5TfhWEZGe3PYPOuCBbpqDxXs5kKlqSCuIbvDv1ua1WXdqb27/jGr
d6Lf+DsnU+GXrGwLY1W1zchagmFU1P2dLh8JhQIDAQABMA0GCSqGSIb3DQEBBQUA
A4GBACUauXrJB/P0za8mPj5As4uQ3kr7CHIAtFBEAd3MvVmf9RHniMU/resXeE1B
CBOZ4kXmTvVQ+/kDxYTXO/pLq0wh4HHuZC4LrmlIHG2WagEskVnYgqJiHUchKi+8
URu/CX4rW6/EdcAHhPsKX6nlHFFKYg5u9b9ZtQHYMrfryStZ
-----END CERTIFICATE-----
subject=/CN=localhost
issuer=/CN=localhost
---
Acceptable client certificate CA names
/CN=dummy
---
SSL handshake has read 565 bytes and written 202 bytes
---
New, TLSv1/SSLv3, Cipher is AES128-GCM-SHA256
Server public key is 1024 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : AES128-GCM-SHA256
    Session-ID: 7D6C1CB53B37700F2BF007D0D079AB72F26A9D289BCA8D98B5B3F1E283311991
    Session-ID-ctx: 
    Master-Key: 448215BEAADBFF90B82B421D182F8AD7174426D9292835775C405A7C3AEC2763E5F2A1127E5AE210ADC6B7335EE1F6FA
    Key-Arg   : None
    Krb5 Principal: None
    PSK identity: None
    PSK identity hint: None
    Start Time: 1451483784
    Timeout   : 7200 (sec)
    Verify return code: 18 (self signed certificate)
---
{noformat}

Additional info:"
Bug,QPID-7147,12950864,When compiling with C++11/14 bind() use gets found as std::bind(),astitcher,astitcher,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"This is a poor naming issue that wasn't a problem before.

In qpid/messaging/amqp/AddressHelper.cpp there are a number of anonymous functions called bind() which take std::string as one of their argument types. Additionally the include chain indirectly includes <functional>.

Because of C\+\+ argument dependent lookup the compiler is finding/using std::bind in preference to the locally declared bind. This is only an issue when compiling with C\+\+11/14 because std::bind did not exist before.

This issue might have gone undetected except that the compiler noted that one of the overloads of the local bind() was unused.

A most pernicious problem and hard to detect."
Bug,QPID-7393,12996942,Unavailable buffers in Windows SSL,cliffjansen,cliffjansen,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"From the user list (acartcat Cartwright_Andrew@cat.com):

> I get the following error in the broker, looks like the same error as
> QPID-5033.
[...]
> 2016-05-26 05:22:23 [System] error No IO buffers available: getQueuedBuffer
> with empty queue. Debug data: 0 1 0 3 0 0 1
[...]
> This can be triggered on demand using:
> qpid-send -b ssl:XXXXXXXX.com:5671 --connection-options {protocol:amqp1.0}
> -a testerq --content-string=hello --messages 200

In my testing, qpid-send must also be Windows based.  I do not see the error
if it is sent from a client running on Linux.

This error is caused by the SChannel driver generating (valid but
useless) empty SSL packets when a zero length write is requested from
the codec on the client side.  On the server side, these are
processed and empty read callbacks are generated, even after close.

The WSAENOBUFS happens as a side effect of recursive calls to
sslDataIn while processing adjacent empty packets.

"
Bug,QPID-7145,12950854,auto_ptr is deprecated from C++11 and onwards and its use causes a warning with GCC 6,astitcher,astitcher,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"As we compile qpid with warnings turned to errors this causes the build to fail by default when compiling with GCC6.

The simplest ""fix"" is just to turn of deprecation warnings.

A better fix would be to stop using auto_ptr. An good alternative in the context of qpid would be boost::scoped_ptr.

If we change the base C++ version for qpid we could use std::unique_ptr instead."
Bug,QPID-7306,12979973,Fix memory bugs and race conditions found in a Qpid HA deployment,aconway,aconway,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"Bugs related to thread safety and lifecycle of Links/Bridges, management objects and Queues. These were discovered in a HA environment but most of the issues could theoretically affect a stand alone broker also. For more information see https://bugzilla.redhat.com/show_bug.cgi?id=1333767"
Bug,QPID-7383,12995978,[linearstore] Overwrite-before-return causes latencies for clients,kpvdr,kpvdr,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"Using the linearstore overwrite-before-return option can cause excessive client latencies owing to the time taken in the store to overwrite the entire journal file with zeros in an inefficient manner.  The store by design does not have its own worker threads, and relies on the thread that is processing a message to perform its work."
Bug,QPID-7326,12984043,Memory bloat on HA primary broker,aconway,aconway,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"Description of problem:
Having a consumer that (in a loop):
- creates an autoDelete queue
- subscribes to it
- unsubscribes
against a HA cluster, primary broker memory consumption grows over the time.


Version-Release number of selected component (if applicable):
0.34-6
0.34-15


How reproducible:
100%


Steps to Reproduce:
1. Start 3 brokers in a HA cluster (mine reproducer uses options:

qpidd --port=5672 --store-dir=_5672 --log-to-file=qpidd.5672.log --data-dir=_5672 --auth=no --log-to-stderr=no --ha-cluster=yes --ha-brokers-url=localhost:5672,localhost:5673,localhost:5674,localhost:5675,localhost:5676 --ha-replicate=all --acl-file=/root/qpidd.acl --link-maintenance-interval=5
)

2. Run simple qpid-receive in a loop:
while true; do
  qpid-receive -a ""autoDelQueue;  {create:always, node:{ x-declare:{auto-delete:True}}}""
  sleep 0.1
done

3. Monitor memory usage of primary broker.


Actual results:
- memory usage grows over the time (just of primary broker, backup ones are OK)


Expected results:
- no memory usage growth


Additional info:
- I *think* HA cluster is necessary condition (i.e. bug does not occur on standalone broker), but I will test it

See also https://bugzilla.redhat.com/show_bug.cgi?id=1350023 ."
Bug,QPID-6714,12859842,Add support for JMSHeaders in selectors,astitcher,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"The proton based Qpid JMS client does not use the names as described in the apache-filters.xml, but sends the JMSHeader names as is. This works with other brokers so changing the client is less than ideal for interop. By modifyig qpidd to recognise these headers, overall interop over 1.0 will be improved."
Bug,QPID-7302,12979297,race between auto-delete and re-declare/consume ,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"In AMQP 0-10, declare and consume are two distinct operations. When creating a receiver through qpid::messaging, we first declare then consume from the queue.

For a timed auto-delete queue, the delayed auto-delete can tae place between the declare and the consume, resulting in a session error. It would be nice to avoid this. The workaround of course is to set the delay for auto-delete to be sufficiently large that the client will either have reconnected or is likely not reconnecting.

However a simple solution would be to reset the timer on the declare, allowing time for the consume.

This does not prevent the race between a non-timed auto-delete triggered by one session and declare/consume from a different client connection."
Bug,QPID-7240,12963841,acquired messages are not evicted from priority-ring queue,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"If a priority queue with a ring queue limit policy exceeds the limit, the lowest priority oldest message should be removed. However at present acquired messages are not considered here."
Bug,QPID-6435,12780104,No error info logged for io errors with ssl,astitcher,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"It seem PR_Read  may retrun -1 without setting errno, so the AsyncIO handling will log the obscure  'Error reading socket: Success(0)' for any ssl related IO error. NSPR has its own routines for retrieving error info.

This is a result of the consolidation from https://issues.apache.org/jira/browse/QPID-4272."
Bug,QPID-6660,12849408,[AMQP 1.0] broker attempts to process incoming messages for closed session,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"If using the proton events API (i.e. any recent version of proton), then if the broker closes the session when there are already incoming delivery events on the event queue, those events will still get dispatched and the broker will try to handle them though proton will fail to retrieve any data for the deliveries."
Bug,QPID-6698,12856732,[amqp1.0] connections drop when heartbeat is used and the time of day changes,kgiusti,kgiusti,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"If heartbeats are enabled on a connection using AMQP 1.0, the connection will drop the connection if the system clock is adjusted.  Qpidd thinks the connection's idle timeout expired, when it actually hasn't"
Bug,QPID-7149,12951165,[HA] active HA broker memory leak when ring queue discards overflow messages,aconway,pmoravec,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"There is a memory leak on active HA broker, triggered most probably by purging overflow message from a ring queue. Basic scenario is to setup HA cluster, promote to primary and feed forever a ring queue with messages.

Detailed scenario:

1) Start brokers and promote one to primary:

{noformat}
start_broker() {
	port=$1
	shift
	rm -rf _${port}
	mkdir _${port}
	nohup qpidd --load-module=ha.so --port=$port --log-to-file=qpidd.$port.log --data-dir=_${port} --auth=no --log-to-stderr=no --ha-cluster=yes --ha-brokers-url=""$(hostname):5672,$(hostname):5673,$(hostname):5674"" --ha-replicate=all --acl-file=/root/qpidd.acl ""$@"" > /dev/null 2>&1 &
	sleep 1
}


killall qpidd qpid-receive 2> /dev/null
rm -f qpidd.*.log
start_broker 5672
sleep 1
qpid-ha promote -b $(hostname):5672 --cluster-manager
sleep 1
start_broker 5673
sleep 1
start_broker 5674
{noformat}

2) Create ring queues and send there messages (it is enough to have 1 queue, having more should show the leak faster):

{noformat}
for i in $(seq 0 9); do
	qpid-config add queue FromKeyServer_$i --max-queue-size=10000 --max-queue-count=10 --limit-policy=ring --argument=x-qpid-priorities=10
done

while true; do
	for j in $(seq 1 10); do
		for i in $(seq 1 10); do
			for k in $(seq 0 9); do
				qpid-send -a FromKeyServer_$k -m 100 --send-rate=50 -- priority=$(($((RANDOM))%10)) &
			done
		done
		wait
		while [ $(qpid-stat -q | grep broker-replicator | sed ""s/Y//g"" | awk '{ print $2 }' | sort -n | tail -n1) != ""0"" ]; do
			sleep 1
		done
	done
	date
	ps aux | grep qpidd | grep ""port=5672"" | awk -F ""--store-dir"" '{ print $1 }'
done
{noformat}

(the ""while [ $(qpid-stat -q | .."" cycle is there just to slow down the message enqueues to ensure replication federation queues dont have big backlog - that would interfere with memory consumpiton observation)


3) Run those scripts and monitor memory consumption.

- without using priority queues and sending messages without priorities, leak is evident as well - sometimes smaller, sometimes the same
- valgrind (on some older versions I tested before more thoroughly) detects nothing (neither leaked memory or reachable at shutdown)
- same leak is evident even with --ha-replicate=none
- number of backup brokers does not affect the memory leak
"
Bug,QPID-7010,12933034,assertion failure if disposition sent for previously settled delivery,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"If you sent multiple disposition frames fro the same delivery-id, each of them with settled=true, then qpidd fails with an assertion error:

src/qpid/broker/amqp/Outgoing.cpp:115: virtual void pid::broker::amqp::OutgoingFromQueue::handle(pn_delivery_t*): Assertion `r.delivery == delivery' failed.

where r.delivery is 0."
Bug,QPID-5398,12682978,qpidd --acl-file does not work with a drive-prefixed path on windows.,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"The acl-file option does not correctly recognize windows paths of the form x:\... as absolute paths and attempts to append them to the brokers data-dir

To reproduce (on windows): qpidd --acl-file c:\path\to\policy.acl

Result: log contains
error Unable to open ACL file ""<data-dir>/c:\path\to\policy.acl""

Expected result: should load file correctly."
Bug,QPID-5324,12678406,C++ broker ignores unrecognised filter in QMF methods,gsim,scholzj,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"Some QMF methods - for example purge or queueMoveMessages - support filers as one their parameters. The filter allows to specify the messages which should be affected by the methods - e.g. which messages should be purged. Unfortunately, if the broker doesn't recognize the filter, it simply ignores it and uses empty filter instead:

2013-11-09 18:15:45 [Broker] error Ignoring unrecognized message filter: '{subject:test}'

Such behaviour doesn't make sense - if the client who called the QMF method specified the filter, it is obvious that he didn't wanted to apply the method to all messages. Especially with methods like purge, this can lead to severe message loss!

Therefore if the broker doesn't recognize the filter, it should throw an error and never execute the method.
"
Bug,QPID-6150,12748018,qpid-qls-analyze tool cannot find Python modules,,mcpierce,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"The python modules qlslibs install to /usr/share/qpid-tools/python. The qpid-qls-analyze builds its module search path to include the above. However, the above directory is missing the necessary __init__.py file to make it a module that can be imported."
Bug,QPID-5666,12706970,HA fails with resource-limit-exceeded: Exceeded replicated queue limit,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"See also: https://bugzilla.redhat.com/show_bug.cgi?id=1076545

How to reproduce:
0] let's have 3 node cluster running: A, B, C 
1] Create queue 'q' on A
2] kill A
3] wait B to become primary
4] Delete queue 'q' on B
5] Try to create any queue on B.

Actual result:  Exception received from broker: resource-limit-exceeded: Exceeded replicated queue limit. 

Expected result: no error."
Bug,QPID-5941,12730575,Set sensible default build type,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"The cmake default build type is a sort of ""didn't bother with flags"" build - it has neither debugging symbols nor optimization and so is not well suited to anything.

- Make the default one of the standard build types: Release, Debug, RelWithDebInfo and MinRel.
- Mention all the available build types in the INSTALL file.
- Mention the default build type in the initial cmake output.

Based on the discussion here: http://qpid.2158936.n2.nabble.com/How-to-test-the-performance-quid-c-broker-td7610614i20.html#a7611007 the majority opinion is to use RelWithDebInfo. It was not unanimous, but this is only the default so people can change it towhatever they like and the doc. will make that clear."
Bug,QPID-4793,12645508,qpid/sys/regex.h doesn't detect correct implementation under FreeBSD 9.1,astitcher,astitcher,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"When building on FreeBSD 9.1 the libc regex implementation isn't detected because the build chain doesn't set _POSIX_SOURCE.

So to allow building on all POSIX/unix variants the test needs to change.

I propose to check if either _POSIX_SOURCE or __unix__ are set."
Bug,QPID-5599,12698730,C++ Broker silently ignores --max-connections option when no ACL file is loaded,chug,chug,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"ACL was converted from being a loadable module to being a built in but it still uses the loadable module interface. In that process if no ACL file is specified on the command line then no ACL object is created. The command line processing for --max-connections is in the ACL constructor and with no ACL object the CLI option is ignored.
"
Bug,QPID-4287,12606292,Poor performance when a priority queue with a ring queue policy has a large backlog,aconway,dillaman,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"The ring queue policy utilizes a single deque to store messages in priority and FIFO order.  When inserting messages of mixed priority into a queue with a large (>100,000) message backlog, the performance degrades quickly enough to potentially block all broker worker threads if they all are publishing to the same queue.  Recommend separating the ring queue data structure into separate deques based upon message priority in order to avoid the potential for reshuffling the deque with each incoming message."
Bug,QPID-6368,12773112,Coverity 1262251 - double free in ~PersistableQueue,shuston,shuston,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,Coverity reported this on 11-January-2015. Assumedly because of the multiple inheritance of LossyLvq and its ancestors. I trust Coverity's analysis more than mine so will submit a patch.
Bug,QPID-6409,12776994,Taking address of a 0-length vector throws exception,shuston,shuston,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"In Debug-mode builds, std::vector in VS2013 will throw an exception if trying to do:  &argv[0]  if argv has 0 length. This construct happens in cpp/src/tests/BrokerFixture.h, so happens in many of the unit tests."
Bug,QPID-6511,12823911,"[C++ Broker, clients] AMQP 0-10 windows clients can not connect to --no-auth broker",chug,chug,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Broker
{noformat}
./qpidd --auth no
{noformat}
Windows client
{noformat}
spout -b my-broker:5672 amq.topic
{noformat}
Fails with ""Not authenticated!""

The behavior change was in the broker as part of QPID-6325. Arguably the change is a good thing as it prevents clients connecting to the broker with no name. However, it makes for a poor out-of-the-box experience with a no-auth broker rejecting connections with an auth error. 

Clients can make a connection by adding:
{noformat}
--connection-options ""{username:dummy}""
or
--connection-options ""{sasl-mechanisms:ANONYMOUS}""
{noformat}
But the change breaks years of accumulated self tests that work just fine against older versions of qpidd.

The proposal to fix this is to make the Windows client provide the same connection defaults as linux cyrus sasl. "
Bug,QPID-6297,12765433,Python client (qpid.messaging) raises KeyError insead of reconnecting,eallen,jortel,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,Python Client,,,,,,"Description of problem:
Having some temporary network outage causing gofer loses TCP connection to AMQP broker, it does not try to reconnect.

How reproducible:
100%

Steps to Reproduce:

1. Just to speedup reproducer, lower kernel tunable net.ipv4.tcp_retries2 to e.g. 4:
echo 4 > /proc/sys/net/ipv4/tcp_retries2

2. Have consumer connected (with auto-reconnect enabled and heartbeats not enabled) and receiver open on a queue address and check its TCP connections to AMQP broker:
netstat -anp | grep 5671
(there should be 2 TCP connections)

3. Emulate network outage via iptables:
iptables -A OUTPUT -p tcp --dport 5671 -j REJECT

4. Monitor /var/log/messages; once it logs WARNING ""recoverable error"", flush iptables (iptables -F).

5. Wait few seconds.

6. Check gofer TCP connections:
netstat -anp | grep 5671


Actual results:
6. shows just 1 TCP connection
/var/log/messages repeatedly logs:
Dec  1 16:39:02 pmoravec-rhel6-3 goferd: [ERROR][pulp.agent.a726580c-5f1e-4a79-9f11-de0adc52c1e9] gofer.transport.qpid.consumer:117 - 046d2084-b0f1-4de4-a039-89499d9e680d
Dec  1 16:39:02 pmoravec-rhel6-3 goferd: [ERROR][pulp.agent.a726580c-5f1e-4a79-9f11-de0adc52c1e9] gofer.transport.qpid.consumer:117 - Traceback (most recent call last): File ""/usr/lib/python2.6/site-packages/gofer/transport/qpid/consumer.py"", line 113, in get return self.__receiver.fetch(timeout=timeout) File ""<string>"", line 6, in fetch File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 1030, in fetch self._ecwait(lambda: self.linked) File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 50, in _ecwait result = self._ewait(lambda: self.closed or predicate(), timeout) File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 993, in _ewait result = self.session._ewait(lambda: self.error or predicate(), timeout) File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 580, in _ewait result = self.connection._ewait(lambda: self.error or predicate(), timeout) File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 219, in _ewait self.check_error() File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 212, in check_error raise e InternalError: Traceback (most recent call last): File ""/usr/lib/python2.6/site-packages/qpid/messaging/driver.py"", line 660, in write op.dispatch(self) File ""/usr/lib/python2.6/site-packages/qpid/ops.py"", line 84, in dispatch getattr(target, handler)(self, *args) File ""/usr/lib/python2.6/site-packages/qpid/messaging/driver.py"", line 877, in do_session_detached sst = self._sessions.pop(dtc.channel) KeyError: 'pop(): dictionary is empty'

Expected results:
2nd TCP connection re-established, no errors in /var/log/messages
"
Bug,QPID-6392,12774990,[C++ Broker] [AMQP 1.0] the broker didnt respond to a link detach request,gsim,robbie,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,"In running some tests, I noticed a situation where the broker does not respond to a detach request for a durable subscriber link."
Bug,QPID-6532,12827790,make sasl service name configurable,gsim,gsim,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,"At present the service name used with cyrus sasl is build time configurable and defaults to qpidd. It should apparently really be the protocol used, i.e. amqp. To allow for things that assume this (e.g. proton) but also retain backward compatibility, the service name used should be configurable."
Bug,QPID-6529,12827038,[C++ Client] Fails to compile with Proton 0.10,chug,chug,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Proton version detection logic
{noformat}
if (Proton_VERSION GREATER 0.8)
{noformat}
gets it wrong when Proton is 0.10.
"
Bug,QPID-6548,12831140,SYSV init scripts do not work properly wiht SSL-only broker.,aconway,aconway,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,"Install in default /usr and /etc locations, configure for SSL only. Try to use the SYSV service scripts. Servivce start starts the broker but reports and error, service status and stop commands don't work at all.
{noformat}
    aconway@mrg33 usr (trunk)$ sudo service qpidd start
    Starting Qpid AMQP daemon: ^[[60G[^[[0;32m  OK  ^[[0;39m]
    2015-05-19 14:59:42 [Unspecified] notice Broker is not running: Cannot open lock file /home/qpidd/.qpidd/qpidd.5672.pid: No such file or directory
    aconway@mrg33 usr (trunk)$ sudo service qpidd status
    qpidd dead but pid file exists
{noformat}
"
Bug,QPID-6563,12834218,[amqp1.0] broker does not clean up closed sessions or links,kgiusti,kgiusti,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,"Due to a bug in older versions of Proton, the broker does not explicitly free sessions and links that have been closed.  Rather, these objects are simply ignored until the connection itself is freed (which then frees all associated links and sessions).

Newer versions of proton do not suffer from this bug.  The broker should clean up closed links and sessions when a version of proton that does not suffer from that bug is employed."
Bug,QPID-6549,12831230," `service qpidd status` returns 1 - hidden error is ""ConnectionError: connection-forced: Connection must be encrypted.(320)""",aconway,aconway,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,,,,,,,"See also https://bugzilla.redhat.com/show_bug.cgi?id=1193762



Description of problem:
`service qpidd status` returns 1 even when the service is running:

# ps ax | grep qpid | grep -v grep
29123 ?        Ssl    2:39 /usr/sbin/qpidd --config /etc/qpid/qpidd.conf --daemon --data-dir=/var/lib/qpidd --close-fd 9

Hidden error is ""ConnectionError: connection-forced: Connection must be encrypted.(320)"". To display it change following in /etc/init.d/qpidd in function qpid_ping:

-    $QPID_HA $QPID_HA_OPTIONS ping >/dev/null 2>&1
+    $QPID_HA $QPID_HA_OPTIONS ping


Version-Release number of selected component (if applicable):
Satellite-6.1.0-RHEL-6-20150210.0-Satellite-x86_64


How reproducible:
always


Steps to Reproduce:
1. Install Satellite without Capsule:
   # katello-installer --foreman-admin-email 'root@localhost' \
     --foreman-admin-username 'admin' --foreman-admin-password '<pass>'
2. # service qpidd status; echo $?


Actual results:
Exit code is 1, no error (or other output) is printed


Expected results:
Status check of the qpidd service should return 0 and should print ""is running..."""
Bug,QPID-6399,12776036,Windows run_test.ps1 script needs revamp to match run_test,shuston,shuston,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Some time back the run_test script was expanded to offer new capabilities and the cmake testing invocation changed to match. The run_test.ps1 script is still expecting ""old"" invocation and needs a makeover."
Bug,QPID-5171,12670349,Don't increment quota count against a queue that already exists,,eallen,Closed,Fixed,2016-09-06 16:23,C++,C++ Broker,,,,,,,Attempting to create a queue that already exists increments the quota count even though no new queue is created. 
Bug,QPID-5358,12679985,Linearstore: Checksums not implemented in record tail,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:23,C++,C++ Broker,,,,,,,The linearstore now implements a 32-bit checksum in the record tail to check data integrity of the xid and data sections of the record. These have not been implemented (the value 0x0 is hardwired currently) and need some developement effort.
Bug,QPID-5704,12708606,[AMQP 1.0] dangling reference to domain in InterconnectFactory,gsim,gsim,Closed,Fixed,2016-09-06 16:23,C++,C++ Broker,,,,,,,"If a domain is deleted while referred to be an InterconnectFactory, that reference will be invalid and if used will cause a segfault (e.g. if a pending link attempt fails)."
Bug,QPID-5357,12679984,Linearstore: Empty file recycling not functional,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"The linearstore recycles journal files into an empty file pool (EFP) when there are no remaining undequeued records present in the file. The mechanism to recycle these files is not functional, and needs some developement work."
Bug,QPID-5483,12689098,"[linearstore] Recovery of journal with partly written record fails with ""JERR_JREC_BADRECTAIL: Invalid data record tail"" error message",kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"When recovering a store journal which contains a partly written record (such that the header is present, but the tail record is not), the broker terminates with the message
{color:blue}{{critical Unexpected error: Queue tq1: recoverMessages() failed: jexception 0x0701 enq_rec::decode() threw JERR_JREC_BADRECTAIL: Invalid data record tail. (Magic: expected 0x9aacb3ae; found 0x0)}}{color}

Expected behavior: The broker should handle such recoveries by treating the partly written record as invalid and, if necessary, adding filler records so that the next write can take place on an softblock boundary.

To reproduce:
1. Start the broker:
{color:blue}{{./qpidd --load-module linearstore.so -m no --auth no --default-flow-stop-threshold 0 --default-flow-resume-threshold 0 --default-queue-limit 0 --store-dir /home/kpvdr/RedHat --log-enable info+ --truncate yes}}{color}

2. Run a client to create some records in a queue:
{color:blue}{{./qpid-send -a ""tq1;{create:always,node:{type:queue,durable:true} }"" --durable true --tx 0 --content-size 1000 --messages 100}}{color}

3. Use a hex editor (eg hexedit) to partly overwrite the last record from the middle of the data section (containing the 'X' characters through to the end of the last write (where all the '\0' characters start) so that the record header and part of the data is still present, but the tail end of the data and record tail (and any filler records) are overwritten.

4. Restart the broker to recover the store:
{color:blue}{{./qpidd --load-module linearstore.so -m no --auth no --default-flow-stop-threshold 0 --default-flow-resume-threshold 0 --default-queue-limit 0 --store-dir /home/kpvdr/RedHat --log-enable info+ --truncate no}}{color}

The broker first detects the bad alignment:
{color:blue}
{{2014-01-15 16:38:45 \[Store\] warning Linear Store: Journal ""tq1"": Bad record alignment found at fid=0x1 offs=0x139800 (likely journal overwrite boundary); 16 filler record(s) required.}}
{{2014-01-15 16:38:45 \[Store\] notice Linear Store: Journal ""tq1"": Recover phase write: Wrote filler record: fid=0x1 offs=0x139800}}
{{...}}
{color}
but terminates with the error message at the top of this description."
Bug,QPID-5479,12689030,"[linearstore] Using recovered store results in ""JERR_JNLF_FILEOFFSOVFL: Attempted to increase submitted offset past file size. (JournalFile::submittedDblkCount)"" error message",kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"While running a qpid-txtest soak test, a store was encountered which recovered correctly, but upon completion of the test, the following error message was discovered in the broker log:

{color:blue}{{jexception 0x0402 AtomicCounter::addLimit() threw JERR_JNLF_FILEOFFSOVFL: Attempted to increase submitted offset past file size. (JournalFile::submittedDblkCount)}}{color}

This message was found four times. The store in question is attached. To reproduce:

1. Expand the store into the store directory. Note that the store directory is the one that contains the *{{qls}}* directory, and is supplied to the broker using the *{{--store-dir}}* parameter.

2. Start the broker so as to recover the store in the store directory:
{color:blue}{{./qpidd --load-module linearstore.so -m no --auth no --default-flow-stop-threshold 0 --default-flow-resume-threshold 0 --default-queue-limit 0 --store-dir <path-to-store-dir> --log-enable info+ --truncate no}}{color}

3. Run the test client to complete the test:
{color:blue}{{./qpid-txtest --messages-per-tx 14 --tx-count 1000000 --total-messages 981 --size 390 --queues 11 --check yes --init no --transfer no}}{color}

The test passes ok. Examine the output from the broker to find the error messages above.

The cause must be analyzed and a fix found for what is probably a corner-case error in the recovery logic."
Bug,QPID-5793,12717491,[C++ broker] Memory leak _and_ deadlock due to qpid.auto_delete_timeout queues,gsim,pmoravec,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"Description of problem:
There is a memory leak in the broker when a client declares auto-delete queue with qpid.auto_delete_timeout and re-connects just at the time the broker is about to delete the queue.


Version-Release number of selected component (if applicable):
any


How reproducible:
100% within some time


Steps to Reproduce:
1) Run script:

queues=100
sleep=0
while true; do
	for i in $(seq 1 $queues); do
		qpid-receive -a ""autoDelQueue_${i}; {create:always, node:{ x-declare:{auto-delete:True, arguments:{'qpid.auto_delete_timeout':1}}, x-bindings:[{exchange:'amq.fanout', queue:autoDelQueue_${i}}] }}"" --print-content=no -m 10 &
	done
	wait
	sleep $sleep
	date
done

Modify parameters (esp. sleep) such that the loop is executed once every second.

2) Monitor qpid broker memory utilization over time.


Actual results:
Both VSZ and RSS of qpidd process grows.


Expected results:
No memory grow.


Additional info:
the memory consumption increase is followed after a while by deadlock (see below) that - depending on number of worker threads - can practically freeze the broker. Backtraces of relevant threads:

Thread 4 (Thread 0x7fc08e803700 (LWP 26576)):
#0  0x00000032c4c0e264 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x00000032c4c09523 in _L_lock_892 () from /lib64/libpthread.so.0
#2  0x00000032c4c09407 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00007fc08f2e4842 in qpid::sys::Mutex::lock() ()
#4  0x00007fc08f2e4900 in qpid::sys::ScopedLock<qpid::sys::Mutex>::ScopedLock(qpid::sys::Mutex&) ()
#5  0x00007fc08f38bec5 in qpid::broker::Queue::canAutoDelete() const ()
#6  0x00007fc08f39d0bd in bool boost::_mfi::cmf0<bool, qpid::broker::Queue>::call<boost::shared_ptr<qpid::broker::Queue> const>(boost::shared_ptr<qpid::broker::Queue> const&, void const*) const ()
#7  0x00007fc08f39c2ef in bool boost::_mfi::cmf0<bool, qpid::broker::Queue>::operator()<boost::shared_ptr<qpid::broker::Queue> >(boost::shared_ptr<qpid::broker::Queue> const&) const ()
#8  0x00007fc08f39b117 in bool boost::_bi::list1<boost::_bi::value<boost::shared_ptr<qpid::broker::Queue> > >::operator()<bool, boost::_mfi::cmf0<bool, qpid::broker::Queue>, boost::_bi::list0>(boost::_bi::type<bool>, boost::_mfi::cmf0<bool, qpid::broker::Queue>&, boost::_bi::list0&, long) ()
#9  0x00007fc08f39974b in boost::_bi::bind_t<boost::_bi::unspecified, boost::_mfi::cmf0<bool, qpid::broker::Queue>, boost::_bi::list1<boost::_bi::value<boost::shared_ptr<qpid::broker::Queue> > > >::operator()() ()
#10 0x00007fc08f397593 in bool qpid::broker::QueueRegistry::destroyIf<boost::_bi::bind_t<boost::_bi::unspecified, boost::_mfi::cmf0<bool, qpid::broker::Queue>, boost::_bi::list1<boost::_bi::value<boost::shared_ptr<qpid::broker::Queue> > > > >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, boost::_bi::bind_t<boost::_bi::unspecified, boost::_mfi::cmf0<bool, qpid::broker::Queue>, boost::_bi::list1<boost::_bi::value<boost::shared_ptr<qpid::broker::Queue> > > >) ()
#11 0x00007fc08f38ed3e in qpid::broker::Queue::tryAutoDelete() ()
#12 0x00007fc08f395a78 in qpid::broker::AutoDeleteTask::fire() ()
#13 0x00007fc08ecb9847 in qpid::sys::TimerTask::fireTask() ()
#14 0x00007fc08ecbaaa1 in qpid::sys::Timer::fire(boost::intrusive_ptr<qpid::sys::TimerTask>) ()
#15 0x00007fc08ecba3d5 in qpid::sys::Timer::run() ()
#16 0x00007fc08ec3b597 in qpid::sys::(anonymous namespace)::runRunnable(void*) ()
#17 0x00000032c4c079d1 in start_thread () from /lib64/libpthread.so.0
#18 0x00000032c44e8b6d in clone () from /lib64/libc.so.6

Thread 3 (Thread 0x7fc08cdcd700 (LWP 26577)):
#0  0x00000032c4c0e264 in __lll_lock_wait () from /lib64/libpthread.so.0
#1  0x00000032c4c09523 in _L_lock_892 () from /lib64/libpthread.so.0
#2  0x00000032c4c09407 in pthread_mutex_lock () from /lib64/libpthread.so.0
#3  0x00007fc08f2e4842 in qpid::sys::Mutex::lock() ()
#4  0x00007fc08f2e4900 in qpid::sys::ScopedLock<qpid::sys::Mutex>::ScopedLock(qpid::sys::Mutex&) ()
#5  0x00007fc08f38f3a3 in qpid::broker::Queue::hasExclusiveOwner() const ()
#6  0x00007fc08f346459 in qpid::broker::Broker::bind(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, qpid::framing::FieldTable const&, qpid::broker::OwnershipToken const*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()
#7  0x00007fc08f462d55 in qpid::broker::SessionAdapter::ExchangeHandlerImpl::bind(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, qpid::framing::FieldTable const&) ()
#8  0x00007fc08ebd15d5 in void qpid::framing::ExchangeBindBody::invoke<qpid::framing::AMQP_ServerOperations::ExchangeHandler>(qpid::framing::AMQP_ServerOperations::ExchangeHandler&) const ()
#9  0x00007fc08ebcf1f5 in qpid::framing::AMQP_ServerOperations::ExchangeHandler::Invoker::visit(qpid::framing::ExchangeBindBody const&) ()
#10 0x00007fc08ebdcb7c in qpid::framing::ExchangeBindBody::accept(qpid::framing::MethodBodyConstVisitor&) const ()
#11 0x00007fc08ebcd5a2 in qpid::framing::AMQP_ServerOperations::Invoker::visit(qpid::framing::ExchangeBindBody const&) ()
#12 0x00007fc08ebdcb7c in qpid::framing::ExchangeBindBody::accept(qpid::framing::MethodBodyConstVisitor&) const ()
#13 0x00007fc08f475545 in qpid::framing::Invoker::Result qpid::framing::invoke<qpid::broker::SessionAdapter>(qpid::broker::SessionAdapter&, qpid::framing::AMQMethodBody const&) ()
#14 0x00007fc08f47152f in qpid::broker::SessionState::handleCommand(qpid::framing::AMQMethodBody*) ()
#15 0x00007fc08f4722ba in qpid::broker::SessionState::handleIn(qpid::framing::AMQFrame&) ()
#16 0x00007fc08f47a0a5 in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) () #17 0x00007fc08ec7b6c7 in qpid::amqp_0_10::SessionHandler::handleIn(qpid::framing::AMQFrame&) ()
#18 0x00007fc08f47a0a5 in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) () #19 0x00007fc08f3ce456 in qpid::framing::Handler<qpid::framing::AMQFrame&>::operator()(qpid::framing::AMQFrame&) ()
#20 0x00007fc08f3ca064 in qpid::broker::ConnectionHandler::handle(qpid::framing::AMQFrame&) ()
#21 0x00007fc08f3c0a2e in qpid::broker::amqp_0_10::Connection::received(qpid::framing::AMQFrame&) ()
#22 0x00007fc08f329780 in qpid::amqp_0_10::Connection::decode(char const*, unsigned long) ()
#23 0x00007fc08f43b015 in qpid::broker::SecureConnection::decode(char const*, unsigned long) ()
#24 0x00007fc08ecb031b in qpid::sys::AsynchIOHandler::readbuff(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) ()
#25 0x00007fc08f4d8534 in boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator()(qpid::sys::AsynchIOHandler*, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) const ()
#26 0x00007fc08f4d7272 in void boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> >::operator()<boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&> >(boost::_bi::type<void>, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>&, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&>&, int) ()
#27 0x00007fc08f4d6704 in void boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >::operator---Type <return> to continue, or q <return> to quit---
()<qpid::sys::AsynchIO, qpid::sys::AsynchIOBufferBase*>(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&) ()
#28 0x00007fc08f4d59dd in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke(boost::detail::function::function_buffer&, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) ()
#29 0x00007fc08ec233dc in boost::function2<void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator()(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) const ()
#30 0x00007fc08ec204cc in qpid::sys::posix::AsynchIO::readable(qpid::sys::DispatchHandle&) ()
#31 0x00007fc08ec283da in boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>::operator()(qpid::sys::posix::AsynchIO*, qpid::sys::DispatchHandle&) const ()
#32 0x00007fc08ec2772b in void boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> >(boost::_bi::type<void>, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>&, boost::_bi::list1<qpid::sys::DispatchHandle&>&, int) ()
#33 0x00007fc08ec26a1c in void boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >::operator()<qpid::sys::DispatchHandle>(qpid::sys::DispatchHandle&) ()
#34 0x00007fc08ec259f9 in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke(boost::detail::function::function_buffer&, qpid::sys::DispatchHandle&) ()
#35 0x00007fc08ecb4332 in boost::function1<void, qpid::sys::DispatchHandle&>::operator()(qpid::sys::DispatchHandle&) const ()
#36 0x00007fc08ecb38f8 in qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) ()
#37 0x00007fc08ec48692 in qpid::sys::Poller::Event::process() ()
#38 0x00007fc08ec47990 in qpid::sys::Poller::run() ()
#39 0x00007fc08ecb24d9 in qpid::sys::Dispatcher::run() ()
#40 0x00007fc08ec3b597 in qpid::sys::(anonymous namespace)::runRunnable(void*) ()
#41 0x00000032c4c079d1 in start_thread () from /lib64/libpthread.so.0
#42 0x00000032c44e8b6d in clone () from /lib64/libc.so.6

(I saw variants of Thread 3 waiting on the lock acquire, e.g. within:
#3  0x00007fc08ecb9c00 in qpid::sys::TimerTask::cancel() ()
#4  0x00007fc08f389cb8 in qpid::broker::Queue::consume(..)

)
"
Bug,QPID-5484,12689102,[linearstore] Poor performance relative to legacystore,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"The linearstore performance is poor compared to the legacystore. As linearstore has similar architecture to legacy store (except for file management), the performance ought to be comparable."
Bug,QPID-5123,12667714,Changes to Fedora 19 packaging of libdb4 prevents legacystore from building,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"Fedora 19 has slightly changed the layout and naming of libdb4 files. Consequently, legacystore when built with cmake cannot find the required libs or headers, and is thus excluded from the build."
Bug,QPID-5603,12698869,[Linearstore] Broker recovery fails with JERR_JREC_BADRECTAIL when record tail is partly or fully separated from rest of record by file boundary,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"When a record that contains a record tail (enqueue, transactional dequeue or transaction records) has the tail separated exactly or partly by a file boundary, then the broker fails recovery with JERR_JREC_BADRECTAIL. In reality, the file handle reaches EOF, but this error is not detected and the random values of the uninitialized record tail are taken as the read values."
Bug,QPID-5442,12685851,Linearstore: Dtx recover test fails,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:22,C++,C++ Broker,,,,,,,"Broker test {color:blue}*qpid_tests.broker_0_10.dtx.DtxTests.test_recover*{color} fails. This test prepares several transactions, then calls dtx_recover, which causes the store to collect prepared xids in a list for recovery. Note that this test does not require a broker restart."
Bug,QPID-5460,12688101,[linearstore] Recovery of store which contains prepared but incomplete transactions results in message loss,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"During recovery of the linear store, transactions that were being prepared at the time the broker stopped/crashed are not correctly recovered, and this results in these messages being lost.

Steps to Reproduce:
1. Start broker loading linearstore:
{color:blue}{{./qpidd --load-module linearstore.so --truncate yes}}{color}
2. Run qpid-txtest against broker:
{color:blue}{{./qpid-txtest --messages-per-tx 4 --tx-count 1000000 --total-messages 100 --size 10 --queues 5}}{color}
3.After several seconds of running, kill the broker:
{color:blue}{{ps -eaf | grep qpidd}}
{{kill -9 <pid from previous cmd>}}{color}
4. Restart broker and recover messages (don't use --truncate)
{color:blue}{{./qpidd --load-module linearstore.so}}{color}
5. Check for lost messages using qpid-txtest:
{color:blue}{{./qpid-txtest --messages-per-tx 4 --tx-count 1000000 --total-messages 100 --size 10 --queues 5 --check yes --init no --transfer no}}{color}

Actual results:
{{qpid-txtest}} reports some messages are missing.

Expected results:
{{qpid-txtest}} retrieves all messages.

"
Bug,QPID-5607,12699240,[linearstore] Recovery of store results in jexception 0x010b LinearFileController::getCurrentSerial() threw JERR_NULL,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"When the last record in a linearstore journal exactly coincides with the end of the last jounral file, the recovery fails with
{{jexception 0x010b LinearFileController::getCurrentSerial() threw JERR_NULL}}
"
Bug,QPID-5480,12689046,"[linearstore] Recovery of store failure with ""JERR_MAP_NOTFOUND: Key not found in map."" error message",kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"While running a qpid-txtest soak test, a store was encountered which could not be recovered. The broker stopped with the following error message:

{color:blue}{{\[Broker\] critical Unexpected error: Error commitjexception 0x0b01 wmgr::dequeue() threw JERR_MAP_NOTFOUND: Key not found in map. (rid=0x3e4f0) (/home/kpvdr/RedHat/qpid/cpp/src/qpid/linearstore/TxnCtxt.cpp:55)}}{color}

The store in question is attached. An additional similar error message is seen during store shutdown.

To reproduce:

1. Expand the store into a store directory. Note that the store directory is the one that contains the *{{qls}}* directory in the attached archive, and is supplied to the broker using the *{{--store-dir}}* parameter.

2. Start the broker so as to recover the store in the store directory:
{color:blue}{{./qpidd --load-module linearstore.so -m no --auth no --default-flow-stop-threshold 0 --default-flow-resume-threshold 0 --default-queue-limit 0 --store-dir <path-to-store-dir> --log-enable info+ --truncate no}}{color}

The store does not recover, and the broker exits with the above error message."
Bug,QPID-5176,12670569,C++ Broker - build fail on Visual Studio 2008,chug,chug,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"Visual Studio 2008 stopped compiling qpidmessaging on or near 2013-09-20. It works fine on Visual Studio 2010.

Examination of compiled file AcceptTracker.obj reveals that there are no class methods in it. The file is a ghost. Further examination shows that VS2008 is compiling AcceptTracker.h and not .cpp like one might expect. The .vcproj file has no apparent errors and the studio shows all the files where they belong; it just fails to compile the right one. Go figure.

The situation is much better if the messaging library .h file names are not included in the cmake qpidmessaging_SOURCES file list. This is the proposed fix."
Bug,QPID-5425,12685017,Linearstore: Transaction Prepared List (TPL) fails with jexception 0x0402 AtomicCounter::addLimit() threw JERR_JNLF_FILEOFFSOVFL,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"When records are sent to the store transactionally, the transaction prepared list (TPL) fails with:

{color:blue}{{Unexpected error: jexception 0x0402 AtomicCounter::addLimit() threw JERR_JNLF_FILEOFFSOVFL: Attmepted to increase submitted offset past file size. (JournalFile::submittedDblkCount)}}{color}

The error can easliy be reproduced by running the following against the broker with the linearstore loaded:

{color:blue}{{qpid-send -a ""tq;{create:always,node:{type:queue,durable:true} }"" --durable true --tx 1 --content-size 10 --messages 10000}}{color}"
Bug,QPID-5473,12688471,[linearstore] Recovery of journal in which last logical file contains truncated record causes crash,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"When the store recovery process encounters a journal where the last logical file is full and the last record in that file is also incomplete (ie this record would ordinarily span this journal file and the next if it were present), then the recovery process crashes with a segfault.

There is no specific reproducer, but using large message sizes in a test will increase the probability that this error will occur, and killing the broker suddenly (ie with signal SIGKILL) increases the probability that this error will occur.

This error could also be synthesized by deleting the last file(s) in a valid journal provided that the last record in the remaining journal files is still undequeued and spans to a deleted file."
Bug,QPID-5901,12727727,Qpid XML Exchange cannot be used on EL6,mcpierce,bmbouter,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"The XML exchange functionality of Qpid is provided by the package qpid-cpp-server-xml which is produced from SRPM qpid-cpp. Pulp includes and delivers all qpid-cpp SRPM bits for EL6 from koji so a recent version of Qpid is available on EL6. The qpid-cpp-server-xml package is missing a dependency called 'xqilla' that is not available in base EL6 or EPEL. When a user goes to install the RPM, they get the following error message.

error: Failed dependencies:
        libxqilla.so.5()(64bit) is needed by qpid-cpp-server-xml-0.26-8.el6.x86_64
        xqilla is needed by qpid-cpp-server-xml-0.26-8.el6.x86_64

One workaround is the user could build the xqilla library from source."
Bug,QPID-5444,12686169,"Linearstore: Recovering from qpid-txtest fails with ""Inconsistent TPL 2PC count"" error message",kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"A test in which qpid-txtest is interrupted by killing the broker and subsequently recovering to check for transactional message loss/inconsisntency failed during recovery with the message ""Inconsistent TPL 2PC count"". The broker exits and is unable to start."
Bug,QPID-6355,12772059,[linearstore] Installation error,kpvdr,kpvdr,Closed,Fixed,2016-09-06 14:47,C++,C++ Broker,,,,,,,"During installation of the linearstore, the following error message is observed:

{{error: can't copy 'src/py/qlslibs/anal.py': doesn't exist or not a regular file}}"
Bug,QPID-2029,12432281,Clustering and Management don't work well together,tross,tross,Closed,Fixed,2016-09-06 12:45,C++,C++ Broker,,,,,,,"Several aspects of management of the C++ broker are not well integrated with clustering.

1)  object-ids assigned to management objects are not synchronized across nodes of a cluster.
2)  persistent object-ids are not synchronized across nodes of a cluster.
3)  cached data within the QMF broker are not synchronized.
4) next-object-id and reboot-sequence are not synchronized.
"
Bug,QPID-7020,12933671,uint16 AMQP0-10 message properties decoded as uint8,pmoravec,pmoravec,Closed,Fixed,2016-08-30 12:52,C++,C++ Broker,,,,,,,"Description of problem:
MessageTransfer::processProperties has trivial typo in decoding uin16 message property type as uint8 variant:

void MessageTransfer::processProperties(qpid::amqp::MapHandler& handler) const
{
..
            switch (v.getType()) {
            case qpid::types::VAR_VOID:
                handler.handleVoid(key); break;
            case qpid::types::VAR_BOOL:
                handler.handleBool(key, v); break;
            case qpid::types::VAR_UINT8:
                handler.handleUint8(key, v); break;
            case qpid::types::VAR_UINT16:
                handler.handleUint8(key, v); break;
..

See the latest line.

Any attempt to call that line raises error:

invalid conversion: Cannot convert from uint16 to uint8 (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/types/Variant.cpp:280)

One reproducer provided below.


Version-Release number of selected component (if applicable):
qpid-cpp-server-0.34-5.el6.x86_64


How reproducible:
100%

Steps to Reproduce:
1. Have this trivial program that creates queue message_queue, subscribes to the queue, bind to amq.match with x-match:any,number:10809 matcher rule:

$ cat send_uint16_t.cpp 

#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Session.h>

#include <cstdlib>
#include <iostream>

#include <sstream>

using namespace qpid::messaging;
using namespace qpid::types;

using std::stringstream;
using std::string;

int main(int argc, char** argv) {
    const char* url = argc>1 ? argv[1] : ""amqp:tcp:127.0.0.1:5672"";
    
    Connection connection(url, """");
    try {
        connection.open();
        Session session = connection.createSession();
        Receiver receiver = session.createReceiver(""message_queue; {create: always, node:{type:queue, durable:false, x-bindings:[{exchange:'amq.match', queue:'message_queue', key:'key', arguments:{x-match:any,number:10809}}]}}"");
        Sender sender = session.createSender(""amq.match/key"");
        Message msg(""Some content"");
        uint16_t number=10809;
        msg.setProperty(""number"", number);
        sender.send(msg);
        Message msg2 = receiver.fetch();
        std::cout << ""Properties: "" << msg2.getProperties() << std::endl
                  << ""Content: "" << msg.getContent() << std::endl;
        session.close();
        connection.close();
        return 0;
    } catch(const std::exception& error) {
        std::cout << error.what() << std::endl;
        connection.close();
    }
    return 1;   
}

2. Compile it and run against a broker:
g++ -Wall -lqpidclient -lqpidcommon -lqpidmessaging -lqpidtypes send_uint16_t.cpp -o send_uint16_t
./send_uint16_t

3. Check output and also qpid logs


Actual results:
output:
2016-01-24 13:46:30 [Client] warning Broker closed connection: 501, invalid conversion: Cannot convert from uint16 to uint8 (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/types/Variant.cpp:280)
framing-error: invalid conversion: Cannot convert from uint16 to uint8 (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/types/Variant.cpp:280)

qpid error:
2016-01-24 13:46:30 [Broker] error Connection exception: framing-error: invalid conversion: Cannot convert from uint16 to uint8 (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/types/Variant.cpp:280)
2016-01-24 13:46:30 [Protocol] error Connection qpid.127.0.0.1:5672-127.0.0.1:33825 closed by error: invalid conversion: Cannot convert from uint16 to uint8 (/builddir/build/BUILD/qpid-cpp-0.34/src/qpid/types/Variant.cpp:280)(501)


Expected results:
output:
a message is received and printed to stdout

qpid logs:
no error
"
Bug,QPID-6397,12775871,[C++ broker] segfault when processing QMF method during periodic processing,pmoravec,pmoravec,Closed,Fixed,2015-06-16 8:42,C++,C++ Broker,,,,,,,"There is a race condition causing segfault when:
- one thread executes periodic processing with traces enabled (at least for qpid::management::ManagementAgent::debugSnapshot)
- second thread is just processing QMF method from a client

The root cause is, the first thread iterates through managementObjects map in dumpMap (or through newManagementObjects in dumpVector) while the second thread is executing moveNewObjects that moves stuff from newManagementObjects to managementObjects.

See backtraces hit (dumpMap shown, hit also dumpVector):
(gdb) bt # of thread 1
#0  0x0000003f0c632885 in raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x0000003f0c634065 in abort () at abort.c:92
#2  0x0000003f0c62b9fe in __assert_fail_base (fmt=<value optimized out>, assertion=0x7ff117bd5c94 ""px != 0"", 
    file=0x7ff117bd5c68 ""/usr/include/boost/smart_ptr/shared_ptr.hpp"", line=<value optimized out>, function=<value optimized out>)
    at assert.c:96
#3  0x0000003f0c62bac0 in __assert_fail (assertion=0x7ff117bd5c94 ""px != 0"", 
    file=0x7ff117bd5c68 ""/usr/include/boost/smart_ptr/shared_ptr.hpp"", line=418, 
    function=0x7ff117bd5e80 ""T* boost::shared_ptr< <template-parameter-1-1> >::operator->() const [with T = qpid::management::ManagementObject]"") at assert.c:105
#4  0x00007ff117947139 in boost::shared_ptr<qpid::management::ManagementObject>::operator->() const ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#5  0x00007ff117bafcd9 in qpid::management::(anonymous namespace)::dumpMap(std::map<qpid::management::ObjectId, boost::shared_ptr<qpid::management::ManagementObject>, std::less<qpid::management::ObjectId>, std::allocator<std::pair<qpid::management::ObjectId const, boost::shared_ptr<qpid::management::ManagementObject> > > > const&) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#6  0x00007ff117bb06ba in qpid::management::ManagementAgent::debugSnapshot(char const*) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#7  0x00007ff117b954ed in qpid::management::ManagementAgent::periodicProcessing() ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#8  0x00007ff117bc5c1f in boost::_mfi::mf0<void, qpid::management::ManagementAgent>::operator()(qpid::management::ManagementAgent*) const () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#9  0x00007ff117bc4384 in void boost::_bi::list1<boost::_bi::value<qpid::management::ManagementAgent*> >::operator()<boost::_mfi::mf0<void, qpid::management::ManagementAgent>, boost::_bi::list0>(boost::_bi::type<void>, boost::_mfi::mf0<void, qpid::management::ManagementAgent>&, boost::_bi::list0&, int) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#10 0x00007ff117bc1269 in boost::_bi::bind_t<void, boost::_mfi::mf0<void, qpid::management::ManagementAgent>, boost::_bi::list1<boost::_bi::value<qpid::management::ManagementAgent*> > >::operator()() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#11 0x00007ff117bbc1e0 in boost::detail::function::void_function_obj_invoker0<boost::_bi::bind_t<void, boost::_mfi::mf0<void, qpid::management::ManagementAgent>, boost::_bi::list1<boost::_bi::value<qpid::management::ManagementAgent*> > >, void>::invoke(boost::detail::function::function_buffer&) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#12 0x00007ff117a5e2af in boost::function0<void>::operator()() const () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#13 0x00007ff117b8e400 in qpid::management::(anonymous namespace)::Periodic::fire() ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#14 0x00007ff1173b518f in qpid::sys::TimerTask::fireTask() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
---Type <return> to continue, or q <return> to quit---
#15 0x00007ff1173b63e9 in qpid::sys::Timer::fire(boost::intrusive_ptr<qpid::sys::TimerTask>) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#16 0x00007ff1173b5d1d in qpid::sys::Timer::run() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#17 0x00007ff1173280ef in qpid::sys::(anonymous namespace)::runRunnable(void*) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#18 0x0000003f0ce077f1 in start_thread (arg=0x7ff116c8f700) at pthread_create.c:301
#19 0x0000003f0c6e570d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:115

(gdb) bt  # of thread 2
#0  0x00007ff116ca99c7 in qpid::types::VariantImpl::~VariantImpl() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidtypes.so.1
#1  0x00007ff116caf2e9 in qpid::types::Variant::~Variant() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidtypes.so.1
#2  0x00007ff117967876 in qmf::org::apache::qpid::broker::Connection::mapEncodeValues(std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, qpid::types::Variant, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, qpid::types::Variant> > >&, bool, bool) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#3  0x00007ff117bb118d in qpid::management::ManagementAgent::DeletedObject::DeletedObject(boost::shared_ptr<qpid::management::ManagementObject>, bool, bool) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#4  0x00007ff117b94ec1 in qpid::management::ManagementAgent::moveNewObjects() ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#5  0x00007ff117b9e79a in qpid::management::ManagementAgent::handleMethodRequest(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, bool) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#6  0x00007ff117bacb70 in qpid::management::ManagementAgent::dispatchAgentCommand(qpid::broker::Message&, bool) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#7  0x00007ff117b9ccc3 in qpid::management::ManagementAgent::dispatchCommand(qpid::broker::Deliverable&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, qpid::framing::FieldTable const*, bool, int) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#8  0x00007ff117bca08a in qpid::broker::ManagementDirectExchange::route(qpid::broker::Deliverable&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#9  0x00007ff117b49d65 in qpid::broker::SemanticState::route(qpid::broker::Message&, qpid::broker::Deliverable&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#10 0x00007ff117b6a8f3 in qpid::broker::SessionState::handleContent(qpid::framing::AMQFrame&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#11 0x00007ff117b6af31 in qpid::broker::SessionState::handleIn(qpid::framing::AMQFrame&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#12 0x00007ff117b72dc1 in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#13 0x00007ff117376ba3 in qpid::amqp_0_10::SessionHandler::handleIn(qpid::framing::AMQFrame&) ()
---Type <return> to continue, or q <return> to quit---
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#14 0x00007ff117b72dc1 in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#15 0x00007ff117ac640a in qpid::framing::Handler<qpid::framing::AMQFrame&>::operator()(qpid::framing::AMQFrame&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#16 0x00007ff117ac1a8c in qpid::broker::ConnectionHandler::handle(qpid::framing::AMQFrame&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#17 0x00007ff117ab8444 in qpid::broker::amqp_0_10::Connection::received(qpid::framing::AMQFrame&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#18 0x00007ff117a23408 in qpid::amqp_0_10::Connection::decode(char const*, unsigned long) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#19 0x00007ff117b34581 in qpid::broker::SecureConnection::decode(char const*, unsigned long) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#20 0x00007ff1173abc2f in qpid::sys::AsynchIOHandler::readbuff(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#21 0x00007ff117bd2ce6 in boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator()(qpid::sys::AsynchIOHandler*, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) const ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#22 0x00007ff117bd1a24 in void boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> >::operator()<boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&> >(boost::_bi::type<void>, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>&, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&>&, int) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#23 0x00007ff117bd0eb6 in void boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >::operator()<qpid::sys::AsynchIO, qpid::sys::AsynchIOBufferBase*>(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#24 0x00007ff117bd018f in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke(boost::detail::function::function_buffer&, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
---Type <return> to continue, or q <return> to quit---
#25 0x00007ff11730f204 in boost::function2<void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator()(qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*) const () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#26 0x00007ff11730c28b in qpid::sys::posix::AsynchIO::readable(qpid::sys::DispatchHandle&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#27 0x00007ff117314202 in boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>::operator()(qpid::sys::posix::AsynchIO*, qpid::sys::DispatchHandle&) const () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#28 0x00007ff117313553 in void boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> >(boost::_bi::type<void>, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>&, boost::_bi::list1<qpid::sys::DispatchHandle&>&, int) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#29 0x00007ff117312844 in void boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >::operator()<qpid::sys::DispatchHandle>(qpid::sys::DispatchHandle&) () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#30 0x00007ff117311821 in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke(boost::detail::function::function_buffer&, qpid::sys::DispatchHandle&) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#31 0x00007ff1173afc7a in boost::function1<void, qpid::sys::DispatchHandle&>::operator()(qpid::sys::DispatchHandle&) const ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#32 0x00007ff1173af240 in qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) ()
   from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#33 0x00007ff1173355d6 in qpid::sys::Poller::Event::process() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#34 0x00007ff1173348d4 in qpid::sys::Poller::run() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#35 0x00007ff1173ade21 in qpid::sys::Dispatcher::run() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidcommon.so.2
#36 0x00007ff117a30177 in qpid::broker::Broker::run() () from /root/qpid-trunk/qpid/cpp/BLD/src/libqpidbroker.so.2
#37 0x000000000040760c in qpid::broker::QpiddBroker::execute(qpid::broker::QpiddOptions*) ()
#38 0x000000000040b461 in qpid::broker::run_broker(int, char**, bool) ()
#39 0x00000000004076a6 in main ()


Reproducer: little bit tricky but basically:
1) create as much objects (and continue in creating them to have something in newManagementObjects map)
2) invoke some QMF method just when periodic processing is starting

In particular, I used this repro:
1) populate_provisioning.sh:

for i in $(seq 1 50); do qpid-config add exchange fanout ex_${i} & done
wait

while true; do
	j=$(uuidgen)
	echo ""$(date): starting with queue ${j}_q_1""
	for i in $(seq 1 200); do qpid-receive -a ""${j}_q_${i}; {create:always, node:{durable:true, x-bindings:[{exchange:'amq.direct', queue:'${j}_q_${i}', key:''}, {exchange:'amq.fanout', queue:'${j}_q_${i}'}, {exchange:'ex_1', queue:'${j}_q_${i}'}, {exchange:'ex_2', queue:'${j}_q_${i}'}, {exchange:'ex_3', queue:'${j}_q_${i}'}, {exchange:'ex_4', queue:'${j}_q_${i}'}, {exchange:'ex_5', queue:'${j}_q_${i}'}, {exchange:'ex_6', queue:'${j}_q_${i}'}, {exchange:'ex_7', queue:'${j}_q_${i}'}, {exchange:'ex_8', queue:'${j}_q_${i}'}, {exchange:'ex_9', queue:'${j}_q_${i}'}, {exchange:'ex_10', queue:'${j}_q_${i}'}, {exchange:'ex_11', queue:'${j}_q_${i}'}, {exchange:'ex_12', queue:'${j}_q_${i}'}, {exchange:'ex_13', queue:'${j}_q_${i}'}, {exchange:'ex_14', queue:'${j}_q_${i}'}, {exchange:'ex_15', queue:'${j}_q_${i}'}, {exchange:'ex_16', queue:'${j}_q_${i}'}, {exchange:'ex_17', queue:'${j}_q_${i}'}, {exchange:'ex_18', queue:'${j}_q_${i}'}, {exchange:'ex_19', queue:'${j}_q_${i}'}, {exchange:'ex_20', queue:'${j}_q_${i}'}, {exchange:'ex_21', queue:'${j}_q_${i}'}, {exchange:'ex_22', queue:'${j}_q_${i}'}, {exchange:'ex_23', queue:'${j}_q_${i}'}, {exchange:'ex_24', queue:'${j}_q_${i}'}, {exchange:'ex_25', queue:'${j}_q_${i}'}, {exchange:'ex_26', queue:'${j}_q_${i}'}, {exchange:'ex_27', queue:'${j}_q_${i}'}, {exchange:'ex_28', queue:'${j}_q_${i}'}, {exchange:'ex_29', queue:'${j}_q_${i}'}, {exchange:'ex_30', queue:'${j}_q_${i}'}, {exchange:'ex_31', queue:'${j}_q_${i}'}, {exchange:'ex_32', queue:'${j}_q_${i}'}, {exchange:'ex_33', queue:'${j}_q_${i}'}, {exchange:'ex_34', queue:'${j}_q_${i}'}, {exchange:'ex_35', queue:'${j}_q_${i}'}, {exchange:'ex_36', queue:'${j}_q_${i}'}, {exchange:'ex_37', queue:'${j}_q_${i}'}, {exchange:'ex_38', queue:'${j}_q_${i}'}, {exchange:'ex_39', queue:'${j}_q_${i}'}, {exchange:'ex_40', queue:'${j}_q_${i}'}, {exchange:'ex_41', queue:'${j}_q_${i}'}, {exchange:'ex_42', queue:'${j}_q_${i}'}, {exchange:'ex_43', queue:'${j}_q_${i}'}, {exchange:'ex_44', queue:'${j}_q_${i}'}, {exchange:'ex_45', queue:'${j}_q_${i}'}, {exchange:'ex_46', queue:'${j}_q_${i}'}, {exchange:'ex_47', queue:'${j}_q_${i}'}, {exchange:'ex_48', queue:'${j}_q_${i}'}, {exchange:'ex_49', queue:'${j}_q_${i}'}, {exchange:'ex_50', queue:'${j}_q_${i}'}] }}"" & sleep 0.1; done
	wait
done


2) while true; do date ""+%T.%N""; ./purge_queue whateverQueue 0 > /dev/null 2>&1; sleep 9.83; done

purge_queue.cpp:
/* To the extent possible under law, Red Hat, Inc. has dedicated all copyright
 * to this software to the public domain worldwide, pursuant to the CC0 Public
 * Domain Dedication. This software is distributed without any warranty.  See
 *  <http://creativecommons.org/publicdomain/zero/1.0/>.
*/

#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Session.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Address.h>

#include <iostream>
#include <cstdlib>

using namespace std;
using namespace qpid::messaging;
using namespace qpid::types;

int main(int argc, char** argv) {
  if (argc < 3) {
    cerr << ""Invalid number of parameters, expecting: queue_name, quantity."" << endl;
    return 1;
  }
  string queue_name = argv[1];
  uint32_t qty = atoi(argv[2]);

  Connection connection(argc>3?argv[3]:""localhost:5672"");
  connection.open();
  Session session = connection.createSession();
  Sender sender = session.createSender(""qmf.default.direct/broker"");
  Address responseQueue(""#reply-queue; {create:always, node:{x-declare:{auto-delete:true}}}"");
  Receiver receiver = session.createReceiver(responseQueue);

  Message message;
  Variant::Map content;
  Variant::Map OID;
  Variant::Map arguments;
  string object_name = ""org.apache.qpid.broker:queue:"" + queue_name;
  OID[""_object_name""] = object_name;

  arguments[""request""] = qty;

  content[""_object_id""] = OID;
  content[""_method_name""] = ""purge"";
  content[""_arguments""] = arguments;

  encode(content, message);
  message.setReplyTo(responseQueue);
  message.setProperty(""x-amqp-0-10.app-id"", ""qmf2"");
  message.setProperty(""qmf.opcode"", ""_method_request"");
  message.setContentType(""amqp/map"");
  Variant::Map map;
  decode(message, map);
  std::cout << map << std::endl;

  sender.send(message, true);

  Message response;
  if (receiver.fetch(response,qpid::messaging::Duration(30000)) == true) {
    qpid::types::Variant::Map recv_props = response.getProperties();
    if (recv_props[""x-amqp-0-10.app-id""] == ""qmf2"")
      if (recv_props[""qmf.opcode""] == ""_method_response"")
        std::cout << ""Response: OK"" << std::endl;
      else if (recv_props[""qmf.opcode""] == ""_exception"")
        std::cerr << ""Error: "" << response.getContent() << std::endl;
      else
        std::cerr << ""Invalid response received!"" << std::endl;
    else
      std::cerr << ""Invalid response not of qmf2 type received!"" << std::endl;
  }
  else
    std::cout << ""Timeout: No response received within 30 seconds!"" << std::endl;

  receiver.close();
  sender.close();
  session.close();
  connection.close();
  return 0;
}

"
Bug,QPID-6551,12831379,[C++ broker]: linearstore raising JERR_LFCR_SEQNUMNOTFOUND after sending many DTX transactions,pmoravec,pmoravec,Closed,Fixed,2015-06-16 8:42,C++,C++ Broker,,,,,,,"Sending many DTX transactions (such that tpl journal requires >64k journal files) causes a transaction fails with JERR_LFCR_SEQNUMNOTFOUND journal error:

jexception 0x0500 LinearFileController::find() threw JERR_LFCR_SEQNUMNOTFOUND: File sequence number not found (fileSeqNumber=0)

Reproducer:
nohup ./src/qpidd --load-module=src/linearstore.so --efp-file-size=32 --log-to-file=/tmp/qpidd.log &
# the --efp-file-size parameter is just for faster reproducer

./src/tests/qpid-txtest --dtx=yes --check=no --init=yes --tx-count=10 --total-messages=1000 --size=1
nohup ./src/tests/qpid-txtest --dtx=yes --check=no --init=no --tx-count=200000 --size=1 &

After a (longer) while, linearstore raises JERR_LFCR_SEQNUMNOTFOUND and subsequently various other exceptions/errors.

The root cause is:
- qpid/linearstore/journal/txn_map.h declares uint16_t pfid_
- but it needs to store file sequence number stored as uint64_t elsewhere
- for 65536th journal file (of tpl journal), re-casting uint64_t to uint16_t returns obvious zero
- but there is no file number zero in the journal 


Fix just being tested:

$ svn diff
Index: qpid/linearstore/journal/txn_map.cpp
===================================================================
--- qpid/linearstore/journal/txn_map.cpp	(revision 1680527)
+++ qpid/linearstore/journal/txn_map.cpp	(working copy)
@@ -36,7 +36,7 @@
 
 txn_data_t::txn_data_t(const uint64_t rid,
                        const uint64_t drid,
-                       const uint16_t pfid,
+                       const uint64_t pfid,
                        const uint64_t foffs,
                        const bool enq_flag,
                        const bool tpc_flag,
Index: qpid/linearstore/journal/txn_map.h
===================================================================
--- qpid/linearstore/journal/txn_map.h	(revision 1680527)
+++ qpid/linearstore/journal/txn_map.h	(working copy)
@@ -39,7 +39,7 @@
     {
         uint64_t rid_;      ///< Record id for this operation
         uint64_t drid_;     ///< Dequeue record id for this operation
-        uint16_t pfid_;     ///< Physical file id, to be used when transferring to emap on commit
+        uint64_t pfid_;     ///< Physical file id, to be used when transferring to emap on commit
         uint64_t foffs_;    ///< Offset in file for this record
         bool enq_flag_;     ///< If true, enq op, otherwise deq op
         bool tpc_flag_;     ///< 2PC transaction if true
@@ -47,7 +47,7 @@
         bool aio_compl_;    ///< Initially false, set to true when record AIO returns
         txn_data_t(const uint64_t rid,
                    const uint64_t drid,
-                   const uint16_t pfid,
+                   const uint64_t pfid,
                    const uint64_t foffs,
                    const bool enq_flag,
                    const bool tpc_flag,
$
"
Bug,QPID-3540,12526463,"Typecasting and alignment requirements for various platforms - ""increases required alignment of target type""",,chug,Closed,Fixed,2015-06-16 8:35,C++,C++ Broker,C++ Client,,,,,,"On sparc/solaris (and others) the following code generates an error:

  qpid/cpp/src/qpid/RefCountedBuffer.cpp line 37
    boost::intrusive_ptr<RefCounted>(reinterpret_cast<RefCountedBuffer*>(store)),

A workaround is the '(void *)' hack that quiets the compiler but leaves the
code exposed to a run time fault if the store object is not properly aligned:

    boost::intrusive_ptr<RefCounted>(reinterpret_cast<RefCountedBuffer*>((void*)store)),

Another error shows up in
  
  qpid/cpp/src/tests/qpid-perftest.cpp line 647
    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);

The (void *) hack silences the error here, too, but the run time code is exposed to
a data alignment fault.

I propose that these two pieces of code need work to guarantee the alignment
or to work around any memory reference fault.

1. In the store case, new() probably returns an address that meets the alignment
requirement. An assert would help diagnose when this assumption fails.

2. In the qpid-perftest case the size_t could be extracted from the raw buffer
with a memcpy and that would be safe to do in all architectures.

2A. A separate issue is the fact that size_t changes between 32-bit and 64-bit
platforms, and that the size_t does not appear to be byte swapped for interop
between big and little endian systems. If these messages are consumed only
by the sender then no problem.


"
Bug,QPID-4129,12598385,C++ Broker failed client authentication in multi-node cluster causes connection leak,chug,chug,Closed,Fixed,2015-06-16 8:35,C++,C++ Broker,,,,,,,"When an HA cluster has at least one connected peer cluster member and a client connection fails authentication then the broker::Connection is leaked.

The issue does not affect standalone brokers nor does it affect a clustered broker with no connected peers.
"
Bug,QPID-3981,12553997,Windows C++ Broker fails ACL self tests,aconway,chug,Closed,Fixed,2015-06-16 8:34,C++,C++ Broker,,,,,,,"Window powershell/python fail many ACL tests apparently because the UserId presented to ACL for lookup does not include the ""@QPID"" domain.

On Linux the log is

2012-05-04 16:36:46 debug ACL: Lookup for id:bob@QPID action:bind objectType:exchange name:amq.direct 
                    with params { routingkey=routing_key queuename=allow_queue }
2012-05-04 16:36:46 debug ACL: checking rule [rule 1 ruleMode = deny props{ }]
2012-05-04 16:36:46 debug ACL: Successful match, the decision is:deny

On Windows the log is:

2012-05-04 16:20:00 debug ACL: Lookup for id:bob action:bind objectType:exchange name:amq.direct 
                    with params { routingkey=routing_key queuename=allow_queue }
2012-05-04 16:20:00 debug ACL: No successful match, defaulting to the decision mode allow

Is there a trick for getting the self to work?"
Bug,QPID-6213,12753012,qpidd misses heartbeats,gsim,gsim,Closed,Fixed,2015-05-07 15:44,C++,C++ Broker,,,,,,,"Caused by https://issues.apache.org/jira/browse/QPID-5758. Reproducer from Pavel Moravec: create many heartbeat enabled connections and queues (e.g. 500 idle receivers, each with their own queue) and have the purge interval relatively short (to speed up reproducing).

The broker misses heartbeats and connections get timed out."
Bug,QPID-6178,12749782,[C++ Broker] compiler error Visual Studio 2008 and Boost 1.55,chug,chug,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"Boost 1.55 triggers a complaint/failure in VS2008:
{noformat}
6>..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(38) : error C2872: 'empty' : ambiguous symbol
6>        could be 'c:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\ivec.h(826) : void empty(void)'
6>        or       '..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(29) : const std::string `anonymous-namespace'::empty'
6>..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(38) : error C2446: ':' : no conversion from 'void (__cdecl *)(void)' to 'const std::string'
6>        No constructor could take the source type, or constructor overload resolution was ambiguous
6>..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(79) : error C2872: 'empty' : ambiguous symbol
6>        could be 'c:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\ivec.h(826) : void empty(void)'
6>        or       '..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(29) : const std::string `anonymous-namespace'::empty'
6>..\..\qpid\cpp\src\qpid\broker\MessageAdapter.cpp(79) : error C2446: ':' : no conversion from 'void (__cdecl *)(void)' to 'const std::string'
6>        No constructor could take the source type, or constructor overload resolution was ambiguous
{noformat}
This error can be reproduced by adding '#include <ivec.h>' in MessageAdapter.cpp. Boost 1.55 achieves the include through include path: interlocked.hpp -> intrin.h -> dvec.h -> fvec.h -> ivec.h
"
Bug,QPID-6241,12757101,"Windows build fails VS2010, x64",chug,chug,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"{noformat}
2>------ Build started: Project: amqp, Configuration: Debug x64 ------
2>  Session.cpp
2>C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\utility(163): error C2440: 'initializing' : cannot convert from 'int' to 'qpid::broker::TxBuffer *'
2>          Conversion from integral type to pointer type requires reinterpret_cast, C-style cast or function-style cast
2>          C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\include\utility(247) : see reference to function template instantiation 'std::_Pair_base<_Ty1,_Ty2>::_Pair_base<_Ty,_Ty>(_Other1 &&,_Other2 &&)' being compiled
2>          with
2>          [
2>              _Ty1=qpid::broker::TxBuffer *,
2>              _Ty2=uint64_t,
2>              _Ty=int,
2>              _Other1=int,
2>              _Other2=int
2>          ]
2>          ..\..\cpp\src\qpid\broker\amqp\Session.cpp(742) : see reference to function template instantiation 'std::pair<_Ty1,_Ty2>::pair<int,int>(_Other1 &&,_Other2 &&)' being compiled
2>          with
2>          [
2>              _Ty1=qpid::broker::TxBuffer *,
2>              _Ty2=uint64_t,
2>              _Other1=int,
2>              _Other2=int
2>          ]
{noformat}
"
Bug,QPID-6389,12774939,[C++ Broker] [AMQP 1.0] consumer attach with a null source leads to unexpected response,gsim,robbie,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"Upon a client attaching a durable consumer link with a null source (not null address), qpidd responds with an attach containing a non-null source with null address, then sends a closing detach with an error indicating no source was specfied. The message ""[Protocol] error Error on attach: No source specified!"" is output on the broker console.

From the spec, I would expect this to have resulted in either:
* A successfull attach to an existing \[possibly detached\] link, with the response source indicating the related terminus details.
* Returning an attach with a null source, and then a closing detach -without an error-, to indicate lack of a matching link.

This behaviour seems to be described at http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-transport-v1.0-os.html#doc-idp315568 with Fig 2.33 in particular being related, albeit for a producing link.

The JMS clients (old and new) currently do this to 'look up' durable subscriptions by attaching a link with a null source (only during unsubscribe currently, but in future also during subscriber open/creation verification as well), and monitoring the source value in the attach response from the broker."
Bug,QPID-6021,12735090,[AMQP 1.0] Improve performance,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,C++ Client,,,,,,Performance is poorer when using AMQP 1.0  (as compared to using AMQP 0-10). This is a JIRA to highlight a few changes to improve things in the next release cycle.
Bug,QPID-6218,12753694,xml exchange can be induced to make http requests,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"CVE-2014-3629  CVS: 3

Severity: Low

Vendor:

The Apache Software Foundation

Versions Affected:

Apache Qpid's qpidd up to and including version
0.30, where xml exchange module is loaded

Description:

The XML exchange type is an optional, dynamically loaded module for
qpidd that allows creation of exchanges that route messages based on
evaluating an xquery expression against them.

On parsing a message sent to an XML exchange, whose body is XML
containing a link to a DTD, the broker process will attempt to
retrieve the referenced resource(s). I.e. the broker process may be
induced to make outgoing HTTP connections by publishing a message
containing links to an XML exchange.

Solution:

A patch is available that prevents any retrieval of
external entities referenced in the XML. This will be included in
subsequent releases, but can be applied to 0.30 if desired. [Details
of patch and commit revision to be added]

Common Vulnerability Score information:

If the XML exchange functionality is not required, the module in
question need not be loaded at all. This can be done either by moving
the module - named xml.so - out of the module directory, or by setting
the --no-module-dir option and adding an explicit --load-module
argument for every required module.

Where the XML exchange functionality is required, authorisation may be
enabled to prevent all but trusted users from creating or publishning
to xml exchanges.

Credit:

This issue was discovered by G. Geshev from MWR Labs

Common Vulnerability Score information:

CVSS Base Score                   3.5
Impact Subscore                   2.9
Exploitability Subscore           6.8
CVSS Temporal Score               3
CVSS Environmental Score          Not Defined
Modified Impact Subscore          Not Defined
Overall CVSS Score                3
"
Bug,QPID-6303,12766377,[linearstore] Roll back auto-upgrade of store directory structure,kpvdr,kpvdr,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"While working on the ability to select partitions (QPID-5671) in linearstore for EFPs, the directory structure of the store was changed and optimized to support the use of symlinks. Code was added as a part of this work to auto-update the store directory structure when the old structure was encountered during a recovery.

Upon reflection and public discussion (http://qpid.2158936.n2.nabble.com/Linearstore-directory-structure-and-handling-structure-change-td7616306.html), it has been decided to roll back this part of the work. Any operation which changes or moves critical data without the direct permission/intervention of the user/owner is undesirable. One of the following is needed to rectify this situation:

# Keep the existing structure if possible, or
# Make the new version of the store use mutually exclusive directory structures such that the old version and new version do not overlap. It is the user's responsiblity to transfer the content from the old structure to the new."
Bug,QPID-6414,12777607,Skip HA tests if qpid-ha or qpid-config tools are not available.,aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,The HA tests should be skipped (not fail) if run in an environement where they cannot locate the qpid-ha or qpid-config tools (e.g. a downloaded tarball of the cpp code only)
Bug,QPID-6160,12748712,CLONE - [CPP Broker] [CPP Client] Disable SSLv3 support,kgiusti,kgiusti,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,C++ Client,,,,,,"SSLv3 is vulnerable to CVE-2014-3566, and will not fixed. 

Wherever a seure connection is established we should ensure that SSLv3 is not in the supported protocols."
Bug,QPID-6413,12777547,Sporadic failure of HA tests causd by maxNegotiateTimeout,aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"Sporadic connection failures in HA tests with the broker logs showing: ""No protocol received closing"". This indicates negotiation exceeded the maxNegotiateTime setting."
Bug,QPID-6135,12746670,build failure in qpid-cpp-0.30/src/tests/txshift.cpp,mcpierce,sharkcz,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"build fails with
...
CMakeFiles/txshift.dir/txshift.cpp.o: In function `boost::program_options::value_semantic* qpid::optValue<unsigned long>(unsigned long&, char const*)':
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/Options.h:77: undefined reference to `boost::program_options::value_semantic* qpid::create_value<unsigned long>(unsigned long&, std::string const&)'
collect2: error: ld returned 1 exit status

for a full please see build.log at http://s390.koji.fedoraproject.org/koji/taskinfo?taskID=1579517

The reason is that the workers atribute is declared as size_t and size_t is defined as unsigned long (as opposed to the usual unsigned int) and there is no instance of qpid::optValue() for size_t/unsigned long. The solution would be to add

template QPID_COMMON_EXTERN po::value_semantic* create_value(size_t& val, const std::string& arg);
 in src/qpid/Options.cpp, but I think it would conflict with existing create_value() functions, at least I recolled such problems from other projects.

The workaround is to declare workers as uint in txshift.cpp."
Bug,QPID-6230,12756110,[linearstore] qpid-qls-analyze fails when analyzing empty journal,kpvdr,kpvdr,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"If a new queue is created through QMF but never used, the store creates a queue directory and places an uninitialized journal file into it. If qpid-qls-analyze is used to look at this store, it fails with and error message:
{noformat}
Traceback (most recent call last):
  File ""/usr/bin/qpid-qls-analyze"", line 109, in <module>
    M.run()
  File ""/usr/bin/qpid-qls-analyze"", line 97, in run
    self.jrnl_recovery_mgr.run()
  File ""/usr/bin/qlslibs/anal.py"", line 73, in run
    jrnl.recover(self.high_rid_counter)
  File ""/usr/bin/qlslibs/anal.py"", line 358, in recover
    self._check_alignment()
  File ""/usr/bin/qlslibs/anal.py"", line 423, in _check_alignment
    remaining_sblks = self.last_record_offset % qlslibs.utils.DEFAULT_SBLK_SIZE
TypeError: unsupported operand type(s) for %: 'NoneType' and 'int'
{noformat}

Thanks to Jitka Kocnova for finding this bug. Method to reproduce:

Using a clean store:
{{qpid-config add queue q --durable}}

then stop the broker and analyze:
{{qpid-qls-analyze --stats <store-path>}}
"
Bug,QPID-4575,12631537,Support Visual Studio 2012,chug,chug,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"Building under VS2012 requires the whole ecosystem of

* qpid code
* boost
* cmake

to be on the same page. This issue chronicles the journey."
Bug,QPID-6269,12761441,timed autodelete doesn't work on recovered queues,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"I.e. if a durable timed autodelete queue is created, then the broker is restarted, the queue is recovered and never deleted if there is no subsequent subscriber."
Bug,QPID-5927,12729697,Broker does not support whitespace in passwords in SSL password file,gsim,chris.richardson,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"qpid/sys/ssl/util.cpp reads passwords from the password file with
...
    std::string password;
    file >> password;
...

The stream operator stops reading at the first whitespace character so a password of eg: ""this is a password""  (considered valid by certutil) will not be properly parsed by the broker.

Possibly use std::getline(file, password); or a stream manipulator instead.
"
Bug,QPID-6321,12768157,Can't build against latest 0.9,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,C++ Client,,,,,,Change to pn_delivery_tag_t breaks build.
Bug,QPID-5950,12731137,C++ Broker Windows Timer launches two simultaneous QueueCleaner::purge instances (was: invalid heap),,chug,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"Start broker with
{noformat}
qpidd  --auth no --no-data-dir --load-module ..\plugins\broker\amqpd.dll
{noformat}
Then launch a series (24000+) HelloWorld clients at it one at a time.
The broker fails with stack:
{noformat}
 	msvcp90d.dll!std::_Debug_message(const wchar_t * message=0x634c28d0, const wchar_t * file=0x634bdee0, unsigned int line=1948)  Line 24	C++
>	qpidcommond.dll!std::_Debug_heap<std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >,std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > >(std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > > _First={px=0x0133aa18 }, std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > > _Last={px=0x01276bf0 }, std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > _Pred=less)  Line 1948 + 0x17 bytes	C++
 	qpidcommond.dll!std::push_heap<std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >,std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > >(std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > > _First={px=0x01276bf0 }, std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > > _Last={px=0xcdcdcdcd }, std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > _Pred=less)  Line 2043 + 0x42 bytes	C++
 	qpidcommond.dll!std::priority_queue<boost::intrusive_ptr<qpid::sys::TimerTask>,std::vector<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >,std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > >::push(const boost::intrusive_ptr<qpid::sys::TimerTask> & _Pred={...})  Line 212 + 0x49 bytes	C++
 	qpidcommond.dll!qpid::sys::Timer::add(boost::intrusive_ptr<qpid::sys::TimerTask> task={...})  Line 196	C++
 	qpidbrokerd.dll!qpid::broker::QueueCleaner::purge(const std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > & batch=[1]({px=0x012a59c0 pn={...} }))  Line 86	C++
 	qpidbrokerd.dll!boost::_mfi::mf1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,qpid::broker::QueueCleaner,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>::operator()(qpid::broker::QueueCleaner * p=0x0127a398, const std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > & a1=[1]({px=0x012a59c0 pn={...} }))  Line 165 + 0x14 bytes	C++
 	qpidbrokerd.dll!boost::_bi::list2<boost::_bi::value<qpid::broker::QueueCleaner *>,boost::arg<1> >::operator()<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,boost::_mfi::mf1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,qpid::broker::QueueCleaner,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>,boost::_bi::list1<std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &> >(boost::_bi::type<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1> > __formal={...}, boost::_mfi::mf1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,qpid::broker::QueueCleaner,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &> & f={...}, boost::_bi::list1<std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &> & a={...}, boost::_bi::type<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1> > __formal={...})  Line 303 + 0x36 bytes	C++
 	qpidbrokerd.dll!boost::_bi::bind_t<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,boost::_mfi::mf1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,qpid::broker::QueueCleaner,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>,boost::_bi::list2<boost::_bi::value<qpid::broker::QueueCleaner *>,boost::arg<1> > >::operator()<std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > >(const std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > & a1=[1]({px=0x012a59c0 pn={...} }))  Line 47 + 0x23 bytes	C++
 	qpidbrokerd.dll!boost::detail::function::function_obj_invoker1<boost::_bi::bind_t<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,boost::_mfi::mf1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,qpid::broker::QueueCleaner,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>,boost::_bi::list2<boost::_bi::value<qpid::broker::QueueCleaner *>,boost::arg<1> > >,std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>::invoke(boost::detail::function::function_buffer & function_obj_ptr={...}, const std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > & a0=[1]({px=0x012a59c0 pn={...} }))  Line 132 + 0x10 bytes	C++
 	qpidbrokerd.dll!boost::function1<std::_Deque_const_iterator<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> >,1>,std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > const &>::operator()(const std::deque<boost::shared_ptr<qpid::broker::Queue>,std::allocator<boost::shared_ptr<qpid::broker::Queue> > > & a0=[1]({px=0x012a59c0 pn={...} }))  Line 760 + 0x1e bytes	C++
 	qpidbrokerd.dll!qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >::process()  Line 152 + 0x19 bytes	C++
 	qpidbrokerd.dll!qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >::dispatch(qpid::sys::PollableCondition & cond={...})  Line 139	C++
 	qpidbrokerd.dll!boost::_mfi::mf1<void,qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >,qpid::sys::PollableCondition &>::operator()(qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> > * p=0x0127a3b0, qpid::sys::PollableCondition & a1={...})  Line 165 + 0x10 bytes	C++
 	qpidbrokerd.dll!boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> > *>,boost::arg<1> >::operator()<boost::_mfi::mf1<void,qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >,qpid::sys::PollableCondition &>,boost::_bi::list1<qpid::sys::PollableCondition &> >(boost::_bi::type<void> __formal={...}, boost::_mfi::mf1<void,qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >,qpid::sys::PollableCondition &> & f={...}, boost::_bi::list1<qpid::sys::PollableCondition &> & a={...}, boost::_bi::type<void> __formal={...})  Line 314	C++
 	qpidbrokerd.dll!boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >,qpid::sys::PollableCondition &>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> > *>,boost::arg<1> > >::operator()<qpid::sys::PollableCondition>(qpid::sys::PollableCondition & a1={...})  Line 33	C++
 	qpidbrokerd.dll!boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> >,qpid::sys::PollableCondition &>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<boost::shared_ptr<qpid::broker::Queue> > *>,boost::arg<1> > >,void,qpid::sys::PollableCondition &>::invoke(boost::detail::function::function_buffer & function_obj_ptr={...}, qpid::sys::PollableCondition & a0={...})  Line 154	C++
 	qpidcommond.dll!boost::function1<void,qpid::sys::PollableCondition &>::operator()(qpid::sys::PollableCondition & a0={...})  Line 760 + 0x1a bytes	C++
 	qpidcommond.dll!qpid::sys::PollableConditionPrivate::dispatch(qpid::sys::windows::AsynchIoResult * result=0x012f8f48)  Line 85	C++
 	qpidcommond.dll!boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>::operator()(qpid::sys::PollableConditionPrivate * p=0x0127ae30, qpid::sys::windows::AsynchIoResult * a1=0x012f8f48)  Line 165 + 0x10 bytes	C++
 	qpidcommond.dll!boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> >::operator()<boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list1<qpid::sys::windows::AsynchIoResult * &> >(boost::_bi::type<void> __formal={...}, boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *> & f={...}, boost::_bi::list1<qpid::sys::windows::AsynchIoResult * &> & a={...}, boost::_bi::type<void> __formal={...})  Line 314	C++
 	qpidcommond.dll!boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> > >::operator()<qpid::sys::windows::AsynchIoResult *>(qpid::sys::windows::AsynchIoResult * & a1=0x012f8f48)  Line 33	C++
 	qpidcommond.dll!boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,boost::_mfi::mf1<void,qpid::sys::PollableConditionPrivate,qpid::sys::windows::AsynchIoResult *>,boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate *>,boost::arg<1> > >,void,qpid::sys::windows::AsynchIoResult *>::invoke(boost::detail::function::function_buffer & function_obj_ptr={...}, qpid::sys::windows::AsynchIoResult * a0=0x012f8f48)  Line 154	C++
 	qpidcommond.dll!boost::function1<void,qpid::sys::windows::AsynchIoResult *>::operator()(qpid::sys::windows::AsynchIoResult * a0=0x012f8f48)  Line 760 + 0x1a bytes	C++
 	qpidcommond.dll!qpid::sys::windows::AsynchCallbackRequest::complete()  Line 189	C++
 	qpidcommond.dll!qpid::sys::windows::AsynchResult::success(unsigned int bytesTransferred=0)  Line 57 + 0xf bytes	C++
 	qpidcommond.dll!qpid::sys::Poller::wait(qpid::sys::Duration timeout={...})  Line 196 + 0x12 bytes	C++
 	qpidcommond.dll!qpid::sys::Poller::run()  Line 118	C++
 	qpidcommond.dll!qpid::sys::Dispatcher::run()  Line 37 + 0x1d bytes	C++
 	qpidcommond.dll!qpid::sys::runThreadPrivate(void * p=0x0127f2f0)  Line 145 + 0x15 bytes	C++
 	msvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes	C
 	msvcr90d.dll!_threadstartex(void * ptd=0x01286c70)  Line 331	C
 	kernel32.dll!7547919f() 	
 	[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]	
 	ntdll.dll!776fa22b() 	
 	ntdll.dll!776fa201() 	
{noformat}
This broker was run from the command line and the debug focus was on the client and not the broker. I'll re-run the test with more instrumentation on the broker and post results here.
"
Bug,QPID-6274,12762277,[AMQP 1.0] subscriptions queues with timed autodelete should be deleted immediately when link is closed,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,The timeout will only apply if the link is detached without closing.
Bug,QPID-6310,12767087,unexpected protocol sequences not properly checked,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"Three distinct cases need better checking:

1. an invalid range in a sequence set

2. content-bearing methods other than message-transfer

3. a session-gap control before a corresponding session-attach"
Bug,QPID-6248,12757722,[linearstore] Symlink creation fails if store dir path is not absolute,kpvdr,kpvdr,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"Thanks to Alan Conway for finding this bug:
{quote}
I uncovered a bug in the way symlinks are created if the data directory
is not an absolute path. It appears that the code creating the symlink
assumes that the path is absolute, which gives invalid symlinks. For
example in the following the brokers working directory
is /home/aconway/qpid/debug/src/tests/interop_tests.tmp/interop_tests.PythonTxTest.test_tx_simple_rollback
and the data dir is ""broker2""
{noformat}
2014-11-18 11:26:33.216699232 [Store] debug Linear Store: Journal
""TplStore"":Journal directory = ""broker2/qls/tpl/""

ls -l /home/aconway/qpid/debug/src/tests/interop_tests.tmp/interop_tests.PythonTxTest.test_tx_simple_rollback/broker2/qls/jrnl/interop_tests.PythonTxTest.test_tx_simple_rollback-a
total 4
lrwxrwxrwx. 1 aconway aconway 71 Nov 18 11:18 3ee76ade-3793-4056-ac39-98f566cb345e.jrnl -> broker2/qls/p001/2048k/in_use/3ee76ade-3793-4056-ac39-98f566cb345e.jrnl
[aconway@wallace dispatch (trunk)]$ 	
{noformat}

I think you should be resolving the path to an absolute path (relative to current working dir) before creating the symlink.
{quote}"
Bug,QPID-6444,12781190,Build fails due to unused function warning,astitcher,astitcher,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,C++ Client,,,,,,"[0.32 RC fails to build with default instructions]

[59/254] Building CXX object src/CMake....dir/qpid/broker/amqp/Connection.cpp.o
FAILED: /usr/lib64/ccache/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -D_IN_QPID_BROKER -Damqp_EXPORTS -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -DNDEBUG -fPIC -I/home/andrew/Work/qpid/src-released/qpid/cpp/src -I/home/andrew/Work/qpid/src-released/qpid/cpp/src/../include -Isrc -Isrc/../include -I/usr/include/nss3 -I/usr/include/nspr4    -pthread -MMD -MT src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o -MF src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o.d -o src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o -c /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Connection.cpp
/home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Connection.cpp:457:13: error: ?쁲td::string qpid::broker::amqp::{anonymous}::convert(pn_delivery_tag_t)??defined but not used [-Werror=unused-function]
 std::string convert(pn_delivery_tag_t in)
             ^
cc1plus: all warnings being treated as errors
[107/254] Building CXX object src/CMak...pid/messaging/amqp/AddressHelper.cpp.o
FAILED: /usr/lib64/ccache/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -Dqpidmessaging_EXPORTS -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -DNDEBUG -fPIC -I/home/andrew/Work/qpid/src-released/qpid/cpp/src -I/home/andrew/Work/qpid/src-released/qpid/cpp/src/../include -Isrc -Isrc/../include -I/usr/include/nss3 -I/usr/include/nspr4    -pthread -fno-visibility-inlines-hidden -fvisibility=hidden -MMD -MT src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o -MF src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o.d -o src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o -c /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/messaging/amqp/AddressHelper.cpp
/home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/messaging/amqp/AddressHelper.cpp:141:6: error: ?쁞ool qpid::messaging::amqp::{anonymous}::contains(const List&, const string&)??defined but not used [-Werror=unused-function]
 bool contains(const Variant::List& list, const std::string& item)
      ^
cc1plus: all warnings being treated as errors
"
Bug,QPID-6299,12765488,can't combine ring queue and lvq functionality,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"Regression introduced (by me!) in the big refactor after 0.18. If a queue is specified to have a ring policy, lvq behaviour won't be supported even if requested."
Bug,QPID-5758,12713312,purging expired messages holds up other timer events,gsim,gsim,Closed,Fixed,2014-11-05 10:39,C++,C++ Broker,,,,,,,"Since the purging of expired messages from queues can be time consuming, it should really not be done on the timer thread or it can delay all other timer tasks. Since heartbeats are driven by the timer this can have adverse effects."
Bug,QPID-2374,12446939,"qpidd: --require-encryption with ""--auth no"" will reject SSL connections as being ""un-encrypted"" ",kgiusti,kgiusti,Closed,Fixed,2014-10-23 18:06,C++,C++ Broker,,,,,,,"Running qpidd with ""--auth no"" and ""--require-encryption"" will reject SSL-based encrypted connections.

Running qpidd like so:

$ ./qpidd --auth no --require-encryption --transport ssl --no-data-dir --no-module-dir --load-module ./.libs/ssl.so  --ssl-cert-db /home/kgiusti/.test_ssl_cert_db/test_cert_db  --ssl-cert-password-file /home/kgiusti/.test_ssl_cert_db/cert.password  --ssl-cert-name localhost.localdomain
2010-01-28 10:11:35 notice SASL disabled: No Authentication Performed
2010-01-28 10:11:35 notice Listening on TCP port 5672
2010-01-28 10:11:35 notice Listening for SSL connections on TCP port 5671
5671
2010-01-28 10:11:35 notice Broker running

And running perftest using SSL:

$ export QPID_NO_MODULE_DIR=1
$ export QPID_LOAD_MODULE=./.libs/sslconnector.so
$ export QPID_SSL_CERT_DB=/home/kgiusti/.test_ssl_cert_db/test_cert_db
$ export QPID_SSL_CERT_PASSWORD_FILE=/home/kgiusti/.test_ssl_cert_db/cert.password
$ ./tests/perftest --count 1 -P ssl -b localhost.localdomain --summary --port 5671

The connection is rejected, and the broker logs:

2010-01-28 10:13:18 error Rejected un-encrypted connection.

I think the proper behavior would have the broker allow encrypted SSL connections, even if --auth no."
Bug,QPID-6157,12748573,linearstore: segfault when 2 journals request new journal file from empty EFP,pmoravec,pmoravec,Closed,Fixed,2014-10-17 8:24,C++,C++ Broker,,,,,,,"Description of problem:
Broker using linearstore module can segfault when:
- EFP is empty
- 2 journals concurrently request new journal file from EFP

There is a race condition described in Additional info that leads to segfault.


Version-Release number of selected component (if applicable):
any


How reproducible:
100% in few minutes (on faster machines)


Steps to Reproduce:
Reproducer script:

topics=10
queues_per_topic=10

rm -rf /var/lib/qpidd/* /tmp/qpidd.log
service qpidd restart

echo ""$(date): creating $(($((topics))*$((queues_per_topic)))) queues""
for i in $(seq 1 $topics); do
  for j in $(seq 1 $queues_per_topic); do
    qpid-receive -a ""Durable_${i}_${j}; {create:always, node:{durable:true, x-bindings:[{exchange:'amq.direct', queue:'Durable_${i}_${j}', key:'${i}'}] }}"" &
  done
done
wait

echo ""$(date): queues created""
while true; do
  echo ""$(date): publishing messages..""
  for i in $(seq 1 $topics); do
    qpid-send -a ""amq.direct/${i}"" -m 1000000 --durable=yes --content-size=1000 &
  done
  wait
  echo ""$(date): consuming messages..""
  for i in $(seq 1 $topics); do
    for j in $(seq 1 $queues_per_topic); do
      qpid-receive -a ""Durable_${i}_${j}"" -m 1000000 --print-content=no &
    done
  done
  wait
done

#end of the script


Actual results:
segfault with bt:

Thread 1 (Thread 0x7ff85b3f1700 (LWP 17810)):
#0  0x00007ff9927104f3 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::assign(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /usr/lib64/libstdc++.so.6
No symbol table info available.
#1  0x00007ff98e59d6a1 in operator= (this=0x1ab3480) at /usr/include/c++/4.4.7/bits/basic_string.h:511
No locals.
#2  qpid::linearstore::journal::EmptyFilePool::popEmptyFile (this=0x1ab3480)
    at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/EmptyFilePool.cpp:213
        l = {_sm = @0x1ab34f8}
        emptyFileName = """"
        isEmpty = true
#3  0x00007ff98e59ddec in qpid::linearstore::journal::EmptyFilePool::takeEmptyFile (this=0x1ab3480, destDirectory=
    ""/var/lib/qpidd/qls/jrnl/DurableQueue"")
    at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/EmptyFilePool.cpp:108
        emptyFileName = """"
        newFileName = """"


Expected results:
no segfault


Additional info:
Relevant source code:

std::string EmptyFilePool::popEmptyFile() {
    std::string emptyFileName;
    bool isEmpty = false;
    {
        slock l(emptyFileListMutex_);
        isEmpty = emptyFileList_.empty();
    }
    if (isEmpty) {
        createEmptyFile();
    }
    {
        slock l(emptyFileListMutex_);
        emptyFileName = emptyFileList_.front();    <-- line 213
        emptyFileList_.pop_front();
    }
    return emptyFileName;
}

If two requests (R1 and R2) are made concurrently when EFP is empty such that:
- R1 performs most of the function until line 212 (second lock)
  - this means creating one empty file
- R2 performs the same - but now EFP has one file so no new file to be created
- R1 (or R2, it does not matter) continues on line 212 and further
  - so it takes the empty file
- the second request tries to take an empty file from the empty EFP and triggers the segfault
"
Bug,QPID-658,12380787,NoLocal messages should be deleted when the queue is exclusive,gsim,arnaudsimon,Closed,Fixed,2014-10-10 12:43,C++,C++ Broker,JMS AMQP 0-x,,,,,,For JMS we need the broker to delete messages of an exclusive queue that cannot be delivered to the consumer because of Nolocal. This is a simple fix for supporting the JMS notion of noLocal (topic only). 
Bug,QPID-6069,12738917,Does not compile under C++11 on FreeBSD,astitcher,astitcher,Closed,Fixed,2014-09-26 21:40,C++,C++ Broker,C++ Client,,,,,,There are some small compile problems that have crept in over the 0.30 release cycle that prevent qpid from compiling with clang++ and libc++ under FreeBsd 10.
Bug,QPID-5859,12724197,Qpidd only listens to protocols that are already up when it starts,astitcher,astitcher,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"When you run qpidd as a service it might be started before networking is fully configured, but the network may work later on.

Currently qpidd will only listen to protocols that have a global address configured configured on a non loopback address.

It would be better to not make this requirement and to listen anyway. That way if the protocol becomes available after qpidd has started it should work ""automatically"""
Bug,QPID-5902,12727989,C++ Broker Acl changes break RHEL5 builds,chug,chug,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,RHEL 5 boost does not support make_shared
Bug,QPID-5706,12708805,[AMQP 1.0] can't easily correlate broker initiated inks with their domain,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,as the qmf properties don't include any mention of the domain
Bug,QPID-5963,12732072,Decoding error on outgoing connection over SSL,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"See http://qpid.2158936.n2.nabble.com/Inter-broker-link-with-SSL-td7611235.html for description of issue and analysis by Chris Richardson.

Summary: if less than 8 bytes are received initially, the protocol header can't be decoded but the broker thinks it has already done so, resulting in decoding errors when more data arrives."
Bug,QPID-5783,12716351,unnecessary copying of date for message on many queues,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,The memory used when sending messages to a large number of  queues is higher than it needs to be as only the data as read of the wire is shared. The memory used can be reduced by sharing some of the essentially immutable state computed before enqueing.
Bug,QPID-5765,12714207,rerouting messages to non-local filtered queue crashes broker,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"If you have a queue with messages on it published by a connection that no longer exists, and you re-route these for whatever reason through an exchange with a queue bound that has the no-local filtering enabled, the broker will crash."
Bug,QPID-5890,12726804,C++ Broker AclModule.h compiles static code dozens of times,chug,chug,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,AclModule needs to be refactored.
Bug,QPID-5747,12712575, Federated link ends up in Connecting state forever after connecting to shutting down broker,gsim,pmoravec,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"Description of problem:
Having federation link with source broker S and destination broker D (such that TCP connection is initiated by D and messages flow from S to D), if the link is attempting to reconnect to S while S is just shutting down, there is a probability the link will stay in Connecting state forever.


Version-Release number of selected component (if applicable):
0.18-11, 0.18-14, 0.18-20


How reproducible:
100% after some time


Steps to Reproduce:
1. Mimic broker S by simple python program:

import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Bind the socket to the port
server_address = ('localhost', 10000)
print >>sys.stderr, 'starting up on %s port %s' % server_address
sock.bind(server_address)
# Listen for incoming connections
sock.listen(1)

# Wait for a connection
print >>sys.stderr, 'waiting for a connection'
connection, client_address = sock.accept()

2. In one terminal, run it in a loop:
while true; do python server.py; done

2a. rather for observation: run tcpdump on port 10000

3. In another terminal, create federation link to this ""server"":
qpid-route link add localhost:5672 localhost:10000

4. Wait few seconds and generate whatever traffic to the broker to make it busy, i.e.:
qpid-send -a amq.fanout -m 1000000 --content-size=1000

5. Check tcpdump when it stops logging new traffic and execute how many times you wish:
qpid-route link list

Actual results:
Everytime and forever, the link status will be Connecting like:

Host            Port    Transport Durable  State             Last Error
=============================================================================
localhost       10000   tcp          N     Connecting        Closed by peer

(expected observation is that python ""server"" cant bind to port 10000 due to ""Address already in use"" for some time - that is expected as previous TCP connection is in some FIN_WAIT-like state so far; but even if the ""server"" can bind to the port after a while, the broker does not attempt to reconnect)


Expected results:
Link status flapps between Waiting and Connecting, until the server is ready again and the link is Operational (wont happen in this scenario due to the ""server.py"" implementation)


Additional info:
The key is, the qpid broker can't send initial ""AMQP 0-10"" frame to the peer. I.e. the bug appears if and only if:
- TCP connection is fully established (3way handshake) such that qpid::broker::connect method returns success
- but closed so fast such that Link::established is not invoked / broker does not react on the connection establishment

That is why it helps / speedups reproducer to put the broker under load."
Bug,QPID-5886,12726451,C++  Broker OutgoingMessage change exposes Completion handle export issue on Windows,chug,chug,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,C++ Client,,,,,,"Windows builds have been failing mysteriously for me for a few weeks[1]. I found the issues/ QPID-5828 r1604952 changed OutgoingMessage such that the Completion object now needs to access Handle<CompletionImpl>::isValid().

Simply instantiating the Handle superclass (r1525706 for example) didn't work. On windows the classes won't export from a .h file but need to come from .cpp files. Review is coming up shortly.

[1] Why some builds work and some don't is unsolved."
Bug,QPID-3650,12533291,cast-align errors while building for various architectures,mcpierce,cpollmeier,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"While running thru various architecture builds for Debian, I'm running in these errors for ia64, armel, mips, mipsel and sparc:

8<----
libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../include -I../include -I. -I=. -D_FORTIFY_SOURCE=2 -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -DQPID_LIBEXEC_DIR=\""/usr/lib/qpid\"" -DBOOST_FILESYSTEM_VERSION=2 -Wno-missing-field-initializers -g -O2 -fstack-protector --param=ssp-buffer-size=4 -Wformat -Wformat-security -Werror=format-security -c qpid/sys/rdma/RdmaIO.cpp  -fPIC -DPIC -o qpid/sys/rdma/.libs/librdmawrap_la-RdmaIO.o
qpid/sys/rdma/RdmaIO.cpp: In member function 'void Rdma::AsynchIO::queueBuffer(Rdma::Buffer*, int)':
qpid/sys/rdma/RdmaIO.cpp:203:59: error: cast from 'char*' to 'uint32_t* {aka unsigned int*}' increases required alignment of target type [-Werror=cast-align]
cc1plus: all warnings being treated as errors

make[4]: *** [qpid/sys/rdma/librdmawrap_la-RdmaIO.lo] Error 1
make[4]: Leaving directory `/build/buildd-qpid-cpp_0.12-2-armel-ztyDej/qpid-cpp-0.12/src'
make[3]: *** [all-recursive] Error 1
make[3]: Leaving directory `/build/buildd-qpid-cpp_0.12-2-armel-ztyDej/qpid-cpp-0.12/src'
make[2]: *** [all] Error 2
make[1]: *** [all-recursive] Error 1
dh_auto_build: make -j1 returned exit code 2
make[2]: Leaving directory `/build/buildd-qpid-cpp_0.12-2-armel-ztyDej/qpid-cpp-0.12/src'
make[1]: Leaving directory `/build/buildd-qpid-cpp_0.12-2-armel-ztyDej/qpid-cpp-0.12'
make: *** [build] Error 2

8<----

The complete logs are here:

https://buildd.debian.org/status/package.php?p=qpid-cpp"
Bug,QPID-5898,12727647,C++ Broker AclHost test fails on systems with no IPv6,chug,chug,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,Test cases fail because none of the specified IPv6 addresses resolves to a valid host. The AclHost test needs to test if IPv4 or IPv6 is enabled before expecting to create AclHost objects of that protocol family.
Bug,QPID-5729,12711012,[AMQP 1.0] concurrent triggering of auto-created topic causes exception,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"If you have a topic policy that causes a topic to be created on demand, and two links concurrently request a link to/from that topic, there is a race such that the second sometimes tries to recreate the topic and gets an exception saying it already exists."
Bug,QPID-5804,12719990,Selectoy parser incorrectly parses unary '+' operator,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"The selector parser ignores the unary + operator and gives an error instead: for example it should allow

amqp.priority>+2"
Bug,QPID-5865,12724737,The client and broker heartbeat code can get confused when the system time changes,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,C++ Client,,,,,,"The underlying timekeeping code in C++ qpid currently uses CLOCK_REALTIME which is related to wallclock time and can go backwards and skip time forwards (either due to NTP or administrator action).

This is not ideal because it can cause false timeouts to occur based on the system time rather than elapsed time.

It would be better for most timing to be based on CLOCK_MONOTONIC which is steadily increasing time based on the system uptime. That will avoid problems due to the system time changing."
Bug,QPID-5705,12708804,[AMQP 1.0] wrong error message when domain already exists,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"if you attempt to create a domain with a name that already exists, the error says the type is not known which is wrong."
Bug,QPID-5667,12707016,C++ broker: QMF subscribe events are not raised with AMQP 1.0,aconway,aconway,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"QMF subscribe and unsubscribe events are not raised with the AMQP 1.0 protocol.

To reproduce:
1. Start a qpidd broker with AMQP 1.0 support
2. Start qpid-printevents to show QMF events on the broker.
3. run: qpid-receive -a ""q;{create:always}"" 
    Note printevents shows subscribe and unsubscribe events.
4. run: qpid-receive -a ""q;{create:always}"" --connection-options '{protocol:amqp1.0}'
    Note there are no subscribe/unsubscribe events in printevents output."
Bug,QPID-5849,12723687,mechanism not set when auth=no,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,not a huge issue since only plain and anonymous are then available (and easy to tell these apart) but qpid-stat -c shows blank fields which is annoying
Bug,QPID-6089,12740247,Qpidd doesn't correctly parse --known-hosts-url option,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"The broker doesn't correctly parse fully specified connections urls for the --known-hosts-url option, instead it will refuse to start. For example:

qpidd --no-module-dir --known-hosts-url amqp:tcp:localhost:5672

Will fail to startup."
Bug,QPID-5725,12710829,Message::getProperty() can return result for a property name which is a prefix of the actual name,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"When comparing the lookup name with the actual property names the test only compares the number of characters in the smallest of the strings being compared (instead of ensuring that they have the same number of characters). This means that it will return incorrect property values.
"
Bug,QPID-1381,12406934,ACL file reader does not reject file with empty extention lines,chug,rajith,Closed,Fixed,2014-07-24 17:20,C++,C++ Broker,,,,,,,"The following ACL file should be rejected as it contains an empty extention line.

group myGroup bob@QPID \
                                                  \
                               joe@QPID
acl allow all all"
Bug,QPID-4373,12611842,C++ Broker ACL changes cause regressions,chug,chug,Closed,Fixed,2014-07-11 13:31,C++,C++ Broker,,,,,,,"Recent changes (r1348707 11-Jun-2012) cause regressions:

1. Deleting the broker management property 'maxConns' causes needless hardship for downstream projects that are expecting it. 

I propose to restore this property and populate it as before.

2. CLI switch max-connections is ambiguous with respect to max-connections-per-ip and max-connections-per-user for older versions of boost program_options.

I propose to resolve the ambiguity by renaming the new options:

max-connections-per-user => limit-connections-per-user
max-connections-per-ip   => limit-connections-per-ip


"
Bug,QPID-5869,12725110,Specifying an invalid ACL file will cause a core dumps when management is disabled,rajith,rajith,Closed,Fixed,2014-07-03 13:17,C++,C++ Broker,,,,,,,"The root cause is due to the ACL module trying to fire an event regardless of whether the management module is there or not.

Core was generated by `./qpidd --auth no -m no -t --acl-file ./data/acl.txt'.
Program terminated with signal 11, Segmentation fault.
#0  0x00007f7e5e855bbd in qpid::management::ManagementAgent::raiseEvent(qpid::management::ManagementEvent const&, qpid::management::ManagementAgent::severity_t) () from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
Missing separate debuginfos, use: debuginfo-install boost-program-options-1.53.0-14.fc19.x86_64 libuuid-2.23.2-5.fc19.x86_64 nspr-4.10.6-1.fc19.x86_64 nss-3.16.1-1.fc19.x86_64 nss-util-3.16.1-1.fc19.x86_64
(gdb) bt
#0  0x00007f7e5e855bbd in qpid::management::ManagementAgent::raiseEvent(qpid::management::ManagementEvent const&, qpid::management::ManagementAgent::severity_t) () from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#1  0x00007f7e5e6bf20d in qpid::acl::Acl::readAclFile(std::string&, std::string&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#2  0x00007f7e5e6bf0b7 in qpid::acl::Acl::readAclFile(std::string&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#3  0x00007f7e5e6bdd23 in qpid::acl::Acl::Acl(qpid::acl::AclValues&, qpid::broker::Broker&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#4  0x00007f7e5e6d4273 in qpid::acl::AclPlugin::init(qpid::broker::Broker&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#5  0x00007f7e5e6d4851 in bool qpid::acl::AclPlugin::init<qpid::broker::Broker>(qpid::Plugin::Target&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#6  0x00007f7e5e6d4425 in qpid::acl::AclPlugin::initialize(qpid::Plugin::Target&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#7  0x00007f7e5e03287c in boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>::operator()(qpid::Plugin*, qpid::Plugin::Target&) const ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#8  0x00007f7e5e032263 in void boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> >::operator()<boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list1<qpid::Plugin* const&> >(boost::_bi::type<void>, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>&, boost::_bi::list1<qpid::Plugin* const&>&, int) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#9  0x00007f7e5e0317ca in void boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > >::operator()<qpid::Plugin*>(qpid::Plugin* const&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#10 0x00007f7e5e030d43 in boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > std::for_each<__gnu_cxx::__normal_iterator<qpid::Plugin* const*, std::vector<qpid::Plugin*, std::allocator<qpid::Plugin*> > >, boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > >(__gnu_cxx::__normal_iterator<qpid::Plugin* const*, std::vector<qpid::Plugin*, std::allocator<qpid::Plugin*> > >, __gnu_cxx::__normal_iterator<qpid::Plugin* const*, std::vector<qpid::Plugin*, std::allocator<qpid::Plugin*> > >, boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > >) () from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#11 0x00007f7e5e02fa3b in void qpid::(anonymous namespace)::each_plugin<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > >(boost::_bi::bind_t<void, boost::_mfi::mf1<void, ---Type <return> to continue, or q <return> to quit---
qpid::Plugin, qpid::Plugin::Target&>, boost::_bi::list2<boost::arg<1>, boost::reference_wrapper<qpid::Plugin::Target> > > const&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#12 0x00007f7e5e02f9cb in qpid::Plugin::initializeAll(qpid::Plugin::Target&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidcommon.so.2
#13 0x00007f7e5e701a04 in qpid::broker::Broker::Broker(qpid::broker::BrokerOptions const&) ()
   from /home/rajith/workspace/git-qpid/qpid/qpid/cpp/build/src/libqpidbroker.so.2
#14 0x0000000000406287 in qpid::broker::QpiddBroker::execute(qpid::broker::QpiddOptions*) ()
#15 0x00000000004096af in qpid::broker::run_broker(int, char**, bool) ()
#16 0x00000000004066d5 in main ()"
Bug,QPID-5447,12687190,Link detached by peer with amqp:precondition-failed: Exchange of different type already exists,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,"When running:

 spout --connection-options '{protocol:amqp1.0}' ""amq.direct; {create:always, node:{type:topic}}""

Since no exchange type was explicitly requested, this error shouldn't occur."
Bug,QPID-5501,12690235,[AMQP 1.0] create topic doesn't fail if topic of same name already exists,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,which is the expected behaviour as implemented for all other object types.
Bug,QPID-5395,12682891,[AMQP 1.0] direct proton tracing into qpids own logging,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,At present protons tracing is entirely distinct from qpidcpp's logging (whether qpidd or qpid:messaging). This means you can't direct the tracing to a file or to syslog. Traces from concurrent connections often get interleaved making them very hard to read.
Bug,QPID-5451,12687608,[AMQP 1.0] overly verbose logging at notce level for message sequence annotations over AMQP 1.0,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,The fix to QPID-5106 unintentionally left in some logging at too verbose a level. This should be removed.
Bug,QPID-5384,12682381,[AMQP 1.0] can't assert on autodelete property,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,this is a result of it actually being communicated as a lifetime-policy (at least in the case of queues)
Bug,QPID-5427,12685124,It is possible to mask critical logging messages,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,"As far as I understand it the entire point of log messages at the ""critical"" level is that they cannot be turned off at all. That is what critical means - the user *must* be informed of the confition being logged.

Unfortunately for a little while now it has been possible to turn all log levels off by specifying ""--log-disable trace+"" or using ""--log-enable !trace+"".
"
Bug,QPID-5630,12701613,Windows C++ broker never finds modules in module directory,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,"There is an error in the way that the --module-dir option works on windows which means that it doesn't try to load modules with the correct name and hence will never load any module automatically.

[modules loaded with --load-module and an explicit path will work]"
Bug,QPID-5641,12702881,[legacystore] Valgrind reports memory leaks on older store tests,kpvdr,kpvdr,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,"When running cmake test, between one and four of the older tests fail with memory leaks reported by Valgrind:

SimpleTest
OrderingTest
TransactionalTest
TwoPhaseCommitTest

These are early tests which use broker components in unconventional ways to test store functionality. Stack trace analysis suggests that the leaks originate in the handling and destruction of static objects and are tied in with the boost test framework which is used in these cases."
Bug,QPID-5681,12707931,c++ broker: Fix core dump interlink tests,aconway,aconway,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"Sporadic core dump in interlink_tests.AmqpBrokerTest.test_translate_with_large_routingkey 
when qpid is built with proton version <= 0.6. Fixed in proton version 0.7

In r1585588 ( QPID-5560: HA tests do not use AMQP 1.0 ) the brokertest, used by this test, was modified to use the swig python client if available. This appears to expose a bug in proton <= 0.6."
Bug,QPID-5457,12688043,[AMQP 1.0] broker doesn't handle messages composed from multiple transfers ,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"E.g. when sending messages from AMQP 1.0 JMS client that are over 64k in length, the client will send these by several partial transfers, but the broker attempt to parse the first transfer as if it were the complete message. (leading to an out of bounds error)."
Bug,QPID-5498,12690075,paged out messages loses expiration,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,meaning expired messages are delivered rather than dropped
Bug,QPID-5658,12706289,C++ code not compiling with libc++,astitcher,astitcher,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,FreeBSD 10 now uses a new compiler/library chain as default. The new C++ standard library has some small differences than the GNU C++ standard library.
Bug,QPID-5468,12688347,[AMQP 1.0] delete-if-unused doesn't work for initial sender,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"if a queue is created by establishing a sender to it, and delete-if-unused is specified, the queue is not deleted when the sender exits (even when no other links to it exist, i.e. it is unused)."
Bug,QPID-5502,12690269,[AMQP 1.0] implement qmf operations for closing connection and ending (detaching) session,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,As these operations are available for 0-10
Bug,QPID-5440,12685811,[AMQP 1.0] display alternate-exchange property for topic,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"{noformat}
$ qpid-config add topic my-topic --argument exchange=amq.direct --argument alternate-exchange=amq.fanout
$ qpid-config list topic
Objects of type 'topic'
  name      durable  properties  exchangeRef
  ============================================
  my-topic  False    {}          amq.direct
{noformat}

properties should include the alternate-exchange."
Bug,QPID-5469,12688352,[AMQP 1.0] don't override autodeletion if implied by topic policy,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"AT present the autodelete setting of a subscription queue is always inferred from the durability and reliability of the link. However if the topic policy specifies autodeletion, links should not be able to override this."
Bug,QPID-5383,12682367,[AMQP 1.0] string valued properties for queues created on attach lose encoding,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"E.g. if setting the last value key to use, then retrieving that via a queue-query in 0-10 it will appear as a vbin16 instead of a str16. This affects assertions in mixed protocol environments."
Bug,QPID-5467,12688342,[AMQP 1.0] delete-on-closed not handled correctly,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"If there is an exception e.g. in processing the filter for a queue created with lifetime-policy delete-on-close, then the queue is not released from use.

Also, if two links specify delete-on-close for the same queue then the second will cause an assertion in the broker. Only the link that created the queue should attempt to set itself as the controlling user."
Bug,QPID-5659,12706291,C++ not compiling (correctly) as C++11,astitcher,astitcher,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,"In order to avoid a compile bug with libc++ and boost you have to compile qpid as C++11 under FreeBSD 10.

The current qpid code needs some small adjustments to compile correctly as C++11"
Bug,QPID-5697,12708307,An exchange is deleted by a request for topic removal,,eallen,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"When a topic delete request is issued and the topic does not exist and there is an exchange of that name, the exchange is deleted which is obviously not intended. When the topic exists the topic is deleted first, see additional info for more details.
How reproducible:
100%

Steps to Reproduce:
1. qpid-config add exchange fanout myExchange
2. qpid-config del topic myExchange

Exchange myExchange removed instead of 'Topic not found' exception
"
Bug,QPID-5750,12712831,[linearstore] Broker fails with JERR__AIO: AIO error. (AIO write operation failed: Invalid argument (-22),kpvdr,kpvdr,Closed,Fixed,2014-05-13 14:13,C++,C++ Broker,,,,,,,"While running soak tests, the following failure is occasionally seen:
{noformat}
[Protocol] error Connection qpid.[::1].5672-[::1]:37555 closed by error: Queue Ve0-2: async_dequeue() failed: jexception 0x0103 wmgr::get_events() threw JERR__AIO: AIO error. (AIO write operation failed: Invalid argument (-22) [pg=0 size=32768 offset=266368 fh=22])
{noformat}
which indicates a problem with the write calls to the AIO libraray.

This error appears to be probabilistic."
Bug,QPID-5694,12708284,Windows C++ broker SSL sends non-existent negotiation token on shutdown,cliffjansen,cliffjansen,Closed,Fixed,2014-04-17 6:26,C++,C++ Broker,,,,,,,"The Windows SChannel logic for releasing resources on shutdown of a broker connection, ""negotiateStep(0);"", incorrectly generates a new SSL handshake exchange after queueWriteClose, allowing for thread activity after the ServerSslAsynchIO object's memory has been deleted."
Bug,QPID-5678,12707477,[linearstore 0.28] segfault in qpid::linearstore::journal::jdir::clear_dir when declaring durable queue,kpvdr,kpvdr,Closed,Fixed,2014-04-09 16:18,C++,C++ Broker,,,,,,,"Pavel Moravec discovered a bug and submitted a fix on trunk (See QPID-5651). This issue also exists on the 0.28 branch, where the same fix applies.

Reviewboard: https://reviews.apache.org/r/20003/"
Bug,QPID-4631,12635666,C++ Broker interbroker links should be protected by ACL,chug,chug,Closed,Fixed,2014-03-05 2:33,C++,C++ Broker,,,,,,,"This issue addresses CVE-2012-4446

Federated interbroker links may be opened by client programs and not just by brokers. By default the creation of these links is not protected any formal authorization.

Users concerned about this issue may immediately lock their systems down by creating ACL rules that allow links to be created only by authorized users. For instance the following ACL rules on each broker would provide the lockdown necessary:

  group proxies <id1> <id2> ...
  acl allow    proxies create link
  acl deny-log all     create link

A better solution is for the ACL module to deny the creation of links unless ACL rules are specified to specifically allow them.
In pseudo code the solution is in two parts. Part one observes CREATE LINK rules in the acl file. Part two authorizes link creation only if ACL is loaded, CREATE LINK ACL rules are specified, and the specific user is authorized to create the link in question:

function readAclFile()
  ...
  if (CREATE LINK rules are specified)
    set acl->createLinkFlag
  endif
  ...
end function

function brokerCreateLink()
  if (aclLoaded)
    if (acl->createLinkFlag)
      if (acl->authorise(user, create, link, properties))
        <create link allowed>
      else
        <create link denied - not authorized>
      endif
    else
      <create link denied - acl did not specify a create link rule>
    endif
  else
    <create link denied - acl module not loaded>
  endif
end function

This Jira will track the implementation of this restriction."
Bug,QPID-5291,12677416,[AMQP 1.0] set connection properties from management schema if available,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"I.e. pid, parent-pid and process-name"
Bug,QPID-5232,12673855,[AMQP 1.0] receiver links from exchanges should be unreliable by default,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,and also use autodelete queues by default.
Bug,QPID-5106,12666299,Queue level message sequencing doesn't work with 1.0 client,gsim,scholzj,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"The JIRA QPID-4591 added the queue level sequencing. I played with it with the 0.24RC3 release and it seems it doesn't work properly with AMQP 1.0 producers (C++ / Qpid Messaging API). 

My queue is configured with following option:
    u'qpid.queue_msg_sequence': u'queue.sequence'

The connection which sends a message into this queue seems to be closed due to the amqp:internal-error:
[0xda1200:0] <- CLOSE @24 [@29 [:""amqp:internal-error"", ""Expected descriptor of type ulong or symbol; found "", null]]
[0xda1200:0] <- EOS
2013-08-30 13:51:18 [Network] debug localhost:20000 decoded 107 bytes from 107
Exception: Connection closed by peer
2013-08-30 13:51:18 [Messaging] debug [127.0.0.1:39092-localhost:20000] TcpTransport closing...
2013-08-30 13:51:18 [Messaging] debug [127.0.0.1:39092-localhost:20000] Socket closed
2013-08-30 13:51:18 [Messaging] debug Driver stopped

And the broker log seems to complain about the type:
2013-08-30 13:51:18 [Broker] warning Exchange response cannot deliver to  queue response.ABCFR_ABCFRALMMACC1.b3458152-e106-42a6-9c8c-4984c08cff81: Expected descriptor of type ulong or symbol; found
2013-08-30 13:51:18 [Broker] error qpid.127.0.0.1:20000-127.0.0.1:39092: Expected descriptor of type ulong or symbol; found

When the sender is using AMQP 0.10, the sequencing seems to work fine.

---

Additionally, when AMQP 1.0 is used for receiving the sequenced message, I seem to be unable to get the sequence number property. Using msgProperties[""queue.sequence""].asString() seems to return only empty string and nothing else. Again, with 0.10 the sequence number seems to be returned properly.

Thanks & Regards
Jakub
"
Bug,QPID-5146,12669621,[AMQP 1.0] capabilities not handled correctly,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,If there is more than one capability it should be sent as an array of symbols. Need to be able to read capabilities as either an array or a single symbol.
Bug,QPID-5312,12678235,Paged queue does not deliver all messages,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"In particular when either max-pages-loaded is 1 or when selectors are used. The problem in both cases is where the head of the queue is not loaded when a new subscription comes in, and the logic doesn't recognise this and load the page, but rather just assumes there is nothing in it."
Bug,QPID-5153,12670042,[AMQP 1.0] specific message properties not read by broker for 1.0 messages,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"LVQs and MessageGroup queues require the broker to read a particular property from a message. For an AMQP 1.0 message this is not yet implemented, so these queue types do not work as expected.

(Just for extra info, selectors use Message::processProperties() rather than Message::getPropertyAsString() which is why they are not affected)."
Bug,QPID-5246,12674535,ACL treats DeleteQueue as a Reject Queue,gsim,adflowers,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"ACL does not yet support the deleteQueue policy (""self-destruct"").  

There is no option available to allow the creation of self-destruct queues as ACL only recognizes the following Queue policy types: ring, ring_strict, flow_to_disk, reject.

Additionally, if the ACL rules specify to deny the creation of a ""reject"" queue, then a deleteQueue is also denied."
Bug,QPID-5041,12661959,adding annotations to durable messages causes persistence id to be lost,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"If an annotation is added to a message (e.g. queue sequence number) *after* the message has been persisted, the persistence id set by the store is lost meaning subsequent dequeue attempts will fail."
Bug,QPID-5149,12669638,[AMQP 1.0] translation from 1.0 to 0-10 should truncate routing key if necessary,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"As the routing key is a str8, this places a limit on its length that should be respected when translating from 1.0 format."
Bug,QPID-4948,12654736,[AMQP 1.0] browsing queues not supported,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,Requires means to set and read the distribution-mode of the receiver link in proton engine.
Bug,QPID-5011,12659196,C++ Broker ACL allows one connection when user quota is zero,chug,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"If an ACL file has a rule like
{noformat}
quota connections 0 user@QPID
{noformat}
then the user is still allowed one connection.

This feature was tested in a self test but the self test did not detect that the feature was broken. See QPID-5010."
Bug,QPID-5315,12678245,paging out of memory loses persistence id for messages,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Meaning that attempt to dequeue fails with 'Dequeuing message with null persistence Id.' error.
Bug,QPID-5299,12677799,[AMQP 1.0] ACL rules should be checked before checking node's existence and returning amqp:not-found error,gsim,scholzj,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"When a client is connecting with AMQP 1.0 to the C++ broker and the node from which it wants to consume messages doesn't exist, the broker throws an amqp:not-found error even when ACL rules deny the user to access or publish from the given node (queue).

This problem might to some extent exist also with AMQP 0.10. But the Qpid AMQP 0.10 clients always query the existence of a queue/exchange before connecting to it and the QueueQuery / QueueDeclare calls are ACL protected, so the Qpid based AMQP 0.10 client always receives the ACL error before the not-found error. But I guess if you skip the QueueQuery / QueueDeclare and go directly to MessageSubscribe the same problem as with AMQP 1.0 might exist in AMQP 0.10 as well.

For a security reasons, I would assume that the ACL check for access or publish rules should be done before revealing that the queue doesn't exist. The broker should not reveal any details about its configuration if the ACL rights don't allow it."
Bug,QPID-5156,12670147,[AMQP 1.0] assert should check node properties,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"Especially important for dynamic nodes, but would be nice to support existing assert behaviour also. "
Bug,QPID-5102,12665991,C++ Broker windows build needs many xxx_EXTERNs when PROTON is included,chug,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,AMQP 1.0 usage invokes new library linkage patterns that require explicit export callouts.
Bug,QPID-5170,12670305,[AMQP 1.0] outgoing deliveries that are settled without an explicit disposition are not dequeued,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,E.g. when consuming messages with recv example from proton (see https://issues.apache.org/jira/browse/PROTON-425)
Bug,QPID-5131,12668076,[AMQP 1.0] xml exchange can't see 1.0 content,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Meaning any xquery that checks the body will fail for 1.0 messages.
Bug,QPID-5280,12676848,exclusivity of queue not enforced for bind/unbind,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"An exclusive queue can be bound or unbound by any other session. The property is really that defined by the 0-10 spec which says that an exclusive queue can not be 'used'  by anyone else. There is no precise definition of what 'use' means here (we deliberately allowed browsing some time back), but binding and unbinding certainly seems to count as using since it affects the stream of messages an exclusive consumer may see."
Bug,QPID-5152,12669712,[AMQP 1.0] exchange arguments aren't set when created on attach,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"If creating an exchange on-demand when establishing a link to/from it, any extra properties are not applied (e.g. qpid.IVE)."
Bug,QPID-4582,12632295,C++ Broker legacystore self tests fail,astitcher,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"As standalone unit test executables the legacystore self tests pass. However, they fail in the 'make test' setup.

qpid/b64-cmake> /usr/bin/ctest -R legacystore_SimpleTest
Test project /home/svn/qpid/b64-cmake
    Start 17: legacystore_SimpleTest
1/1 Test #17: legacystore_SimpleTest ...........***Not Run   0.00 sec

0% tests passed, 1 tests failed out of 1

Total Test time (real) =   0.23 sec

The following tests FAILED:
         17 - legacystore_SimpleTest (BAD_COMMAND)
Errors while running CTest



"
Bug,QPID-5227,12673697,redelivered flag not always set correctly,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"The broker tracks delivery count as per 1.0 specification. Mapping this to isRedelivered, the broker is simply testing the count is non-zero. However as the count is initialised to -1, this leads to the message incorrectly being marked as redelivered if it is first browsed. (Further, the first consume attempt then increments the delivery count so it appears the redlivery flag is flipped back to false)."
Bug,QPID-5341,12679261,Allow use of proton 0.6,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,which is now in rc1 and assuming no significant changes should work fine when released
Bug,QPID-5292,12677424,"connection event not raised, authIdentity not set in mgmt props",gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Caused by http://svn.apache.org/viewvc?view=revision&revision=1424125
Bug,QPID-5289,12677384,[AMQP 1.0] error descriptions are not given in exceptions by client,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"E.g. if attempting to transfer to a queue that would exceed max depth, the exception thrown is a connection-exception and simply says 'Connection closed by peer'.

There are two parts to this, one is that this should not be a connection exception but a link exception in 1.0. The second is that the error text sent by the broker should be included in the exception."
Bug,QPID-5124,12667751,durable LVQ raises journal error when only transient messages are sent,pmoravec,pmoravec,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Description of problem:
Sending+consuming transient messages to/from a durable LVQ queue raises ""Dequeuing message with null persistence Id"" journal error on producer.


Version-Release number of selected component (if applicable):
0.24


How reproducible:
100%


Steps to Reproduce:
1. In the first terminal:
qpid-receive -a ""myLVQ; {create:always, node:{ durable:true, x-declare: { arguments:{'qpid.flow_stop_count':0, 'qpid.max_count':0, 'qpid.last_value_queue':True, 'qpid.last_value_queue_key':'qpid.LVQ_key', 'qpid.file_count':64, 'qpid.policy_type':'reject', 'qpid.file_size':16, 'qpid.flow_resume_count':0, 'qpid.flow_stop_size':0, 'qpid.max_size':104857600, 'qpid.flow_resume_size':0}}}}"" -f -m 100000 --print-content=no

2. In the second terminal:
qpid-send -a ""myLVQ"" -m 1000000 --group-key=qpid.LVQ_key --group-size=10 --content-size=100


Actual results:
qpid-send is disconnected by the broker with error:
2013-09-09 21:24:59 [Client] warning Broker closed connection: 501, Queue ""myLVQ"": Dequeuing message with null persistence Id. (/root/rpmbuild/BUILD/qpid-0.22/cpp/src/qpid/legacystore/MessageStoreImpl.cpp:1370)


Expected results:
No such error.


Additional info:
- everytime, the queue has these stats after the error:
acquires:3, bindingCount:1, bindingCountHigh:1, bindingCountLow:1, byteDepth:100, byteFtdDepth:0, byteFtdDequeues:0, byteFtdEnqueues:0, bytePersistDequeues:0, bytePersistEnqueues:0, byteTotalDequeues:100, byteTotalEnqueues:200, byteTxnDequeues:0, byteTxnEnqueues:0, consumerCount:0, consumerCountHigh:0, consumerCountLow:0, discardsLvq:1, discardsOverflow:0, discardsPurge:0, discardsRing:0, discardsSubscriber:0, discardsTtl:0, flowStopped:False, flowStoppedCount:0, messageLatencyAvg:0, messageLatencyCount:0, messageLatencyMax:0, messageLatencyMin:0, msgDepth:1, msgFtdDepth:0, msgFtdDequeues:0, msgFtdEnqueues:0, msgPersistDequeues:0, msgPersistEnqueues:0, msgTotalDequeues:1, msgTotalEnqueues:2, msgTxnDequeues:0, msgTxnEnqueues:0, redirectPeer:, redirectSource:False, releases:1, reroutes:0, unackedMessages:0, unackedMessagesHigh:0, unackedMessagesLow:0

I.e. one msg discarded due to LVQ, 2 enqueues, 1 dequeue (the discard), BUT 3 acquires???
"
Bug,QPID-5276,12676599,[AMQP 1.0] node resolution doesn't take into account requested type,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"E.g. if there is both a queue and exchange of the same name, any explicit node type in the address is ignored. Or if the node type is specified in conjunction wit create and a node of a different type already exists, that existing type will be used.

The node type is conveyed through a (currently) qpidd specific capability. It is not required, but if specified should be honoured."
Bug,QPID-5110,12666705,[AMQP 1.0] make handling of incorrectly typed properties more robust,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"If a property is sent in the wrong type (e.g. as long instead of ulong), subsequent properties get handled incorrectly. Would be nicer to simply skip (or even by lenient and accept) the incorrect types, but handle all others correctly."
Bug,QPID-5151,12669702,[AMQP 1.0] messages sent to exchange over 1.0 are not rerouted to alternate exchange,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Messages sent to exchange over 1.0 are not rerouted to alternate exchange in the event that there are no matching bindings.
Bug,QPID-5077,12663911,[AMQP 1.0] SASL layer for interlinks assumes synchronous interaction,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"There is a bug in the SASL client logic in qpidd such that if it gets a successful SASL-OUTCOME before it has sent SASL-INIT, then it immediately moves on to the AMQP header rather than sending the necessary SASL-INIT anyway.

This means that connecting to e.g. dispatch-router or the recv example with proton messenger doesn't work."
Bug,QPID-5251,12675036,[AMQP 1.0] allow create-on-demand through broker configuration,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Though often it is better to have explicit configuration with errors raised when attempting to send to or receive from non-existent nodes, there are occasions when creating those nodes on demand would be preferable.

The aim here is to add a mechanism to qpidd that will allow policies to be created that define which parts of the node 'namespace' get created on demand and what properties to apply to them."
Bug,QPID-5101,12665924,C++ Broker windows build is missing SaslFactory::createServer,chug,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Function was added to unix builds on 2012-10-19 but never added to windows platform.
Bug,QPID-5200,12671553,Can't disable size limit on individual queue,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,Setting a qpid.max_size of 0 has no effect; the default queue limit still applies.
Bug,QPID-5300,12677800,[AMQP 1.0] Some ACL errors are returned as internal error instead of unauthorized error,gsim,scholzj,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"It seems when some ACL errors occur, the C++ broker is sometimes using the AMQP 1.0 error code unauthorized-access and sometimes internal-error. For example the ""ACL denied queue access"" error is amqp:unauthorized-access:

{{[0x24ca9d0:0] <- @detach [handle=0, closed=true, error=@error {condition=:""amqp:unauthorized-access"", description=""ACL denied queue access request from ABCFR_ABCFRALMMACC1@QPID0000 (/home/jakub/qpid/qpid-trunk/cpp/src/qpid/broker/amqp/Authorise.cpp:72)""]]}}

But ""ACL denied queue create access"" is amqp:internal-error:

{{[0x1d14b10:0] <- @detach [handle=1, closed=true, error=@error [condition=:""amqp:internal-error"", description=""unauthorized-access: ACL denied queue create request from ABCFR_ABCFRALMMACC1@QPID0000 (/home/jakub/qpid/qpid-trunk/cpp/src/qpid/broker/Broker.cpp:1295)""]]}}

I would expect that all ACL errors should be returned as amqp:unauthorized-access."
Bug,QPID-5083,12664355,[AMQP 1.0] if sasl implementation is not available client (and interlinking) will fail,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,E.g. if on fedora you build without cyrus-sasl-devel.
Bug,QPID-5330,12678565,Queue flow limit tests try to invoke a missing qpid-python-test,astitcher,jross,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"This is from testing a release tarball.  I believe this test should avoid running if it can't find qpid-python-test.

25/54 Testing: queue_flow_limit_tests
25/54 Test: queue_flow_limit_tests
Command: ""/tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/src/tests/run_test"" ""--build-dir=/tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/build"" ""--start-broker"" ""--broker-options=--default-flow-stop-threshold=80 --default-flow-resume-thre\
shold=70 -t --log-to-stderr=no --log-to-stdout=no"" ""/tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/src/tests/run_queue_flow_limit_tests""
Directory: /tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/build/src/tests
""queue_flow_limit_tests"" start time: Nov 09 19:51 EST
Output:
----------------------------------------------------------
/tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/src/tests/run_queue_flow_limit_tests: line 24: /tmp/tmp.qNIAEwMgJv/qpid-cpp-0.26/build/src/tests/python/commands/qpid-python-test: No such file or directory
<end of output>
Test time =   3.96 sec
----------------------------------------------------------
Test Failed.
""queue_flow_limit_tests"" end time: Nov 09 19:51 EST
""queue_flow_limit_tests"" time elapsed: 00:00:03
----------------------------------------------------------
"
Bug,QPID-5016,12659857,Legacy store not correctly initialising rmgr,astitcher,astitcher,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Gcc 4.8.1 found an incorrect memset in legacystore/jrnl/rmgr.cpp, where the an aio_cb struct is zeroed using a sizeof aio_cb* rather than aio_cb."
Bug,QPID-5126,12667887,Unable to compile legacy store on ARM platforms,mcpierce,mcpierce,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"The code does not properly accomodate ARM platforms and fails to compile with:

#error endian?"
Bug,QPID-5228,12673719,[AMQP 1.0] can't set alternate-exchange for subscription queue,gsim,gsim,Closed,Fixed,2014-02-19 11:29,C++,C++ Broker,,,,,,,The intended mechanism for controlling the configuration of subscription queues is through the newly introduced 'topic' entities. These allow various subscription queue properties and an exchange to be tied together . However the properties that can be configured are limited to those passed in the 0-10 arguments. It does not include alternate-exchange.
Bug,QPID-5121,12667557,Store module does not raise exception when attempting to enqueue a message bigger than the journal size,pmoravec,pmoravec,Closed,Fixed,2014-02-02 14:05,C++,C++ Broker,,,,,,,"Description of problem:
Whenever store module tries to write to a journal a message bigger than the journal capacity is, it a) does not store the message (so far so good), but b) it does _not_ raise an error (!!!). So the broker thinks the message was enqueued.

That is a big gotcha, as the durable message is kept in memory only.


Version-Release number of selected component (if applicable):
0.22


How reproducible:
100%


Steps to Reproduce:
rm -rf /var/lib/qpidd/* /var/lib/qpidd/.* 2> /dev/null
service qpidd restart

# create a durable queue with tiny journal and send there one huge message
qpid-send -a ""DurableQueue4; {create:always, node:{durable:true, x-declare:{ arguments:{'qpid.flow_stop_count':0, 'qpid.max_count':0, 'qpid.file_count':4, 'qpid.file_size':8, 'qpid.flow_resume_count':0, 'qpid.flow_stop_size':0, 'qpid.flow_resume_size':0, 'qpid.max_size':0 }}}}"" -m 1 --content-size=100000000 --durable=yes

# check in stats the queue has the message enqueued
qpid-stat -q 
Queues
  queue                                     dur  autoDel  excl  msg   msgIn  msgOut  bytes  bytesIn  bytesOut  cons  bind
  =========================================================================================================================
  7e553cc6-89d4-46b2-93fd-5ad7cf1f72a9:0.0       Y        Y        0     0      0       0      0        0         1     2
  DurableQueue4                             Y                      1     1      0     100m   100m       0         0     1

# restart the broker and check queue stats
service qpidd restart
qpid-stat -q 
Queues
  queue                                     dur  autoDel  excl  msg   msgIn  msgOut  bytes  bytesIn  bytesOut  cons  bind
  =========================================================================================================================
  DurableQueue4                             Y                      0     0      0       0      0        0         0     1
  cddddd53-5b98-4101-ad35-de71e038cd61:0.0       Y        Y        0     0      0       0      0        0         1     2

# ouch, where the _durable_ message went to???


Actual results:
1) generic reproducer for regular durable queue:
- qpid-send/broker/store has not returned an error (THIS is the wrong)
- after the broker restart, the queue has no message (this should be ok but not after no error raised)


Expected results:
qpid-send should fail due to ""Enqueue capacity threshold"" error (and no message should be kept in the broker later on).


Additional info:
- Optional/variant scenarios: send first some tiny message to the journal and then the huge one.
- Trivial patch to be added

"
Bug,QPID-3502,12524389,Durable messages not acked on queue-based federation route,gsim,gsim,Closed,Fixed,2013-11-06 22:03,C++,C++ Broker,,,,,,,"- On both the source and destination broker I run:
    qpid-config add exchange topic mytopic --durable
    qpid-config add queue myq --durable
    qpid-config bind mytopic myq 'topica.*'
- On the destination broker I run:
    qpid-route -d -s --ack 1 queue add <dest-broker> <source-broker> mytopic myq
- On the source broker machine I edit the spout script to make
messages durable and run:
    spout mytopic/topica.hello
- On the destination broker I run:
    drain myq

Using qpid-stat -q monitor the dequeue of messages. Durable messages are not dequeued, when a transient message is sent all previous messages will be dequeued."
Bug,QPID-5072,12663651,"[C++ broker] SessionManager does not forget sessions when broker drops connection after journal error, leading to memory leak",pmoravec,pmoravec,Closed,Fixed,2013-10-04 13:12,C++,C++ Broker,,,,,,,"Description of problem:
Broker rejects session re-subscription (on a new AMQP+TCP connection) after the previous was dropped due to a journal error. This bug in broker:
- is in fact a memory leak, as session manager map is not cleared when requested
- it affects Java client during failover, when original journal problem has been already resolved, but the client can't even attach the same session.


Version-Release number of selected component (if applicable):
any (teste 0.18 and also 0.22 broker)


How reproducible:
100%


Steps to Reproduce:
1) run attached Java reproducer on a fresh broker:
java test_00903524_threaded 1

2) check qpidd logs for errors


Actual results:
2013-08-02 11:39:04 [Protocol] error Unexpected exception: Enqueue capacity threshold exceeded on queue ""testQueue"". (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/legacystore/JournalImpl.cpp:594)
2013-08-02 11:39:04 [Protocol] error Connection qpid.10.34.1.141:5672-10.34.1.141:42635 closed by error: Enqueue capacity threshold exceeded on queue ""testQueue"". (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/legacystore/JournalImpl.cpp:594)(501)
2013-08-02 11:39:14 [Protocol] error Channel exception: session-busy: Session already attached: guest@QPID.36332225-5c5b-4077-b8ec-820555253a89 (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/broker/SessionManager.cpp:55)
2013-08-02 11:39:14 [Protocol] error Channel exception: not-attached: Channel 1 is not attached (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/amqp_0_10/SessionHandler.cpp:39)
..
(few thousands of the latest error)


Expected results:
just the journal error be seen (and multiple times), not the ""Session already attached"" one or ""Channel 1 is not attached"" one.


Additional info:
The broker management _deletes_ the session, as the broker logs:

2013-08-02 11:39:04 [Management] trace Management object marked deleted: org.apache.qpid.broker:session:36332225-5c5b-4077-b8ec-820555253a89
   org.apache.qpid.broker:session:36332225-5c5b-4077-b8ec-820555253a89 (deleted)
2013-08-02 11:39:10 [Management] trace Deleting V1 properties 0-68-1--14(org.apache.qpid.broker:session:36332225-5c5b-4077-b8ec-820555253a89) len=164
2013-08-02 11:39:10 [Management] trace Deleting V1 statistics 0-68-1--14(org.apache.qpid.broker:session:36332225-5c5b-4077-b8ec-820555253a89) len=127
2013-08-02 11:39:10 [Management] trace Deleting V2 map={_create_ts:1375436343054221056, _delete_ts:1375436344249095890, _object_id:{_agent_epoch:68, _object_name:org.apache.qpid.broker:session:36332225-5c5b-4077-b8ec-820555253a89}, _schema_id:{_class_name:session, _hash:1aaa08d0-c118-ff78-0956-47b9ac9c6849, _package_name:org.apache.qpid.broker, _type:_data}, _update_ts:1375436343054221056, _values:{TxnCommits:0, TxnCount:0, TxnRejects:0, TxnStarts:0, attached:True, channelId:0, clientCredit:0, connectionRef:{_agent_epoch:68, _object_name:org.apache.qpid.broker:connection:qpid.10.34.1.141:5672-10.34.1.141:42635}, detachedLifespan:0, name:36332225-5c5b-4077-b8ec-820555253a89, unackedMessages:0, vhostRef:{_object_name:org.apache.qpid.broker:vhost:org.apache.qpid.broker:broker:amqp-broker,/}}}

But session manager inside does not forget the sessions/channels..


Reproduction for memory leak:
run attached script

Weird is, even fixing the bug for Java client, some steady memory increase is still present.."
Bug,QPID-4949,12654799,C++ broker may crash on shutdown,kgiusti,kgiusti,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The C++ broker may crash during shutdown.  The resulting core file shows an attempt to send a QMF event message during the Broker class destructor.

"
Bug,QPID-5054,12662579,[C++ broker] Deleting topic which doesn't exist crashes the broker,gsim,scholzj,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"When the user attempts to delete a non-existent topic using the qpidt utility:
{{/usr/local/libexec/qpid/tests/qpidt -b admin/admin@localhost:20000 delete topic i-do-not-exist}}
it seems to result in broker crash. The trace log from the broker is attached."
Bug,QPID-4893,12650177,[AMQP 1.0] relay sends out buffered message before it is ready,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,Manifests itself as intermittent failure of the relay test in interlink tests.
Bug,QPID-4957,12655108,[AMQP 1.0] link bindings are not removed after the link is closed,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Steps to Reproduce:
{noformat}
1. drain --connection-options ""{protocol:'amqp1.0'}"" amq.direct/a
2. qpid-config exchanges -r | grep -A1 amq.direct
(a binding to ""<unknown>"" queue is listed)
3. spout --connection-options ""{protocol:'amqp1.0'}"" amq.direct/a
4. use 'qpid-stat -e' to realize that the message was routed to the non-existing queue instead of being dropped
{noformat}"
Bug,QPID-4792,12645458,Windows UUID processing mingles GUID values,cliffjansen,cliffjansen,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"RFC 4122 defines a UUID.  A GUID is the same as a UUID in string form, but differs in binary layout.  Microsoft operates with GUIDs but confusingly labels them as UUIDs in their documentation and include files.

i.e. rpcdce.h:  typedef GUID UUID;

The binary form matters since it is used over the wire.  Mapping a GUID to a UUID (or vice versa) without the layout conversion results in structures with mangled RFC version info and different string representations on Windows and non-Windows systems.

Proton currently only calls Microsoft APIs to obtain the string representation of the UUID (which will match the GUID), so it is unaffected.
"
Bug,QPID-4735,12641902,C++ Broker ACL file size/count limit check bug when no value declared by user,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The error in the ACL code shows up when:
1. An ACL rule specifies an 'upper limit' rule such as filemaxsizeupperlimit
2. The queue_declare call from the user does not specify qpid.file_size in the queue declaration.

The broker passes a file_size lookup value of 0 to the ACL for checking.

The ACL code (in error) sees that the lookup value is 0 and declares the comparison a failure despite the fact that the value (0) is less than the rule's upper limit.

The fix is not to check that a lookup value is zero but just go ahead with the comparison.

The failure is easy to trigger in the self test."
Bug,QPID-4971,12655642,C++ Broker queue settings have uninitialized variables,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"File size limits for ACL are unitialized. The problem appears during ACL lookups:

2013-06-17 17:42:00 [Security] debug ACL: 
  Lookup for id:usera@QPID 
    action:create 
    objectType:queue name:testq with params { 
      durable=false 
      autodelete=false 
      exclusive=false 
      alternate= 
      policytype=reject 
      maxqueuesize=0 
      maxqueuecount=0 
      maxfilesize=48794453446331572 
      maxfilecount=13119085654258853640 }
"
Bug,QPID-4986,12657240,[AMQP 1.0] correlation-id/message-id gets corrupted by broker,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"E.g. qpid-receive --connection-properties {protocol:amqp1.0} -f --address amq.fanout --print-headers true

then

qpid-send --connection-options {protocol:amqp1.0} --address amq.fanout --correlation-id abc

The receiver prints:

CorrelationId: 1"
Bug,QPID-4021,12558133,Badly behaved clients can still clog up the broker,,astitcher,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The recent code that timeouts out new connections that have not negotiated the protocol within (a default) 2 seconds still leaves a gap where badly behaved applications can tie up the broker.

The timeout should really be till either heartbeats are activated in which case they will take over the role of timing out idle connections. Or until the connection is authenticated in which case the policy on admitting users should take care of limiting the connections."
Bug,QPID-4727,12641380,C++ Broker ACL rules provide no way to match default exchange,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"ACL rules use 'name=value' formatting. In the case of ACL rule PUBLISH EXCHANGE the exchange name must be specified with a name= setting. However, in the case of the default exchange the exchange name is blank. There is no way to specify a blank exchange name and there is no acceptable workaround.

The proposal is to add keyword *amq.default* to the ACL syntax so that when a PUBLISH EXCHANGE rule exchange name is specified with this keyword then the run-time rule will actually match a blank exchange name.
{noformat}
 acl allow bob publish exchange name=amq.default routingkey=bobPrivate
 acl deny  all publish exchange name=amq.default routingkey=bobPrivate
{noformat}

Impact assessment:
||Design consideration||Proposed feature||
|Threading model|n/a|
|Memory management|n/a|
|Automated testing approach|easy to test|
|Impact on public API|Adds new keyword to ACL file syntax|
|- Interoperability with implementations in other languages|n/a|
|- Backwards compatibility|No. Old code will try to match literal 'amq.default' text|
|Performance implications|Per-message publish exchange lookup tests a bool in the rule before checking that the name in the lookup is blank|
|Security implications|New method already protected by ACL|
|Platform support|n/a|
|Logging|no change|
|Monitoring|no change|
|Management|no change|
"
Bug,QPID-4734,12641886,Release builds fail on GCC 4.4.7 / Boost 1.41,astitcher,astitcher,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"build fails with warnings turned to errors when compiling SocketTransport.cpp:

These are potentially uninitialised variable warnings in boost::bind and boost::function templates and so the underlying code can't be changed by us.

It appears that the cause here is either (or some combination):
* The compiler's flow analysis is incorrect.
* The compiler misinterprets the warning as being in the location that the template instantiation happened (our code) and so ignores the -Wno-system-headers flag which should stop it reporting warnings in the system headers.
* There is an issue in the boost code.

In any of these cases there is little that we can do except suppress the warning."
Bug,QPID-4888,12649349,[AMQP 1.0] link naming is not handled correctly,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"The client does not let the name of the link be controlled, but always defaults it to the name of the node (which doesn't meet uniqueness criteria).

The broker uses the link-, source- and target- names as the key to the managment objects and uses the link- and source- name for subscriptions queues when the source refers to an exchange. The link name is only guaranteed to be unique within the scope of a clients container id."
Bug,QPID-4854,12647959,max-negotiate-time feature breaks AMQP 1.0 (and arguably doesn't achieve the desired objective anyway),astitcher,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"It has assumptions based on 0-10 (and a particular pattern for 0-10 at that) built into the underlying transport code (which should be protocol agnostic).

As AMQP 1.0 makes it much simpler and more likely for less synchronous handshaking, the '3 reads' magic doesn't work and causes 1.0 connections to be terminated incorrectly. Either the original solution needs to be reimplemented or it needs to be possible to disable it for use with 1.0.

See QPID-4021 and QPID-2518."
Bug,QPID-4720,12641115,C++ Broker Headers exchange match comparison self tests use stale comparison code,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Steps to Reproduce:
1. Use the old Python client API and do this:

session.exchange_bind(exchange=""MyHeadersExchange"", queue=""MyQueue"", arguments={""x-match"":""all"", ""MyHeader"":1})

2. Use the new C++ messaging API to send a message like this:

Message msg(;
msg.getProperties()[""MyHeader""] = boost::uint16_t(1);

3. Use qpid-stat to see if the exchange routed the message to the queue, or if it was dropped.  In this case, it will be incorrectly dropped.
  
Actual results: Message is dropped

Expected results: Message is delivered into queue MyQueue


Additional info: It looks like the binding generated via Python is a match on the value 1L.  If we create a C++ client to set up the binding, it creates a match based on 1.  It looks like the headers exchange thinks that 1 (2-bytes) isn't the same as 1L (4-bytes).
----------

Headers exchange looks at the value type and sees that they are different and so does not compare the value data.

I'm comfortable saying that the comparison is based on the header entry's type and data value. If the types don't match then the comparison fails. This is how the code works now.

To match ""comparable"" data types then the match must cover [int uint]_[8 16 32 64], and possibly float and double. Even a string data type could be matched ""1"", ""0x1"", and so on. This could be an awful lot of development effort and testing.

What is the correct behavior?
"
Bug,QPID-4880,12649100,[AMQP 1.0] allow temp queues to be qualified by brokers domain,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"i.e. when creating a temp queue, which with 1,0 has a broker assigned name, have the broker qualify the local name with its configured domain to assist in routing in a federation."
Bug,QPID-4969,12655423,C++ Broker headers exchange allows creation of bindings with duplicate keys,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The test case:
{code}
qpid-config add queue MyQueue --durable
qpid-config bind amq.match MyQueue SomeKey any property1=value1
qpid-config bind amq.match MyQueue SomeKey all property1=value1
{code}
Causes a management error as two bindings are created with amq.match,MyQueue,SomeKey managementId."
Bug,QPID-4819,12646596,[AMQP 1.0] auto-deleted queues for outgoing links from an exchange are not in fact autodeleted,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,Caused by fix for QPID-4718; won't be visible in released version.
Bug,QPID-4757,12643641, Report failure to open qpidd.sasldb,chug,eallen,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"When the sasldb is not accessible (file permissions or not found) the error code returned from the library call is SASL_NOUSER. However, that is the same code returned when the user name supplied was not in the sasldb.

The log message should reflect this possibility."
Bug,QPID-4923,12652732,Windows C++ broker ignores --ssl-port option and always uses --port for ssl,astitcher,astitcher,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The cause is a simple mistake in qpid/broker/windows/SslProtocolFactory.cpp where the wrong port option is passed down to create the listening socket.

I'm not sure how far back this bug goes - at least as far as 0.22"
Bug,QPID-4810,12645863,If ssl/tcp multiplexing is enabled and ssl initialisation fails tcp doesn't start either,astitcher,astitcher,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"To reproduce:
qpidd --ssl-cert-db non-existent_file --ssl-port 5672

This will try to start ssl, fail and then not start tcp either.

In versions prior to 0.23 it will also just sit there dumbly waiting, doing nothing, not exiting (this issue was fixed in trunk r1478398)."
Bug,QPID-4917,12652381,[AMQP 1.0] allow for shared topic subscriptions,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,One of the things that could be done over 0-10 that is generally useful.
Bug,QPID-4702,12640762,cmake build of ssl support does not work on certain platforms,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,This is a result of the order of libraries and object files passed to the linker. The libraries must follow the .o files that require them or they will be ignored (assumed not needed).
Bug,QPID-5053,12662575,[C++ broker] Exclusive autodelete queues created with AMQP 1.0 don't seem to be autodeleted,gsim,scholzj,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"I'm using a qpid.messaging client with AMQP 1.0 to create a temporary / auto-delete queue on the broker. This queue should get deleted after the connection is closed. However, it seems that if the queue is exclusive, it is never autodeleted. To create the queue, I'm using following address:

myresponse_queue_1;
{
         create: always,
         assert: never,
         node:
         {
                 durable: false,
                 properties: {
                         auto-delete: true,
                         exclusive: true,
                         'qpid.max_count': 1000,
                         'qpid.max_size': 1000000,
                         'qpid.policy_type': ring
                 }
         }
}

According to qpid-tool, the auto-delete option is properly recognized:

Object of type: org.apache.qpid.broker:queue:_data(aee19387-3611-855a-c8ff-d2f106e5b5f4)
    Attribute            160
    ===========================================================================================================
    vhostRef             170
    name                 response.ABCFR_ABCFRALMMACC1.response_queue_1
    durable              False
    autoDelete           True
    exclusive            True
    arguments            {u'qpid.max_size': '1000000', u'qpid.max_count': '999', u'qpid.policy_type': 'ring'}
    msgTotalEnqueues     0
    msgTotalDequeues     0
    msgTxnEnqueues       0
    msgTxnDequeues       0
    msgPersistEnqueues   0
    msgPersistDequeues   0
    msgDepth             0
    byteDepth            0
    byteTotalEnqueues    0
    byteTotalDequeues    0
    byteTxnEnqueues      0
    byteTxnDequeues      0
    bytePersistEnqueues  0
    bytePersistDequeues  0
    msgFtdEnqueues       0
    msgFtdDequeues       0
    byteFtdEnqueues      0
    byteFtdDequeues      0
    msgFtdDepth          0
    byteFtdDepth         0
    releases             0
    acquires             0
    discardsTtl          0
    discardsRing         0
    discardsLvq          0
    discardsOverflow     0
    discardsSubscriber   0
    discardsPurge        0
    reroutes             0
    consumerCount        1
    consumerCountHigh    1
    consumerCountLow     1
    bindingCount         1
    bindingCountHigh     1
    bindingCountLow      1
    unackedMessages      0
    unackedMessagesHigh  0
    unackedMessagesLow   0
    messageLatencyMin    0s
    messageLatencyMax    0s
    flowStopped          False
    flowStoppedCount     0
    redirectPeer         
    redirectSource       False

But the queue is never deleted. With qpid.messaging and AMQP 0.10, or with qpid.messaging, AMQP 1.0 and non-exclusive queue, the auto deletion seems to work fine.

Please let me know if you need some additional logs or information."
Bug,QPID-4339,12608651,flow to disk replacement,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,QPID-4178 removed the flow-to-disk 'feature' from the broker. It should be replaced by a more effective solution.
Bug,QPID-3772,12539019,"Qpid broker on Windows allows multiple, simultaneous processes to listen to broker port",astitcher,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Socket code on windows allows multiple, simultaneous listening processes on broker port. 
  C:\Windows\system32>netstat -anb

  TCP    0.0.0.0:5672           0.0.0.0:0              LISTENING
 [qpidd2.exe]
  TCP    0.0.0.0:5672           0.0.0.0:0              LISTENING
 [qpidd.exe]

This is a security issue as it allows a rogue process to hijack connections directed to the broker.

A simple first step is in Socket.cpp to change SO_REUSEADDR to SO_EXCLUSIVEADDRUSE as described in
http://msdn.microsoft.com/en-us/library/windows/desktop/cc150667%28v=vs.85%29.aspx
"
Bug,QPID-5078,12664103,consumers not notified of messages if another consumer with selector/filter doesn't want it,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"E.g. run

{noformat}
  drain ""q; {create:always, link:{selector:\""colour = 'red'\""}}"" -f
{noformat}

and in another terminal:

{noformat}
  drain ""q; {create:always, link:{selector:\""colour = 'blue'\""}}"" -f
{noformat}

then:

{noformat}
  for i in `seq 1 5`; do spout --content ""red-$i"" -P colour=red q; done
  for i in `seq 1 5`; do spout --content ""blue-$i"" -P colour=blue q; done
  for i in `seq 6 10`; do spout --content ""red-$i"" -P colour=red q; done
{noformat}
Expect first drain to see all 10 'red' messages, second drain to see all 5 'blue' messages but in practice this doesn't (always) happen. The message are on the queue but the consumers are not always notified of their existence."
Bug,QPID-4976,12656034,[AMQP 1.0] support standard lifetime policies,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"I.e. delete-on-close, delete-on-no-links, delete-on-no-messages and delete-on-no-links-or-messages"
Bug,QPID-5061,12662642,[C++ broker] The qpidd broker crashes when two links are created with the same name,gsim,scholzj,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"I have a C++ client based on the qpid.messaging / AMQP 1.0. This client has a container-id specified in the connection options. This client creates a receiver with following address:

z/response.ABCFR_ABCFRALMMACC1.response_queue_1; { create: never, link: { name: 'response.ABCFR_ABCFRALMMACC1.response_queue_1', durable: false } }

where z is a name of a topic. The client alone seems to be working fine. It creates the receiver and waits for a message. 

However, when I start second instance of the same program, it results in a broker crash. I assume it might be related to the fact that it uses the same container-id and link name.

A trace log from the broker is attached."
Bug,QPID-4712,12640999,[AMQP 1.0] ACL support,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Though e.g. creation of queues and exchanges is governed by ACL rules, creation of connections is not and this should be rectified."
Bug,QPID-1353,12406388,xa.FaultTest.testRollback failure with CPP profile,rhs,ritchiem,Closed,Fixed,2013-08-21 10:58,C++,C++ Broker,Java Tests,JMS AMQP 0-x,,,,,"Summary:
Picked up on an build system:
Testcase: testRollback took 0.246 sec
	Caused an ERROR
Error closing connection: org.apache.qpid.AMQException: 
javax.jms.JMSException: Error closing connection: org.apache.qpid.AMQException: 
	at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:936)
	at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:887)
	at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:874)
	at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:867)
	at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:862)
	at org.apache.qpid.test.unit.xa.FaultTest.tearDown(FaultTest.java:99)
	at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220)

Full log attached in JIRA"
Bug,QPID-3188,12503446,CyrusSasl ctor logic change for callback storage,mgoulish2,mgoulish2,Closed,Fixed,2013-08-20 20:41,C++,C++ Broker,C++ Client,,,,,,"The logic that stores callbacks in the CyrusSasl ctor should be changed to make the c++ client behave similarly to other language clients.

If there is no username, then do nothing with either NAME or PASSWD callbacks.
If there is a name but no passwd, then explicitly store an empty PASSWD callback."
Bug,QPID-3239,12505963,sasl_fed_ex tests hangs,mgoulish2,mgoulish2,Closed,Fixed,2013-08-20 20:40,C++,C++ Broker,,,,,,,"the sasl_fed_ex test ( which is the base code for severl tests ) is hanging, because qpid-tool can no longer print the status of links between clustered brokers."
Bug,QPID-3288,12508961,"[C++] Broker sets federation link tag as empty string ("""") when no tag is present in the client/server properties",kpvdr,kpvdr,Closed,Fixed,2013-08-20 20:40,C++,C++ Broker,,,,,,,"When handling the start() and startOk() methods in ConnectionHandler::Handler, the broker fails to check the client/server properties FieldTable for the presence of the federation tag correctly. Rather, it simply gets the tag as a string, and this in turn returns an empty string when it is not present. Not only this, but no check is made for the presence of the federation flag (which is also not present in such cases) prior to setting this string."
Bug,QPID-3620,12531589,time conversions fail on solaris,cliffjansen,cliffjansen,Closed,Fixed,2013-08-20 20:33,C++,C++ Broker,C++ Client,,,,,,"Condition::wait(Mutex&, const AbsTime& absoluteTime) fails for far future time during cast/truncation from 64 bit int to posix timespec.tv_sec.  The time is actually in the past and the wait times out instantly."
Bug,QPID-3960,12551506,Performance regression in priority queue implementation.,aconway,aconway,Closed,Fixed,2013-08-20 20:32,C++,C++ Broker,,,,,,,"Commit 1307582 introduced a serious regression in the performance of priority queues.

    QPID-3603: Keep acquired messages on queues for all queue types.
    
    Updated priority and lvq queues to keep acquired messages, and supply
    them to browsers if requested. This is necessary so replicating
    subscriptions can back-up these queue types without message loss.
    
To demonstrate the slowdown, run this on the broker before and after the commit:

   qpid-send -a ""test1;{create:always,node:{x-declare:{arguments:{'qpid.priorities':10}}}}"" --priority 5 --content-size 259 -m 25000 --report-total

E.g. on my test I see 24112 m/s before and 4549 after. Note that if you repeatedly run the test the results get progressively worse, so it appears to be related to queue depth."
Bug,QPID-5039,12661905,C++ broker compile issue in VS2012,,chug,Closed,Fixed,2013-08-09 14:54,C++,C++ Broker,,,,,,,"Routine build fails with:

2>S:\Users\boost-1_53\boost/functional/hash/extensions.hpp(269): 
   error C2664: 'boost::hash_value' : cannot convert parameter 1 
   from 'const qpid::types::Uuid' to 'std::type_index'

Originating from:

s:\users\chug\svn\phase10\qpid\cpp\src\qpid\ha\Primary.h(145)

Full error log in attachment"
Bug,QPID-4234,12603727,ConfigurationObservers are not notified of queue deletion,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"See also QPID-4223, raised against the 0.18 branch."
Bug,QPID-2078,12434520,Management method for closing connection does not cleanup sessions,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If a connection is closed using the management method (e.g. via qpid-tool), the
sessions appear not to be freed up and e.g. the names remain locked from further
use.
"
Bug,QPID-2210,12441208,broker coredumps on shutting down when rdma module is loaded,astitcher,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"$ ./src/qpidd --auth no --no-module-dir --load-module ./src/.libs/rdma.so 
2009-11-19 12:32:17 notice SASL disabled: No Authentication Performed
2009-11-19 12:32:17 notice Listening on TCP port 5672
2009-11-19 12:32:17 notice Rdma: Listening on RDMA port 5672
2009-11-19 12:32:17 notice Broker running
2009-11-19 12:32:18 notice Shut down                        <===== Ctrl-C to shutdown broker
Segmentation fault (core dumped)


Core was generated by `/home/gordon/qpid/cpp/src/.libs/lt-qpidd --auth no --no-module-dir --load-modul'.
Program terminated with signal 11, Segmentation fault.
[New process 7935]
[New process 7951]
#0  0x00000035bb07270e in free () from /lib64/libc.so.6
(gdb) bt
#0  0x00000035bb07270e in free () from /lib64/libc.so.6
#1  0x00000035bb0babf0 in freeaddrinfo () from /lib64/libc.so.6
#2  0x00002abd0575b2bf in ~SocketAddress (this=0x3111c88) at qpid/sys/posix/SocketAddress.cpp:58
#3  0x00002abd05d01a86 in ~Listener (this=0x3111b10) at ./qpid/sys/rdma/RdmaIO.h:176
#4  0x00002abd05ae8a61 in ~RdmaIOProtocolFactory (this=0x310ed10) at /usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259
#5  0x00002abd052ff9c2 in std::_Rb_tree<std::string, std::pair<std::string const, boost::shared_ptr<qpid::sys::ProtocolFactory> >, std::_Select1st<std::pair<std::string const, boost::shared_ptr<qpid::sys::ProtocolFactory> > >, std::less<std::string>, std::allocator<std::pair<std::string const, boost::shared_ptr<qpid::sys::ProtocolFactory> > > >::_M_erase (this=0x310acb8, __x=0x31116d0) at /usr/include/boost/detail/sp_counted_base_gcc_x86.hpp:145
#6  0x00002abd052f84a7 in ~Broker (this=0x310ab00) at /usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_tree.h:578
#7  0x00000000004072d9 in QpiddBroker::execute (this=<value optimized out>, options=<value optimized out>) at ./qpid/RefCounted.h:42
#8  0x000000000040578f in main (argc=6, argv=0x7fff622649b8) at qpidd.cpp:80

Last observed on r882182."
Bug,QPID-2229,12442352,"Compile errors in new test program, test_store",shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The cpp/src/tests/test_store.cpp file gets compile errors on Windows due to clashing boost and global namespace types:

------ Build started: Project: test_store, Configuration: Release Win32 ------
Compiling...
test_store.cpp

C:\qpid\trunk\qpid\cpp\src\..\include\qpid/framing/FieldValue.h(140) : error C2872: 'uint8_t' : ambiguous symbol

        could be 'C:\qpid\trunk\qpid\cpp\src\..\include\qpid/sys/windows/IntegerTypes.h(26) : unsigned char uint8_t'
        or       'C:\Program Files\boost\boost-1_40\boost/cstdint.hpp(196) : boost::uint8_t'
        C:\qpid\trunk\qpid\cpp\src\..\include\qpid/framing/FieldValue.h(200) : see reference to class template instantiation 'qpid::framing::FixedWidthValue<width>' being compiled
        with
        [
            width=4
        ]
        C:\qpid\trunk\qpid\cpp\src\..\include\qpid/framing/FieldValue.h(214) : see reference to function template instantiation 'T qpid::framing::FieldValue::getFloatingPointValue<float,4>(void) const' being compiled
        with
        [
            T=float
        ]

C:\qpid\trunk\qpid\cpp\src\..\include\qpid/framing/FieldValue.h(144) : error C2872: 'uint8_t' : ambiguous symbol

        could be 'C:\qpid\trunk\qpid\cpp\src\..\include\qpid/sys/windows/IntegerTypes.h(26) : unsigned char uint8_t'
        or       'C:\Program Files\boost\boost-1_40\boost/cstdint.hpp(196) : boost::uint8_t'

etc... there are similar errors for uint32_t and uint64_t. These usually come from doing something like:

using boost;

"
Bug,QPID-4404,12614054,C++ Broker qpidd hang with --config <directory> command line,chug,chug,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"qpidd --config switch naming a directory causes the startup to hang.

Steps to Reproduce on unix:
1. mkdir /tmp/dir
2. qpidd --config /tmp/dir

This is not an issue on windows."
Bug,QPID-306,12360788,AMQP 0-9 unbind,gsim,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,Implement new Queue::unbind and Exchange::unbind methods from 0-9.
Bug,QPID-4286,12606291,QMF queries for HA replication take too long to process,aconway,dillaman,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"In an HA broker with approximately 12,000 queues, it takes roughly 10-14 seconds for the the first QMF response fragment to arrive.  While the QMF management agent is collecting the response, all other QMF-related functionality is blocked  -- which will block any thread that raises a QMF event.  

Not only will this result in clients getting disconnected from the broker due to worker threads being blocked by QMF (either due to missed heartbeats in an extreme case or from the 2 second handshake timeout), this also results in the HA backup's federated link getting disconnected due to missed heartbeats when the link heartbeat interval is set to a low value.  

If the HA backup loses its connection, it only exacerbates the issue since it will reconnect and re-query the QMF data that made it lose its connection in the first place.  

Recommend that QMF events not be blocked by a global management agent lock and also recommend that potentially long-running QMF queries be separated from the worker thread that initiated them to prevent a heartbeat timeout.
"
Bug,QPID-2278,12443443,Store recovery compatibility problem introduced by alternate-exchange fix,kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"A recent checkin (r.831082) fixed a problem in which the exchange did not persist the alternate-exchange setting, and on recovery this was being lost. To fix it, an additional string was added to the Exchange::encode() and Exchange::decode() methods. However, this fix means that there is a binary incompatibility between pre- and post-fix exchange data. Attempting to recover stores from pre-fix brokers result in broker shutdown if recovery is attempted using post-fix brokers."
Bug,QPID-2488,12461543,ACL - error handling/bounds checking,rajith,rajith,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Qpid ACL properties maxqueuesize, maxqueuecount, policytype, ... currently accepts invalid values.
Only valid ACL rules should be applied, at the moment broker throws an exception at the point when invalid ACL rule is triggered.

How reproducible:
Always

Steps to Reproduce:
#set ACL rules vith invalid values
acl allow tester@QPID all queue maxqueuesize=18446744073709551617
acl allow tester@QPID all queue maxqueuesize=-1
acl allow tester@QPID all queue policytype=invalid_policy_type

Actual results:
ACL rules with invalid rules/values are processed without any error message. 


qpidd.log:
2009-oct-23 07:11:56 debug ACL Processing  1 allow [tester@QPID] * queue
maxqueuesize=18446744073709551617
2009-oct-23 07:11:56 debug ACL: Adding actions
{consume,publish,create,access,bind,unbind,delete,purge,update} to objects
{queue} with props { maxqueuesize=18446744073709551617 } for users
{tester@QPID}
...

Expected results:
ACL rules with invalid property values should not be processed"
Bug,QPID-1108,12397269,QPID broker asserts in qpid::sys::RWlock::RWlock(),,mteira,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Creation of a RWlock asserts in the call:

QPID_POSIX_ASSERT_THROW_IF(pthread_rwlock_init(&rwlock, recursiveRWlockattr));

As discussed in the dev maillist, the problem is reusing the pthread_once_t variable to initialize both the RWlock and Mutex initialization attrs. Furthermore, this machinery is not even needed for RWlock, as default attributes would suffice.

 
"
Bug,QPID-2521,12462568,ACL module core dumps if management is disabled,rajith,rajith,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If you load the acl module while disabling management (using -m no) the broker
core dumps. This is due to the mgtObject not being initialized, hence the
subsequent if statements pass and results in accessing a null management
Object.

How reproducible:
Always

Steps to Reproduce:
Load the acl module with an acl file and set -m no to disable management.

Actual results:
Broker core dumps

Expected results:
Should not core dump.    "
Bug,QPID-2098,12435428,ACL checking for the exchangeBound method is incorrect,rajith,rajith,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The action used for the exchange bound method is CREATE instead of ACCESS.

ACL:  
acl allow tester@QPID access exchange name=foo  

Code:  
session->exchangeBound(""foo"");  

Broker:  
2009-sep-08 09:12:17 info ACL Deny id:tester@QPID action:create
ObjectType:exchange Name:foo
2009-sep-08 09:12:17 error Execution exception: not-allowed: ACL denied exhange
bound request from tester@QPID (qpid/broker/SessionAdapter.cpp:234)

"
Bug,QPID-2454,12459485,[Patch] Messages set with a TTL expire immediately when sent on qpid queues with LVQ ordering,cctrieloff,siddhesh,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Problem Description:

MRG LVQ becomes unstable when msg TTLs are used and a message expires. Sometimes when messages expire, it seems to upset the LVQ mechanism. Eg.  Once a message with key 'X' has expired, any subsequent messages sent  to the LVQ with key 'X' are expired immediately, and never made  available to client applications. Once an LVQ begins exhibiting this  behaviour, This behaviour continues until the broker is restarted. At this point, another side effect is that the msgDepth and byteDepth properties on an LVQ do not always agree, i.e, when msgDepth is zero, byteDepth is not zero.

How Reproducible:

Always:

Steps to Reproduce:

* Create a queue with queue ordering as lvq or lvq-no-browse
* Build and run attached producer for 1 minute
* Stop the producer for a minute to allow messages to expire
* Use qpid-tool to monitor the queue depth and wait for the message to be dequeued (usually takes about 10 minutes)
* Once message has expired, restart the producer
* Watch queue properties with qpid-tool

Actual Results:

The queue depth is always 0, but the byte depth is not. Occasionally, one will get the following error message from the producer:

Unexpected exception: Attempted size underflow on dequeue  

Expected Results:

The queue depth should not be 0 (at least till the time expired messages are purged). Also, when queue depth is 0, byte depth should be 0.

Additional Information:

The root cause seems to be that the lvq object in the Queue that holds mapping from key to messages (Queue::lvq) is not cleared when messages are expired (Queue::purgeExpired), which leads to incorrect accounting when the next message arrives in the queue with the same LVQ key as the message that expired."
Bug,QPID-3337,12513024,eliminate guest/guest default username/password and use an explicit sasl mechanism list,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Currently, we default to using the system-default sasl mechanisms list.  That
list will include GSSAPI if the package is installed on the user's system.  But
merely installing the GSSAPI package does not prepare qpidd to use GSSAPI.  The
user must perform specific config steps to make it work.  And, since GSSAPI
will be selected before other mechanisms, this means that many users will see
qpidd fail as soon as they try  --auth=yes  .

It also seems dangerous to allow PLAIN, since users who install qpidd will then
have an insecure system by default.

By accepting the system-default list we are allowing too many user-surprises.

The solution is to explicitly control the mech list, probably only allowing a
single mechanism such as DIGEST-MD5, and give the user sufficient instruction
on how to set up other mechanisms when they are desired.

NOTE -- I am also allowing  ANONYMOUS, because some python tools do not yet know how to send credentials, and this will allow them to continue working."
Bug,QPID-3932,12549561,HA library links to non-existant broker::SignalHandler::shutdown(),shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"There is a recently started build error on Windows:
HaBroker.obj : error LNK2019: unresolved external symbol ""public: static void __cdecl qpid::broker::SignalHandler::shutdown(void)""

The missing symbol is in qpid/broker/SignalHandler.(h cpp) which appear to not be meant to be used on Windows. So the normal easy fix of adding a QPID_BROKER_EXTERN won't work. There are two issues:

1. The qpid/broker/SignalHandler.cpp file is POSIX-specific since it uses signal handlers. Therefore, it should be in qpid/broker/posix, not qpid/broker

2a. Should HA be building on Windows?

2. The HaBroker module needs some sort of shutdown mechanism for Windows, probably a Windows equivalent of the above SignalHandler.cpp - note that the windows/QpiddBroker.cpp has this type of shutdown in it. Maybe it should be worked into a form useable by HaBroker?

Could the experts in these areas comment please?
"
Bug,QPID-1674,12415374,failover_soak string-out-of-scope error,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Fixes an error caused by a string going out of scope just before ForkedBroker startup.

"
Bug,QPID-633,12380099,C++ broker deadlock on subscribe/flow/sync,gsim,rhs,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"I believe I've encountered a broker deadlock. The client is doing subscribe immediately followed by a flow, and then syncing. The client reports sending MessageSubscribe, MessageFlow, and ExecutionSync. The broker only reports receiving MessageSubscribe and then hangs. I've attached the stack dump from the broker."
Bug,QPID-2482,12461258,Topic Exchange can duplicate messages.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"As per Gordon's description:

If a given queue is bound to a topic exchange with multiple bindings, a message sent to that exchange will result in a copy being enqueued for each binding that matches. This is incorrect - each message should be enqueued once if there is any binding to the queue that matches it.

Steps to Reproduce:
1. create queue
2. bind it to amq.topic with two distinct bindings (e.g. red.* and *.herring)
3. send amq.topic a message whose routing key matches both patterns (e.g. ""red.herring"")
4. check the queue

Actual results:

The message is enqueued on the queue twice.

Expected results:

The message should only be enqueued on the queue once.
"
Bug,QPID-2941,12479836,CLFS store recovery can encounter invalid C++ iterator,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If the CLFS recovery replays a set of operations on a message which results in its removal from the list of valid messages (for example, it is dequeued from all queues) there's an error in handling the C++ iterators working through the recovery operations - in debug mode this results in the C++ runtime throwing an error about mismatched iterators. In Release mode it will either hang or crash.
"
Bug,QPID-3778,12539610,qpid-stat with MD5 fails when other tools running,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"qpid-stat reliably fails with a ""connection aborted"" message when it is connected through SASL MD5, and when there are several qpid-tools also connected to the broker.
The qpid-tools do not have to be connected with MD5.  They do not have to be doing anything, just sitting there.
In my testing the qpid-stat failure occurred close to 100% of the time when there were at least 3 qpid-tools connected."
Bug,QPID-2991,12494957,Add message counts for both directions to connection stats,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The connection object visible via management (e.g. with qpid-tool) has
statistics for frames and bytes sent over the connection in each direction
(note that the stats of frames/bytes *to* the client are currently not
correctly populated and are always at zero). It would be beneficial to also
record the number of messages, as that is often more meaningful.
"
Bug,QPID-438,12366159,C++ broker Queue.delete does not destroy the queue.,,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,The queue is partially destroyed (removed from registry and messagestore) but remains bound to the exchange. Careful not to introduce shared_ptr cycles and memory leaks when fixing this.
Bug,QPID-3180,12503120,Ring queues do not work with --default-queue-limit 0,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,A broker started with --default-queue-limit 0 will result in any ring queue failing to enqueue any messages with non-empty content as the policy incorrectly tries to enforce a size of 0 rather than an infinite size limit.
Bug,QPID-2295,12443700,Clustered broker crashes with inconsistency error,aconway,prattrs,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"When running two brokers in a cluster, one of them will fail with a message like the following:

2009-12-17 14:04:23 error qpid/amqp_0_10/SessionHandler.cpp:97: Execution exception: invalid-argument: na1mdev1@QPID.f16efd17-e55d-4a40-b9b0-c506a4df5f3e: confirmed < (805+0) but only sent < (800+0) (qpid/SessionState.cpp:151)
2009-12-17 14:04:23 critical qpid/cluster/ErrorCheck.cpp:87: cluster(10.59.174.211:3060 READY/error) local error 126323 did not occur on member 10.59.174.186:32003: invalid-argument: na1mdev1@QPID.f16efd17-e55d-4a40-b9b0-c506a4df5f3e: confirmed < (805+0) but only sent < (800+0) (qpid/SessionState.cpp:151)
2009-12-17 14:04:23 error ./qpid/cluster/PollableQueue.h:58: Error delivering frames: local error did not occur on all cluster members : invalid-argument: na1mdev1@QPID.f16efd17-e55d-4a40-b9b0-c506a4df5f3e: confirmed < (805+0) but only sent < (800+0) (qpid/SessionState.cpp:151) (qpid/cluster/ErrorCheck.cpp:89)
2009-12-17 14:04:23 notice qpid/cluster/Cluster.cpp:369: cluster(10.59.174.211:3060 LEFT/error) leaving cluster na1m-dev1
2009-12-17 14:04:23 notice qpid/broker/Broker.cpp:340: Shut down
...
2009-12-17 14:25:00 error qpid/amqp_0_10/SessionHandler.cpp:97: Execution exception: invalid-argument: na1mdev1@QPID.28265958-4239-4fdf-8772-f6630a7f01fe: confirmed < (742+0) but only sent < (729+0) (qpid/SessionState.cpp:151)
2009-12-17 14:25:00 critical qpid/cluster/ErrorCheck.cpp:87: cluster(10.59.174.211:3874 READY/error) local error 151214 did not occur on member 10.59.174.186:32003: invalid-argument: na1mdev1@QPID.28265958-4239-4fdf-8772-f6630a7f01fe: confirmed < (742+0) but only sent < (729+0) (qpid/SessionState.cpp:151)
2009-12-17 14:25:00 error ./qpid/cluster/PollableQueue.h:58: Error delivering frames: local error did not occur on all cluster members : invalid-argument: na1mdev1@QPID.28265958-4239-4fdf-8772-f6630a7f01fe: confirmed < (742+0) but only sent < (729+0) (qpid/SessionState.cpp:151) (qpid/cluster/ErrorCheck.cpp:89)
2009-12-17 14:25:00 notice qpid/cluster/Cluster.cpp:369: cluster(10.59.174.211:3874 LEFT/error) leaving cluster na1m-dev1
2009-12-17 14:25:00 notice qpid/broker/Broker.cpp:340: Shut down

qpidd.conf looks like this:

data-dir=/usr/local/adobe/qpid-data
#no-module-dir=1
#load-module=/usr/local/adobe/qpid/lib/qpid/daemon/cluster.so
#load-module=/usr/local/adobe/qpid/lib/qpid/daemon/msgstore.so
cluster-mechanism=PLAIN
#cluster-mechanism=ANONYMOUS
cluster-name=""na1m-dev1""
cluster-username=""na1mdev1""
cluster-password=""***""
log-to-file=/usr/local/adobe/qpid-data/qpidd.log
log-source=1
trace=0
auth=1
#acl-file=/usr/local/adobe/qpid-data/qpidd.acl
wait=60

The client is the Java JMS client from 0.6beta1.  The connection strings are as follows:

connectionfactory.qpidConnectionFactory = amqp://na1mdev1:***@test/?brokerlist='tcp://na1m-dev1.services.adobe.com:443?ssl='true',connectdelay='1000',connecttimeout='5000'',failover='roundrobin?cyclecount='999''

destination.recvQueue=direct:////test-prattrs?durable='true'
destination.sendQueue=direct:////test-prattrs?durable='true'

Qpid was built from trunk at the following revision:

[prattrs@localhost qpid]$ svn info
Path: .
URL: http://svn.apache.org/repos/asf/qpid/trunk/qpid
Repository Root: http://svn.apache.org/repos/asf
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68
Revision: 891406
Node Kind: directory
Schedule: normal
Last Changed Author: aconway
Last Changed Rev: 891395
Last Changed Date: 2009-12-16 11:31:20 -0800 (Wed, 16 Dec 2009)

The messaging store was built from trunk at the following revision:

[prattrs@localhost cpp]$ svn info
Path: .
URL: http://anonsvn.jboss.org/repos/rhmessaging/store/trunk/cpp
Repository Root: http://anonsvn.jboss.org/repos/rhmessaging
Repository UUID: 06e15bec-b515-0410-bef0-cc27a458cf48
Revision: 3750
Node Kind: directory
Schedule: normal
Last Changed Author: kpvdr
Last Changed Rev: 3747
Last Changed Date: 2009-12-16 10:24:45 -0800 (Wed, 16 Dec 2009)

I'll work on packaging up driver code for external consumption.  Basically though, what I'm doing to drive qpid is establishing 8 send and 8 receiving connections, with either a producer or consumer on each one, and a separate thread for each.  Message bodies are randomly generated 1000 character strings.  Each sender thread sends 1000 or these messages, for a total of 8000 messages sent.  All the messages get through because the primary survives in good health.  The total length of the sending period for each of the above failures was about 20 seconds, at a rate of about 450 messages per second.
"
Bug,QPID-4165,12600054,Fix unsused variable warnings when compiling with -DNDEBUG ,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Trivial fixes, patch attached.
request merge to 0.18."
Bug,QPID-424,12365147,C++: Fix memory leaks,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"We need to get to a clean slate on memory leaks, right now valgrind is reporting quite a few.

The current batch of leaks are being suppressed in cpp/test/.vg-supp so that we can make --enable-valgrind the default and catch/fix new leaks quickly going forward. Valgrind errors are equivalent to a test failure, you should not commit with errors.

The supressed leaks also need to be addressed either fix the leak or prove that it's a problem outside qpid's control. 
In the later case the supression description should explain why the leak can safely be ignored."
Bug,QPID-4259,12605144,HA broker crash during queue reroute,aconway,dillaman,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Broker will crash if a priority queue contains deleted messages with NULL payloads (i.e. HA message padding) when a reroute is performed.  PriorityQueue::removeIf is missing a guard to only include available messages for the reroute -- other classes derived from Messages have the guard.

Backtrace:
#0  0x00000036f42091c0 in pthread_mutex_lock () from /lib64/libpthread.so.0
#1  0x00007f8d9d58297a in qpid::sys::Mutex::lock (this=<value optimized out>) at ../include/qpid/sys/posix/Mutex.h:116
#2  0x00007f8d9d5fbdaa in ScopedLock (this=0x0) at ../include/qpid/sys/Mutex.h:33
#3  qpid::broker::Message::clearTrace (this=0x0) at qpid/broker/Message.cpp:389
#4  0x00007f8d9d61beab in qpid::broker::Queue::purge (this=0x7f8d940111a0, purge_request=<value optimized out>, dest=..., filter=<value optimized out>) at qpid/broker/Queue."
Bug,QPID-1723,12416510,Management's 'messages matched' count incorrect for headers exchange,tross,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"As reported on user list the messages routed counter for bindings from a headers exchange is non-zero even where no messages have been enqueued:

qpid: show 8386
Object of type org.apache.qpid.broker:binding: (last sample time: 13:55:35)
    Type       Element      8386

===================================================================================
    property   exchangeRef  110
    property   queueRef     4338
    property   bindingKey
    property   arguments    {u'SPECIES': 'DOG23', u'TYPE': 'ANIMAL',
u'x-match': 'all'}
    property   origin       <NULL>
    statistic  msgMatched   4193496

qpid: show 4338
Object of type org.apache.qpid.broker:queue: (last sample time: 00:20:06)
    Type       Element                4338

============================================================================================
    property   vhostRef               103
    property   name
pyclient-feeds-queuec9a401f7-413c-ab48-b955-5ca55bcdd7c6
    property   durable                False
    property   autoDelete             False
    property   exclusive              True
    property   arguments              {}
    statistic  msgTotalEnqueues       0 messages
    statistic  msgTotalDequeues       0
    statistic  msgTxnEnqueues         0
    statistic  msgTxnDequeues         0
    statistic  msgPersistEnqueues     0
    statistic  msgPersistDequeues     0
    statistic  msgDepth               0
    statistic  byteDepth              0 octets
    statistic  byteTotalEnqueues      0
    statistic  byteTotalDequeues      0
    statistic  byteTxnEnqueues        0
    statistic  byteTxnDequeues        0
    statistic  bytePersistEnqueues    0
    statistic  bytePersistDequeues    0
    statistic  consumerCount          0 consumers
    statistic  consumerCountHigh      0
    statistic  consumerCountLow       0
    statistic  bindingCount           2749 bindings
    statistic  bindingCountHigh       2749
    statistic  bindingCountLow        2749
    statistic  unackedMessages        0 messages
    statistic  unackedMessagesHigh    0
    statistic  unackedMessagesLow     0
    statistic  messageLatencySamples  0
    statistic  messageLatencyMin      0
    statistic  messageLatencyMax      0
    statistic  messageLatencyAverage  0

LIne 118 of HeadersExchange.cpp shows that the count is incremented regardless of the success of match test."
Bug,QPID-1936,12428648,Potential for deadlock when using durable ring queues,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"When a message is evicted from a durable ring queue (due to arrival of a new message when queue is at its limit), the dequeue request to the store plugin (if loaded) is done with the Queues messageLock held. Depending on the store plugins locking, this causes the potential for deadlocks and shouldbe fixed so that no lock is held when calling dequeue() (as is usually the case)."
Bug,QPID-980,12394956,Amend Qpid/C++ INSTALL file to show how to build/install Boost to work with the current build system,gsim,danushka,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"I found this issue when I was trying to build Boost from the source distribution.
   According to Qpid/C++ documentation (refer to INSTALL file) the following command is supposed to build Boost libraries.
   bjam -sTOOLS=gcc --prefix=~/qpid-tools

   The generated libraries with this command have the name format <prefix><library name>-<tooset name>-<threading tag>-<ABI tag><version tag><extension>.
.
   E.g. libboost_program_options-gcc41-mt-1_34_1.so

   In Qpid build system, the Boost libs that are linked have the name format <prefix><library name><extension>.

   The remedy for this issue is twofold.
   1. Use the following command instead of what is given in the INSTALL file.

   bjam -sTOOLS=gcc --layout=system --build-type=complete --prefix=~/qpid-tools

   This generates all possible variants of libs and hence what we want, takes longer time to build the libs though.

   2. Make use of package management tools to install Boost libs.

   On Ubuntu, use the following command.

   sudo apt-get install libboost*-dev "
Bug,QPID-1158,12399177,Portability problems with flock on solaris,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"On Thu, 2008-06-26 at 12:12 +0200, Manuel Teira wrote:
Hello.
> After further  investigation and tests, related with the change in 
> r671604 to drop the file locking strategy in favour of a flock on the 
> data dir.
> 
> Trying to write a similar code, but using lockf, I hit the issue that 
> the file must be opened using O_RDWR or O_RWONLY, and that's not allowed 
> for a directory.
> The same happens trying to use a fcntl call.
> And unexpectedly, the same for flock. In the solaris manual page:
> 
> <snip>
>      Read permission is required on a file  to  obtain  a  shared
>      lock,   and  write  permission  is  required  to  obtain  an
>      exclusive lock.
> </snip>
> 
> But the linux man page claims:
> 
> <snip>
> A shared or exclusive lock can be placed on a file regardless of the 
> mode in which the file was opened.
> </snip>
> 
> I've searched the web for some BSD system pages, but they don't say 
> anything about the file mode.
> 
> 
> On the other way, POSIX fcntl specification says, apropos the failure 
> causes:
> 
> [EBADF]
>     The /fildes/ argument is not a valid open file descriptor, or the
>     argument /cmd/ is F_SETLK or F_SETLKW, the type of lock, *l_type*,
>     is a shared lock (F_RDLCK), and /fildes/ is not a valid file
>     descriptor open for reading, or the type of lock *l_type*, is an
>     exclusive lock (F_WRLCK), and /fildes/ is not a valid file
>     descriptor open for writing. 
> 
> Posix specs also forces write permissions for lockf:
> http://www.opengroup.org/onlinepubs/007908799/xsh/lockf.html
> 
> 
> 
> This leads to solaris not being able to lock directly on a directory, 
> I'm afraid. Any idea?
> 

Yes, we can create (if it doesn't already exist) a lock file in the directory and then use lockf to lock it. There's already code in Daemon.cpp that does exactly this for the PID file. The reason I switched to flock was because crashing or killed brokers were sometimes leaving the lock file behind them, whereas a flock (or lockf)  lock is automatically released when the process exits. 

We need to
 - create a qpid::sys::LockFile class that can be re-implemented on different platforms.
 - use the Daemon.cpp code as the posix implementation.
 - Replace the locking code in Daemon.cpp and DataDir.cpp with the common sys::LockFile."
Bug,QPID-3773,12539067,Creating exchange source routes to different brokers can fail if the channels overlap.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The following valid configuration results in a failure to create a second bridge queue:

./qpidd --auth no --no-data-dir -p 7777 &
./qpidd --auth no --no-data-dir -p 8888 &
./qpidd --auth no --no-data-dir -p 9999 &

[kgiusti@localhost src (trunk)]$ qpid-config -a127.0.0.1:7777 add exchange topic ex1
[kgiusti@localhost src (trunk)]$ qpid-config -a127.0.0.1:8888 add exchange topic ex1
[kgiusti@localhost src (trunk)]$ qpid-config -a127.0.0.1:9999 add exchange topic ex1
[kgiusti@localhost src (trunk)]$ qpid-route -s route add 127.0.0.1:7777 127.0.0.1:8888 ex1 ""#""
[kgiusti@localhost src (trunk)]$ qpid-route -s route add 127.0.0.1:9999 127.0.0.1:8888 ex1 ""#""

This *should* result in two bridge queues being created on 127.0.0.1:8888; one queue for the route to :7777, the other for the route to :9999.

What actually happens is one queue is created:

[kgiusti@localhost src (trunk)]$ qpid-stat -q 127.0.0.1:8888
Queues
  queue                                                dur  autoDel  excl  msg   msgIn  msgOut  bytes  bytesIn  bytesOut  cons  bind
  ====================================================================================================================================
  ...
  bridge_queue_1_c1de955c-3632-4a7d-b6d8-be9890ff38b3       Y        Y        0     0      0       0      0        0         1     2
  ...

This is due to the way the broker generates the name for the queue.  The format of the name is ""bridge_queue_"" + channel# + broker's federation uuid.  In the failure case, the channel # happens to be the same for both routes, which results in duplicate names for different queues."
Bug,QPID-3206,12504157,Variant converts from negative number in string format to unsigned integer without error,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"E.g. 
  uint16_t i = 0;
  qpid::types::Variant v = ""-5"";
  i = v;

The above results in an exception in older versions of gcc (e.g. 4.1.2) but sets i to 65531 on later versions (e.g. 4.4.4). This is a result of a fix to the gcc std library to be compliant with specification which requires stringstream to accept negative values even for unsigned ints (which is the behaviour of scanf).

See e.g:
http://boost.2283326.n4.nabble.com/conversion-lexical-cast-doesn-t-throw-td2593967.html
http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/97475b21515462c9/ce369a327fa39243#ce369a327fa39243"
Bug,QPID-2281,12443466,Windows C++ broker does not detect and disallow multiple brokers using the same data directory,astitcher,astitcher,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The LockFile implementation on Windows doesn't actually lock the the lock file, it merely opens it. This means that the only use of this class in the Windows broker which is to ensure that multiple brokers don't share the same data directory is nullified."
Bug,QPID-3866,12543698,Priority ring queue lets lower-priority message displace higher-priority,gsim,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Currently a ring+priority queue works by removing the lowest priority message
if the limit is reached. However it does not consider whether the new message
is actually of lower priority than the one being displaced. A lower priority
message should not displace a higher-priority message.
"
Bug,QPID-2588,12464002,Race condition in queue,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"==32561== Possible data race during read of size 8 at 0x60260f0 by thread #9
==32561==    at 0x4F1AC4A: qpid::broker::Queue::enqueue(qpid::broker::TransactionContext*, boost::intrusive_ptr<qpid::broker::Message>, bool) (Queue.cpp:743)
==32561==    by 0x4F1577E: qpid::broker::Queue::deliver(boost::intrusive_ptr<qpid::broker::Message>&) (Queue.cpp:157)
==32561==    by 0x4ECC2A1: qpid::broker::DeliverableMessage::deliverTo(boost::shared_ptr<qpid::broker::Queue> const&) (DeliverableMessage.cpp:31)
==32561==    by 0x4EE3AD2: qpid::broker::Exchange::doRoute(qpid::broker::Deliverable&, boost::shared_ptr<std::vector<boost::shared_ptr<qpid::broker::Exchange::Binding>, std::allocator<boost::shared_ptr<qpid::broker::Exchange::Binding> > > const>) (Exchange.cpp:91)
==32561==    by 0x4F74702: qpid::broker::TopicExchange::route(qpid::broker::Deliverable&, std::string const&, qpid::framing::FieldTable const*) (TopicExchange.cpp:321)
==32561==    by 0x4F490DC: qpid::broker::SemanticState::route(boost::intrusive_ptr<qpid::broker::Message>, qpid::broker::Deliverable&) (SemanticState.cpp:461)
==32561==    by 0x4F482C6: qpid::broker::SemanticState::handle(boost::intrusive_ptr<qpid::broker::Message>) (SemanticState.cpp:415)
==32561==    by 0x4F6DB55: qpid::broker::SessionState::handleContent(qpid::framing::AMQFrame&, qpid::framing::SequenceNumber const&) (SessionState.cpp:249)
==32561==    by 0x4F6E803: qpid::broker::SessionState::handleIn(qpid::framing::AMQFrame&) (SessionState.cpp:327)
==32561==    by 0x4F716EC: qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) (Handler.h:67)
==32561==    by 0x55DF009: qpid::amqp_0_10::SessionHandler::handleIn(qpid::framing::AMQFrame&) (SessionHandler.cpp:93)
==32561==    by 0x4F716EC: qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle(qpid::framing::AMQFrame&) (Handler.h:67)
==32561==  This conflicts with a previous write of size 8 by thread #1
==32561==    at 0x4F1CA89: qpid::broker::Queue::destroy() (Queue.cpp:900)
==32561==    by 0x4F1D48B: qpid::broker::Queue::tryAutoDelete(qpid::broker::Broker&, boost::shared_ptr<qpid::broker::Queue>) (Queue.cpp:1011)
==32561==    by 0x4F48029: qpid::broker::SemanticState::cancel(boost::shared_ptr<qpid::broker::SemanticState::ConsumerImpl>) (SemanticState.cpp:402)
==32561==    by 0x4F449DE: qpid::broker::SemanticState::~SemanticState() (SemanticState.cpp:84)
==32561==    by 0x4F6CCA1: qpid::broker::SessionState::~SessionState() (SessionState.cpp:96)
==32561==    by 0x4F6CE53: qpid::broker::SessionState::~SessionState() (SessionState.cpp:96)
==32561==    by 0x4F67BDC: std::auto_ptr<qpid::broker::SessionState>::~auto_ptr() (auto_ptr.h:168)
==32561==    by 0x4F66CEF: qpid::broker::SessionHandler::handleDetach() (SessionHandler.cpp:70)


"
Bug,QPID-4490,12618880,Durable messages with TTL do not expire after broker recovery (c++ store),kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Durable messages with TTL which are later recovered from the c++ store do not expire. The following demonstrates:

1. Start broker:
./qpidd --load-module msgstore.so --auth no --log-enable info+

2. Run client to send two messages:
./qpid-send -m 2 --ttl 100000 --durable yes -a ""test; {create: always, node: {durable: True}}""

3. Stop and restart broker, recovering the messages.

4. Run client to receive messages one at a time:

./qpid-receive -m 1 --print-header yes -a test
TTL: 100000
Durable: true
Redelivered: true
Properties: {sn:1, ts:1354716748759170497, x-amqp-0-10.routing-key:test}

./qpid-receive -m 1 --print-header yes -a test
TTL: 100000
Durable: true
Redelivered: true
Properties: {sn:2, ts:1354716748759340826, x-amqp-0-10.routing-key:test}

For both messages the TTL of the recovered messages is set to 100000 (the initial setting), but the timer is not running, and the TTL never decreases.
"
Bug,QPID-2157,12438837,Persistent cluster restart,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Currently, when restarting a persistent cluster, the first broker to start loads from its store and all other brokers move their store aside and update from the cluster.  If some brokers failed and have out-of-date stores, we assume manual intervention to ensure that the correct broker is started first.

The goal is to have the brokers automatically compare their stores, allowing all brokers with clean stores to load from store and all other brokers to update from the cluster.

A design note for this issue is at http://cwiki.apache.org/confluence/display/qpid/Persistent+Cluster+Restart+Design+Note"
Bug,QPID-630,12380088,C++ broker dies/hangs during CommitRollbackTest,gsim,rhs,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,I seem to be able to cause the C++ broker to intermittedly die by running CommitRollbackTest from the java client suite. I also got it to hang once. Please see attached stack dump.
Bug,QPID-4248,12604887,HA does not replicate topic binding keys to backups,aconway,dillaman,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"With HA enabled, start a primary broker and create a topic exchange, queue, and a binding with a non-empty binding key between the exchange and queue.  Start a backup broker and notice that the binding key is missing on the backup broker's binding.

Actions:
<start primary>
qpid-config add exchange topic MyExchange
qpid-config add queue MyQueue
qpid-config bind MyExchange MyQueue MyKey
<start backup>

Primary Config:
Exchange 'MyExchange' (topic)
    bind [MyKey] => MyQueue

Backup Config:
Exchange 'MyExchange' (topic)
    bind [] => MyQueue
"
Bug,QPID-4625,12635234,Amqp 1.0 message properties (from the application-properties section) cannot be extracted,astitcher,astitcher,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,The existing code has only a stub implementation which returns null when trying to extract properties from 1.0 messages. This means that the selectors code cannot extract any property values from 1.0 messages.
Bug,QPID-2979,12493333,The following SASL mechanisms [PLAIN] specified by the client are not supported by the broker,gsim,ibisek,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,JMS AMQP 0-x,,,,,,"An exception is thrown when connecting from a Java client (v 0.8) to qpidd (v 0.8) run with ""--auth no"".

javax.jms.JMSException: Error creating connection: The following SASL mechanisms [PLAIN] specified by the client are not supported by the broker
	at org.apache.qpid.client.AMQConnectionFactory.createConnection(AMQConnectionFactory.java:286)

Used JNDI/JMS configuration:

java.naming.factory.initial = org.apache.qpid.jndi.PropertiesFileInitialContextFactory
connectionfactory.qpidConnectionfactory = amqp://guest:guest@clientid/abcd?brokerlist='tcp://localhost:5672'
destination.mainSend = direct://amq.direct//step.01

It worked just fine in 0.6 but no success now in 0.8. 

The broker is from Contributed C++ Packages -> Windows Installer (http://www.riverace.com/qpid/qpidc-0.8-x86.msi)

Logs from qpidd:

C:Program Filesapache-qpidc-0.8bin>qpidd --auth no --log-enable info+ --log-enable trace+:amqp_0_10
2010-12-15 11:42:48 info Management enabled
2010-12-15 11:42:48 notice SASL disabled: No Authentication Performed
2010-12-15 11:42:48 info Policy file not specified. ACL Disabled, no ACL checking being done!
2010-12-15 11:42:48 error Failed to initialise SSL listener: The credentials supplied to the package were not recognized (........cpps
rcqpidbrokerwindowsSslProtocolFactory.cpp:177)
2010-12-15 11:42:48 notice Listening on TCP port 5672
5672
2010-12-15 11:42:48 notice Broker running
2010-12-15 11:42:53 trace SENT 127.0.0.1:1786 INIT(0-10)
2010-12-15 11:42:53 trace SENT [127.0.0.1:1786]: Frame[BEbe; channel=0; {ConnectionStartBody: server-properties={qpid.federation_tag:V2:36:s
tr16(96790865-dc5c-427a-affe-70d021653737)}; mechanisms=str16{V2:9:str16(ANONYMOUS)}; locales=str16{V2:5:str16(en_US)}; }]


Run it with the -t option:

2010-12-15 11:45:56 trace SEND raiseEvent (v1) class=org.apache.qpid.broker.clientDisconnect
2010-12-15 11:46:01 debug RECV [127.0.0.1:1794] INIT(0-10)
2010-12-15 11:46:01 trace SENT 127.0.0.1:1794 INIT(0-10)
2010-12-15 11:46:01 trace SENT [127.0.0.1:1794]: Frame[BEbe; channel=0; {ConnectionStartBody: server-properties={qpid.federation_tag:V2:36:s
tr16(96790865-dc5c-427a-affe-70d021653737)}; mechanisms=str16{V2:9:str16(ANONYMOUS)}; locales=str16{V2:5:str16(en_US)}; }]
2010-12-15 11:46:01 debug DISCONNECTED [127.0.0.1:1794]
2010-12-15 11:46:01 trace SEND raiseEvent (v1) class=org.apache.qpid.broker.clientDisconnect 
"
Bug,QPID-2183,12439713,Deleting a durable queue while durable messages are queued crashes broker/SQL provider,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If the C++ broker is running with the MS SQL storage provider and a durable queue is deleted while there are still durable messages in the queue, the broker crashes. Removing the message from the messages table fails with an integrity violation because there are still references to the message ID in the messages->queues map. Handling that exception throws another one trying to close the recordset and the C++ runtime kills the process.

Should probably put the queue, map, message deleting logic in a stored procedure."
Bug,QPID-3030,12497357,C++ buffer encoding allows overflow on write.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The framing Buffer::put{Short,Medium,Long}String() or Buffer::putRawData() do not validate the length of the written data, and may allow overflow of the buffer."
Bug,QPID-4722,12641189,qpid-cpp-0.22-rc1 doesnt compile on RHEL6,,jimmyjones2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Freshly installed RHEL6.3 VM

Compile (with automake) of http://people.apache.org/~jross/qpid-0.22-rc1/qpid-cpp-0.22-rc1.tar.gz fails unless -Werror is removed:

make[3]: Entering directory `/home/jimmy/Downloads/qpidc-0.22/src'
/bin/sh ../libtool  --tag=CXX   --mode=compile g++ -DHAVE_CONFIG_H -I. -I../include -I../include -I. -I=.   -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -D_IN_QPID_BROKER -g -O2 -MT qpid/sys/libqpidbroker_la-SocketTransport.lo -MD -MP -MF qpid/sys/.deps/libqpidbroker_la-SocketTransport.Tpo -c -o qpid/sys/libqpidbroker_la-SocketTransport.lo `test -f 'qpid/sys/SocketTransport.cpp' || echo './'`qpid/sys/SocketTransport.cpp
libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../include -I../include -I. -I=. -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -D_IN_QPID_BROKER -g -O2 -MT qpid/sys/libqpidbroker_la-SocketTransport.lo -MD -MP -MF qpid/sys/.deps/libqpidbroker_la-SocketTransport.Tpo -c qpid/sys/SocketTransport.cpp  -fPIC -DPIC -o qpid/sys/.libs/libqpidbroker_la-SocketTransport.o
cc1plus: warnings being treated as errors
qpid/sys/SocketTransport.cpp: In constructor 'qpid::sys::SocketAcceptor::SocketAcceptor(bool, bool, uint32_t, qpid::sys::Timer&)':
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/bind_cc.hpp:72: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/bind.hpp:482: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/storage.hpp:244: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/storage.hpp:195: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/storage.hpp:129: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'f' is used uninitialized in this function
qpid/sys/SocketTransport.cpp:114: note: 'f' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'f' is used uninitialized in this function
/usr/include/boost/function/function_template.hpp:722: note: 'f' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'f' is used uninitialized in this function
/usr/include/boost/function/function_template.hpp:915: note: 'f' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'f' may be used uninitialized in this function
/usr/include/boost/function/function_template.hpp:602: note: 'f' was declared here
In file included from /usr/include/boost/bind/bind.hpp:1538,
                 from /usr/include/boost/bind.hpp:22,
                 from qpid/sys/SocketTransport.cpp:32:
qpid/sys/SocketTransport.cpp: In function 'boost::_bi::bind_t<R, R (*)(B1, B2, B3, B4, B5, B6), typename boost::_bi::list_av_6<A1, A2, A3, A4, A5, A6>::type> boost::bind(R (*)(B1, B2, B3, B4, B5, B6), A1, A2, A3, A4, A5, A6) [with R = void, B1 = boost::shared_ptr<qpid::sys::Poller>, B2 = const qpid::sys::SocketTransportOptions&, B3 = qpid::sys::Timer*, B4 = const qpid::sys::Socket&, B5 = qpid::sys::ConnectionCodec::Factory*, B6 = const std::string&, A1 = boost::shared_ptr<qpid::sys::Poller>, A2 = qpid::sys::SocketTransportOptions, A3 = qpid::sys::Timer*, A4 = boost::arg<1>, A5 = qpid::sys::ConnectionCodec::Factory*, A6 = std::basic_string<char, std::char_traits<char>, std::allocator<char> >]':
qpid/sys/SocketTransport.cpp:209: error: 'a2' is used uninitialized in this function
/usr/include/boost/bind/bind_cc.hpp:83: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' may be used uninitialized in this function
/usr/include/boost/bind/bind.hpp:551: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' may be used uninitialized in this function
/usr/include/boost/bind/storage.hpp:276: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' may be used uninitialized in this function
/usr/include/boost/bind/storage.hpp:227: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' may be used uninitialized in this function
/usr/include/boost/bind/storage.hpp:195: note: 'a2' was declared here
qpid/sys/SocketTransport.cpp:209: error: 'a2' may be used uninitialized in this function
/usr/include/boost/bind/storage.hpp:129: note: 'a2' was declared here
make[3]: *** [qpid/sys/libqpidbroker_la-SocketTransport.lo] Error 1
make[3]: Leaving directory `/home/jimmy/Downloads/qpidc-0.22/src'
"
Bug,QPID-4452,12617159,issuing and handling of producer credit not implemented,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,Prevents proper stress testing.
Bug,QPID-1865,12425858,Built-in exchanges can be deleted on the C++ broker,tross,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Executing an exchange.delete on a built-in exchange (amq.* or """") causes the exchange to be deleted.  This may lead to the broker becoming unusable.
"
Bug,QPID-3222,12504794,Potentially TTL Overflow,gsim,jeromeajot,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"When a message TTL is set by the client to Duration::FOREVER, the message is not reachable anymore.

Every addition and multiplication to the TTL/Expiration Time should check to avoid uint64_t overflow.
For example: broker/Message.cpp: Message::setTimestamp() overflows the uint64_t."
Bug,QPID-640,12380447,"The C++ struct encode/decode always includes nested structs even when they're empty, and (I believe) transforms empty strings to null",gsim,rhs,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The code that detectes whether or not a struct field is present does so by checking the size or value of the field. This results in some odd behavior. 

 - nested structs will always be included on the wire even when empty because the size is computed to always include the packing flags
 - empy strings can never be encoded onto the wire
 - zero values will be omitted

As the specification doesn't state that empty values are equivalent to absent ones, this behavior is probably unsafe since to clients that treat null separately from empty ("""" or 0), the broker would appear to be transforming the specified field value.

As a general rule I'd suggest that when the client presents us fields encoded in a certain way we should probably leave the encoding of those fields alone unless we're modifying the semantic value somehow.
"
Bug,QPID-1901,12427633,Messages with no content that 'flow to disk' result in protocol errors on delivery,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If 'flow to disk' is triggered for messages that have no content (i.e. if the
content is released from memory because the queue onto which they are placed
has reached a specified limit), then on delivery the broker sends an empty
content frame after a header frame that marks the frameset as ended. This is a
protcol violation and causes the connection to be terminated.

To reproduce e.g. run:

1. qpid-config add queue test-queue --durable --max-queue-count 5
2. for m in one two three four five six seven """" eight nine ten; do echo $m;
done | ./src/tests/sender --send-eos 1
3. ./src/tests/receiver

"
Bug,QPID-1899,12427585,--require-encryption doesn't work unless cyrus sasl authentication is turned on,shuston,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If you specify --require-encryption and --auth no then the broker will allow un-encrypted conections. (If on the other hand you have authentication on, it will prevent you connecting with anything other than a mech that supports encryption and will require an encrypting sasl security layer - or of course an ssl connection)"
Bug,QPID-4194,12601598,cluster should enable queue events in CATCHUP state,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"pavel moravec has discovered the mechanism for this problem already -- current cluster code does not enable queue events until READY state -- but new messages may be enqueued during CATCHUP state.
So if you have a replication-queue, which needs those queue-events to be generated, a newbie broker -- if it is in CATCHUP state -- will fail to replicate any messages that arrive on the replicated queue.
Two-line fix"
Bug,QPID-1660,12414567,Consumer with no credit can cause messages not to be seen by other consumers on that queue,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Create a queue and publish one message to it. Then start a consumer (pre-acquiring subscription), with credit for one message. When the message is delivered, sleep for a short while and start a new consumer on the same queue. Then have the first consumer release the message.

The released message is now available for redelivery. Unfortunately the first consumer is picked as the consumer to be notified of this. That consumers connection then attempts to deliver the message but finds it has insufficient credit. The second consumer however is not notified and the broker does not attempt to dispatch the message.

(This is a bug introduced by the change in r721685  which was intended to fix QPID-1280)."
Bug,QPID-3335,12512468,Remove duplicate and buggy type conversion code from Management Agent.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The broker's management agent exports a FieldTable to Variant Map translation API.  This duplicates the translation code from the common library (Codecs.h), and the version in the management agent is stale and buggy.   Remove the duplication and have the management agent use the common code. "
Bug,QPID-4040,12559391,Destination federation broker needs to close connection if heartbeats are missed,tross,ncdc,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"When setting up a federation link, the destination broker never checks to see if it's missed heartbeats from its peer (the source broker).  As such, if network connectivity is lost to the source broker, the destination broker continues to believe that the link is operational.  To fix this, the destination broker should verify that it is still receiving heartbeats, and forcefully close the connection to the source broker if it isn't."
Bug,QPID-4442,12616646,x-match fails to match properties,gsim,lanced,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Using the spout/drain messaging example.  I run the spout like this:
spout -P source:sports -c 1 my_exchange

And I run drain like this:
drain -f ""my_queue; {create:receiver, node:{x-declare:{auto-delete:true},x-bindings:[{exchange:'my_exchange',queue:'my_queue,key:'key',arguments:{x-match:any,source:'sports'}}]}}""

Using a drain built on version v0.14, this works, the source property is correctly matched and messages are correctly routed to the drain through a v0.18 C++ broker; using a drain built in version v0.18, messages are not routed to the drain's queue.

Further inspection (at the packet level) shows that the difference is that in the exchange.bind method on the drain side, 'sports' is encoded as a variable binary (0x90) in v0.14, but a string (0x95) in v0.18.

"
Bug,QPID-1843,12424855,Multiple use of single qpid::management::ManagementAgent::Singleton confusing and error-prone,tross,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,QMF,,,,,,"Currently the qpid/agent/ManagementAgent.h file declares the qpid::management::ManagementAgent pure virtual class. Places where management agent functionality is desired must derive a class from ManagementAgent at a minimum. This is fine. However, there's also a non-virtual ManagementAgent::Singleton class defined in ManagementAgent.h. Current practice for this arrangement requires each place where a ManagementAgent-derived class is defined to also reimplement (including static class members) qpid::management::ManagementAgent::Singleton, the implementation of which manages the new class derived from ManagementAgent.

This causes a problem because the ManagementAgent::Singleton class's member functions must be exported from the implementing DLL. However, the implementing DLL is not known when the class is declared and, in fact, there may be multiple implementations. For example, the qmf-agent has an implementation, and so does the broker. Currently, Singleton is marked as exported from the QMF-agent library. Thus, when broker is built, it sees both locally-defined and imported Singleton symbols. Apparantly, g++ is ok with this and just takes the local one (even if that's not what you want, but I digress...).

It wouldn't work to just avoid exporting the symbols, because they are needed externally. For example, the acl plugin needs to get the broker's singleton pointer.

One idea is to simply avoid the use of Singleton. If a instance of a ManagementAgent-derived class is desired, just instantiate one. Or add a method to the subclass to manage a singleton. Or whatever works for the particular class's use cases. The point is to push the lifetime management to the agent-derived class.

In the case of the broker, the ManagementBroker (derived from ManagementAgent) could simply be used (or not, depending on the disable-management setting), and a method be added to Broker to obtain the ManagementAgent pointer, which could be a refcounted pointer since it's often saved. Then the, for example, ManagementBroker could export the symbols it needs, if any, in addition to the getMgmtAgent (or whatever) method.

Any other ideas on this? I can start working on the changes when we decide on a way to go."
Bug,QPID-1073,12396340,Broker deadlock in management code,tross,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"There is a possible deadlock that can occur in the C++ broker if a bind request to a topic exchange occurs coincident with the transmission of a periodic update from the management broker.

This issue was discovered by Rafi Schloming when testing the broker with a management publish interval of zero seconds.
"
Bug,QPID-2670,12467007,Concurrent tagging of message with trace id while message is delivered from another queue causes segfault,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Federation routes that annotate a message with a trace id can cause segfaults
if that message is concurrently delivered from another queue.
"
Bug,QPID-1819,12423045,Large messages cause hangs and crashes when using digest-md5 and security layer (ssf 128),gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"crash ends with:

2009-apr-15 17:43:44 trace guest@QPID.6411302a-229c-4eb1-b097-fc8a613a3233: sent cmd 0: content (65495 bytes) cccccccccccccccc...
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[BEbe; channel=2; {SessionFlushBody: completed=1; }]
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[Bbe; channel=2; {MessageTransferBody: destination=message_queue; accept-mode=0; acquire-mode=0; }]
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[be; channel=2; header (47 bytes); properties={{MessageProperties: content-length=65495; }{DeliveryProperties: exchange=amq.direct; routing-key=routing_key; }}]
qpidd: qpid/amqp_0_10/Connection.cpp:93: virtual size_t qpid::amqp_0_10::Connection::encode(const char*, size_t): Assertion `workQueue.empty() || workQueue.front().encodedSize() <= size' failed.


pstack for hung client:

Thread 2 (Thread 0xb7f77b90 (LWP 16187)):
#0  0x0069a416 in __kernel_vsyscall ()
#1  0x00ce1b3b in write () from /lib/libc.so.6
#2  0x0024fd80 in qpid::sys::Socket::write () from /usr/lib/libqpidcommon.so.0
#3  0x00255eb4 in qpid::sys::posix::AsynchIO::writeable ()
#4  0x00259152 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO,
qpid::sys::DispatchHandle&>,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::arg<1> (*)()> >, void, qpid::sys::DispatchHandle&>::invoke ()
#5  0x002b77d3 in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() () from
/usr/lib/libqpidcommon.so.0
#6  0x002b5b78 in qpid::sys::DispatchHandle::processEvent ()
#7  0x00267ef6 in qpid::sys::Poller::run () from /usr/lib/libqpidcommon.so.0
#8  0x002b53c4 in qpid::sys::Dispatcher::run ()
#9  0x00e8b3d2 in qpid::client::TCPConnector::run ()
#10 0x0025dba1 in ?? () from /usr/lib/libqpidcommon.so.0
#11 0x00dbc51f in start_thread () from /lib/libpthread.so.0
#12 0x00cf204e in clone () from /lib/libc.so.6
Thread 1 (Thread 0xb7f78720 (LWP 16186)):
#0  0x0069a416 in __kernel_vsyscall ()
#1  0x00dc0105 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
#2  0x00d00e9d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x00e70f4d in qpid::client::Bounds::expand ()
#4  0x00eb4642 in qpid::client::SessionImpl::sendFrame ()
#5  0x00eb479c in qpid::client::SessionImpl::handleOut ()
#6  0x00eb7488 in qpid::client::SessionImpl::sendContent ()
#7  0x00eb7db2 in qpid::client::SessionImpl::sendCommand ()
#8  0x00eb7f07 in qpid::client::SessionImpl::send ()
#9  0x00e68afe in qpid::client::no_keyword::Session_0_10::messageTransfer ()
#10 0x0804cf4f in main ()

"
Bug,QPID-3574,12529849,Perl bindings are not correctly installed,,caus,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,Building with PERL_LIB just installs the bindings library. The perl-Module itself seems to be missing in the install target.
Bug,QPID-1459,12408425,port confusion when ssl module is loaded,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The simple sequence of qpidd -d; qpidd -q no longer works because there is
ambiguity as to which port (tcp or ssl) defines the process:

$ src/qpidd --daemon
$ src/qpidd --quit
Cannot open /home/user/.qpidd/qpidd.5672.pid: No such file or directory
$ src/qpidd --quit --port 5671
$ 

It appears that the port used in the pid file is chosen by the --transport
option.  This option appears to default to ""ssl"" for creation of the daemon and
""tcp"" for deletion of the daemon.

This is also true of the stdout emission of an ephemeral port:

$ src/qpidd --daemon --port 0
5671

In this case, we have no idea what port qpidd is listening on for tcp."
Bug,QPID-1744,12417068,Adding a new node to a cluster node that has recovered messages from disk fails.,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Instead you get something like:

2009-mar-16 14:28:41 error Connection exception: framing-error: Unexpected
command start frame. (qpid/SessionState.cpp:57)"
Bug,QPID-2691,12467790,ttl is lost for federation routes where trace id is added,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,This was introduced by the fix to QPID-2670.
Bug,QPID-1435,12407867,TxOp.h compile warning TxOpConstVisitor,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Recent change to TxOp.h and new TxOpVisitor.h cause the following compile warning on Visual Studio:
c:\ace\exported\qpid\trunk\qpid\cpp\src\qpid\broker\TxOp.h(31) : warning C4099: 'qpid::broker::TxOpConstVisitor' : type name first seen using 'struct' now seen using 'class'
       c:\ace\exported\qpid\trunk\qpid\cpp\src\qpid\broker\TxOpVisitor.h(39) : see declaration of 'qpid::broker::TxOpConstVisitor'

Since TxOp.h already includes TxOpVisitor.h, there's no need to re-declare TxOpConstVisitor further down. Removing that fixes this. In the event it sometime becomes better to declare it rather than including TxOpVisitor.h, it should be declare using ""struct"" since that what it's defined as in TxOpVisitor.h

Index: TxOp.h
===================================================================
--- TxOp.h      (revision 711592)
+++ TxOp.h      (working copy)
@@ -28,8 +28,6 @@
 namespace qpid {
     namespace broker {

-class TxOpConstVisitor;
-
         class TxOp{
         public:
             typedef boost::shared_ptr<TxOp> shared_ptr;
"
Bug,QPID-4392,12613183,C++ Broker - channel number collisions on federated links,chug,chug,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Channel numbers are allocated in counting sequence. After creating and deleting tens of thousands of bridges the channel numbers wrap around and collide with existing channels.

Existing channel numbers need to be tracked so that new channel numbers are unique.
"
Bug,QPID-3476,12521631,Timer warnings are too verbose,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The broker at present will log warnings about overrunning timer tasks and late wakeups. In general they can be ignored. The information in the warnings is only of interest if they are experiencing other problems that may be connected to the precision of timer tasks. The most obvious issue - for which I believe these warnings were introduced - is where clients are timing out due to delays to broker heartbeats. 

Demoting the warnings to informational statements would avoid undue alarm and prevent excess noise in log files. Should there be a need to see the information it is a lot easier to enable it (--log-enable info+:TimerWarnings) than it is to turn it off at present. "
Bug,QPID-304,12360764,qpidd --daemon should not return until broker has started.,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Running qpidd --daemon followed immediately by a client sometimes fails becaue the background qpidd has not yet started accept()ing connections.

To fix this the, foreground qpidd process (which forks the background one with --daemon)  should not return until the background qpidd is accepting connections.

There are several ways to implement this. One is for the foreground qpidd to set up some inter-process communication (pipe, semaphore, whatever) and wait to be notified, the background qpidd would notify after calling accept() . Alternatively the foreground qpidd could repeatedly try to connect until it is succssful.

Whatever the approach be careful that the foreground qpidd returns with zero status only if the background daemon starts listening, and returns with non-zero exit status if the background  process fails for any reason. Under no circumstance should the foreground process hang forever. If the background qpidd does not start accepting within some reasonable delay (a minute or so) the foreground process should kill it and return non-zero status.

Once implemented, go thru all tests and remove arbitrary sleeps introduced to work around this problem."
Bug,QPID-4347,12609198,durable links break recovery,kgiusti,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"On recovery of a durable link, the broker calls MessageStore::create() for the recovered link which causes a hang and prevents recovery completing."
Bug,QPID-2567,12463676,[c++] Timer - possible thread lock ordering violation,astitcher,kpvdr,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Starting the broker using valgrind and the helgrind thread check tool shows several lock order violations centered around the qpid::sys::Timer class.

valgrind --tool=helgrind .libs/lt-qpidd --auth no --log-enable info+

results in the following message (and others that are similar):

==31280== Thread #2: lock order ""0x597D548 before 0x59AE350"" violated
==31280==    at 0x4A0679C: pthread_mutex_lock (hg_intercepts.c:464)
==31280==    by 0x4E8C27B: qpid::sys::Mutex::lock() (Mutex.h:116)
==31280==    by 0x4E8CD82: qpid::sys::ScopedLock<qpid::sys::Mutex>::ScopedLock(qpid::sys::Mutex&) (Mutex.h:33)
==31280==    by 0x56346FF: qpid::sys::Timer::add(boost::intrusive_ptr<qpid::sys::TimerTask>) (Timer.cpp:162)
==31280==    by 0x4EFDCD0: qpid::broker::LinkRegistry::Periodic::fire() (LinkRegistry.cpp:73)
==31280==    by 0x563344C: qpid::sys::TimerTask::fireTask() (Timer.cpp:57)
==31280==    by 0x5634917: qpid::sys::Timer::fire(boost::intrusive_ptr<qpid::sys::TimerTask>) (Timer.cpp:190)
==31280==    by 0x5633E84: qpid::sys::Timer::run() (Timer.cpp:119)
==31280==    by 0x5525BEE: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==31280==    by 0x4A0A1A5: mythread_wrapper (hg_intercepts.c:201)
==31280==    by 0x31D6C07950: start_thread (pthread_create.c:301)
==31280==    by 0x31D68E4D3C: clone (clone.S:115)
==31280==   Required order was established by acquisition of lock at 0x597D548
==31280==    at 0x4A095F6: pthread_cond_wait_WRK (hg_intercepts.c:653)
==31280==    by 0x4A096B8: pthread_cond_wait@* (hg_intercepts.c:675)
==31280==    by 0x4EF587A: qpid::sys::Condition::wait(qpid::sys::Mutex&) (Condition.h:63)
==31280==    by 0x4EF5932: qpid::sys::Monitor::wait() (Monitor.h:41)
==31280==    by 0x5633AA6: qpid::sys::Timer::run() (Timer.cpp:98)
==31280==    by 0x5525BEE: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==31280==    by 0x4A0A1A5: mythread_wrapper (hg_intercepts.c:201)
==31280==    by 0x31D6C07950: start_thread (pthread_create.c:301)
==31280==    by 0x31D68E4D3C: clone (clone.S:115)
==31280==   followed by a later acquisition of lock at 0x59AE350
==31280==    at 0x4A0679C: pthread_mutex_lock (hg_intercepts.c:464)
==31280==    by 0x4E8C27B: qpid::sys::Mutex::lock() (Mutex.h:116)
==31280==    by 0x4E8CD82: qpid::sys::ScopedLock<qpid::sys::Mutex>::ScopedLock(qpid::sys::Mutex&) (Mutex.h:33)
==31280==    by 0x5633B97: qpid::sys::Timer::run() (Timer.cpp:108)
==31280==    by 0x5525BEE: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==31280==    by 0x4A0A1A5: mythread_wrapper (hg_intercepts.c:201)
==31280==    by 0x31D6C07950: start_thread (pthread_create.c:301)
==31280==    by 0x31D68E4D3C: clone (clone.S:115)

Running perftest against this broker shows numerous read/write conflicts too.
"
Bug,QPID-3051,12498470,Reject can fail to restore message credit,gsim,jonathan.robie,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"In window mode, if messages are rejected before they are completed, the corresponding credit is not re-issued. I.e. the credit window is not correctly moved forward. A receiver with non-zero capacity that rejects message may therefore find that it gets no more messages delivered even when there are some available."
Bug,QPID-1711,12416088,Federation bridging sessions get command id sequence out of sync,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"general symptom is something like:

 invalid-argument: confirmed < (65535+0) but only sent < (65533+0) (qpid/SessionState.cpp:150)  

seen when running a federation link with acknowledgements turned on for a long period (i.e. lots of messages, exact number depends on the ack frequency selected)."
Bug,QPID-3152,12501756,non-clustered sasl_fed_ex_* tests load cluster.so,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,The 4 non-clustered versions of the sasl_fed_ex_* tests load cluster.so in the broker command line (and fail when it isn't present).
Bug,QPID-4262,12605307,C++ broker crashes due to priority queue corruption,aconway,dillaman,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When re-routing messages from a priority queue (via the queue's QMF purge method) back to the same queue, the PriorityQueue's ""messages"" deque will become out-of-sync with the state of its ""fifo"" MessageDeque.  Since the ""messages"" deque contains pointers into the ""fifo"" deque, this will lead to a broker crash as the pointers are no longer valid.  

This issue occurs because ""MessageDequeue::index()"" will return index zero for messages that are sequenced prior the start of the deque.  

Steps to reproduce:
(1) Create a priority queue
(2) Add several messages to the queue
(3) Issue a purge on the queue such that the messages return to the same queue
(4) Observe that the ""messages"" collection within the queue's PriorityQueue collection does not match its corresponding ""fifo"" collection."
Bug,QPID-1264,12403467,Don't hold exchange lock while routing  message,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,This can cause deadlocks when using upcoming rdma transport.
Bug,QPID-3629,12531779,CPP Broker allows credit window to exceed the request size.,gsim,kwall,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Investigation of QPID-2703 revealed that the CPP Broker can be made to extend the window size beyond that requested by the client's message.flow command.   To reproduce the problem, the client must perform the following steps:

1) Receive messages
2) Perform message stop
3) Perform message flow
4) Complete messages received by step 1)
5) Observe the window is the sum of that requested by step 3 + the recredit of messages from 1)

The window handling behaviour of the CPP Broker was the reason that QPID-2703 was not apparent against the CPP Broker but was against the Java Broker which does not expand the window in this way.

The attached Python test demonstrates the issue by receiving more uncompleted message commands than the window should allow.  Obviously it can be argued that the python test does not have the expected order of commands, but there is nothing stopping a client from performing such a sequence (e.g. the Qpid Java Client) so the broker should enforce the requested window size regardless.

"
Bug,QPID-1057,12395966,Fix XML Exchange for Python client (which does not supply an empty FieldTable if there are no application message headers),,jonathan.robie,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,This fixes a bug that could crash the server with Python clients.
Bug,QPID-2849,12473547,TTL not updated for messages on LVQs,gsim,dln,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"On an LVQ, enqueued messages will not update its TTL from newly posted messages having the same LVQ_key.

The TTL of the initial message remains in effect - Although browsing the queue will (incorrectly) show the TTL of the latest message.

To reproduce:

 * Send a message w/ ttl=5 LVQ_key=bar
 * Send another message w/ ttl=3600, LVQ_key=bar

The message will expire and get purged after 5s.

Expected behavior would be expiration after 3600s."
Bug,QPID-2191,12440030,Released message can hamper correct browsing of the queue,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If an acquired message is released, it is requeued out of position and
subsequent browsing of the queue is affected. 
"
Bug,QPID-3244,12506110,C++ broker should release flow control for a queue when it is deleted.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When deleting a queue that contains messages that are pending flow control, the flow control should be released."
Bug,QPID-978,12394917,memory leak in C++ broker,gsim,rpolzer,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"In a simple test program (basically, a qpid based echo server) used for measuring the latency of qpid, I get a severe memory leak - the 4GB RAM of this system are fully utilized after about two minutes.

Also, subscriptions.stop() does not work right (subscriptions.run() then appears to succeed, but will never receive a packet), which is why I had to throw an exception to get out of the Listener after a packet was received on the latency measuring client. I will try to attach a test program code for this."
Bug,QPID-4249,12604906,C++ Broker needs TopicExchange binding key lookup matching in all Acl rules,,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Ref: QPID-3892 and https://reviews.apache.org/r/5836/

Previous work added TopicExchange routing key matching to Acl lookup:
 PUBLISH EXCHANGE routingkey=X

This same logic needs to be added to:
  BIND   EXCHANGE routingkey=X
  UNBIND EXCHANGE routingkey=X
  ACCESS EXCHANGE routingkey=X

The problem with current Acl match processing is that an Acl rule like
  allow all BIND EXCHANGE routingkey=news.#

Will match only when a user literally uses routingkey=news.#
It will not match routingkey=news.usa nor =news.canada.toronto

This issue proposes to change the Acl match logic to treat all Acl rule
routingkey specifications as if they are TopicExchange patterns. User
requests match the Acl rule using TopicExchange pattern matching logic."
Bug,QPID-4032,12558696,"Broker does not accept sub-groups in group declaration, contrary to wiki documentation",chug,pcolby,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The ACL wiki page ([https://cwiki.apache.org/qpid/acl.html]) indicates by at least two examples, that group declarations can contain sub-groups.  However, Qpid 0.16 does not (seem to) allow this.

For example, given the following ACL file (cut down from the example at [https://cwiki.apache.org/qpid/acl.html#ACL-Examplefile%253A]):

{code}
# Some groups
group user-consume martin@QPID ted@QPID
group group2 kim@QPID user-consume rob@QPID
{code}

Qpid 0.16 gives the following error:

{{ACL format error: /home/paul/.qpidd/qpidd.acl:3: Line : 3, Username 'user-consume' must contain a realm}}

It appears that the broker is requiring {{user-consume}} to be a qualified user name such as {{user-consume@QPID}} and not realizing that it is a group name instead."
Bug,QPID-4269,12605472,Qpid windows service ignore service parameters,shuston,sviridov_alexey,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When installing qpid as windows service (i.e. by command qpidd.exe --install --arguments --no-data-dir) qpid create service with arguments. It's fine, while you don't try to start created service. When starting servce qpid starts, but ignore all params. To be honest there is way to start service with params (by specifying they in another place for params in service dialog (greeting windows!)) but for only one start, this params not saved after closing service properties dialog"
Bug,QPID-1438,12407959,Qpidd fails with the rdma transport module installed fails to start if the machine has no rdma devices,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,starting qpidd with an installed rdma trtansport module on a system with any rdma devices causes qpidd to faiil with a segv
Bug,QPID-4607,12634441,C++ Broker connection limits counting fails and self tests don't catch the errors,,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Two bugs in the source were found by code inspection. Upon fixing them then the self-tests started to fail.
Bug,QPID-3553,12528365,C++ broker does not handle multiple ConnectionTuneOk cleanly,gsim,siddhesh,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the C++ broker is sent ConnectionTuneOk more than once with heartbeat set, it creates that many timer tasks for the heartbeat. This will result in a case where a heartbeat task is triggered for a connection that has already been deleted.

Steps to reproduce:

1) Start broker:

MALLOC_MMAP_THRESHOLD_=8 qpidd

The MALLOC_MMAP_THRESHOLD_ is to catch the use-after-free immediately rather than having to depend on a heap corruption

2) Run the following python script:

import struct, time
from qpid.framing import OpEncoder, SegmentEncoder, FrameEncoder
from qpid.util import connect
from qpid.ops import *

def encode(op):
  print ""Sending:"", op
  op_enc = OpEncoder()
  seg_enc = SegmentEncoder()
  frame_enc = FrameEncoder()

  op_enc.write(op)
  seg_enc.write(*op_enc.read())
  frame_enc.write(*seg_enc.read())
  bytes = frame_enc.read()
  print ""  bytes:"", repr(bytes)
  return bytes

conn = connect(""127.0.0.1"", 5672)
conn.send(struct.pack(""!4s4B"", ""AMQP"", 1, 1, 0, 10))
conn.send(encode(ConnectionTuneOk(heartbeat=1)))
conn.send(encode(ConnectionTuneOk(heartbeat=1)))
conn.send(encode(ConnectionOpen(virtual_host=""vhost-blah"",channel=0)))
time.sleep(3)
"
Bug,QPID-2324,12444786,message_cancel should throw 404 not-found exception if subscription does not exist,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Fix message.MessageTests.test_cancel (last two lines) as well.
Bug,QPID-2364,12446739,Management updates in timer create inconsistencies in a cluster.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Management updates are triggered by a timer. They are not predictable for the
cluster and so can cause cluster shut-downs and inconsistent message delivery.

We have a hack in place that suppresses exceptions when the session receives
completions for transfers not yet sent (which is the usual manifestation of the
unpredictability). I.e. we have in essence disabled consistency checking for
management sessions. This solved immediate problems but would quickly stop
working if sessions/connections could be used for management and other things
(as will be more likely with QMFv2 where using management becomes quite
straightforward).    

In a cluster, management updates need to be synchronized by executing them in the cluster dispatch thread rather than a timer thread.

"
Bug,QPID-4546,12628634,Unable to delete federation routes or links if connection is not up,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Step 1) create a route using a -source- broker address that does not exist.
Step 2) Attempt to delete that route

Actual Result: route is never deleted, stuck in ""Waiting"" state

Expected Result: route should be deleted."
Bug,QPID-1446,12408162,Memory leak in qmf agent,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,QMF,,,,,,"There's a memory leak in the management agent code that affects both the remote agent and the broker.  If you repeatedly create and destroy queues, exchange, bindings, etc. on the broker, the memory usage will increase and not recover.
"
Bug,QPID-2649,12466364,Segfault on shutting down qpidd,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Seems to be more frequent if the broker has several very large queues at the time of shutdown; intermittent even then. Appears to be a result of the management agents timer task firing and accessing deleted objects.

(gdb) bt
#0  0x00000038f9c30265 in raise () from /lib64/libc.so.6
#1  0x00000038f9c31d10 in abort () from /lib64/libc.so.6
#2  0x00000038fccbec44 in __gnu_cxx::__verbose_terminate_handler ()
   from /usr/lib64/libstdc++.so.6
#3  0x00000038fccbcdb6 in ?? () from /usr/lib64/libstdc++.so.6
#4  0x00000038fccbcde3 in std::terminate () from /usr/lib64/libstdc++.so.6
#5  0x00000038fccbceca in __cxa_throw () from /usr/lib64/libstdc++.so.6
#6  0x0000003033eae2ab in qpid::sys::Mutex::lock ()
   from /usr/lib64/libqpidbroker.so.2
#7  0x0000003033fca1c3 in qpid::management::ManagementAgent::periodicProcessing
    () from /usr/lib64/libqpidbroker.so.2
#8  0x0000003033fcb32a in qpid::management::ManagementAgent::Periodic::fire ()
   from /usr/lib64/libqpidbroker.so.2
#9  0x00000030339e5b6b in qpid::sys::Timer::run ()
   from /usr/lib64/libqpidcommon.so.2
#10 0x00000030339146aa in ?? () from /usr/lib64/libqpidcommon.so.2
#11 0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#12 0x00000038f9cd3c2d in clone () from /lib64/libc.so.6
(gdb) thread apply all bt

Thread 3 (process 14409):
#0  0x00000038fa407955 in pthread_join () from /lib64/libpthread.so.0
#1  0x00000030339148b2 in qpid::sys::Thread::join ()
   from /usr/lib64/libqpidcommon.so.2
#2  0x00000030339e4236 in qpid::sys::Timer::stop ()
   from /usr/lib64/libqpidcommon.so.2
#3  0x00000030339e4674 in qpid::sys::Timer::~Timer ()
   from /usr/lib64/libqpidcommon.so.2
#4  0x0000003033ee33fd in qpid::broker::Broker::~Broker ()
   from /usr/lib64/libqpidbroker.so.2
#5  0x0000000000406a99 in ?? ()
#6  0x000000000040553f in __cxa_pure_virtual ()
#7  0x00000038f9c1d994 in __libc_start_main () from /lib64/libc.so.6
#8  0x0000000000404fb9 in __cxa_pure_virtual ()
#9  0x00007fff3b92d838 in ?? ()
#10 0x0000000000000000 in ?? ()

Thread 2 (process 14411):
#0  0x00000038fa40af70 in pthread_cond_timedwait@@GLIBC_2.3.2 ()
   from /lib64/libpthread.so.0
#1  0x00000030339e5f18 in qpid::sys::Timer::run ()
   from /usr/lib64/libqpidcommon.so.2
---Type <return> to continue, or q <return> to quit---
#2  0x00000030339146aa in ?? () from /usr/lib64/libqpidcommon.so.2
#3  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#4  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 1 (process 14410):
#0  0x00000038f9c30265 in raise () from /lib64/libc.so.6
#1  0x00000038f9c31d10 in abort () from /lib64/libc.so.6
#2  0x00000038fccbec44 in __gnu_cxx::__verbose_terminate_handler ()
   from /usr/lib64/libstdc++.so.6
#3  0x00000038fccbcdb6 in ?? () from /usr/lib64/libstdc++.so.6
#4  0x00000038fccbcde3 in std::terminate () from /usr/lib64/libstdc++.so.6
#5  0x00000038fccbceca in __cxa_throw () from /usr/lib64/libstdc++.so.6
#6  0x0000003033eae2ab in qpid::sys::Mutex::lock ()
   from /usr/lib64/libqpidbroker.so.2
#7  0x0000003033fca1c3 in qpid::management::ManagementAgent::periodicProcessing
    () from /usr/lib64/libqpidbroker.so.2
#8  0x0000003033fcb32a in qpid::management::ManagementAgent::Periodic::fire ()
   from /usr/lib64/libqpidbroker.so.2
#9  0x00000030339e5b6b in qpid::sys::Timer::run ()
   from /usr/lib64/libqpidcommon.so.2
#10 0x00000030339146aa in ?? () from /usr/lib64/libqpidcommon.so.2
#11 0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#12 0x00000038f9cd3c2d in clone () from /lib64/libc.so.6
(gdb)    "
Bug,QPID-3767,12538693,Federation link index becomes invalid on failover against a cluster.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The Link management object that represents a connection between two federated brokers is indexed (identified) by the remote broker's host and port.  If the remote broker is part of a cluster, and a failover event occurs, the host:port used by the Link object's index may no longer exist.  This prevents the route from being deleted.

For example, create a cluster of two brokers using addresses 127.0.0.1:2222 and 127.0.0.1:3333.  Start a third broker, say 127.0.0.1:8888.  Create a queue route from 127.0.0.1:2222 to an exchange on 127.0.0.1:8888.  Kill the broker 127.0.0.1:2222.   This results in a Link object that is connected to 127.0.0.1:3333, but reports 127.0.0.1:2222 as it's host. 

[kgiusti@localhost src]$ qpid-config -a 127.0.0.1:2222 add queue src
[kgiusti@localhost src]$ qpid-config -a 127.0.0.1:8888 add exchange fanout destx
[kgiusti@localhost src]$ qpid-config -a 127.0.0.1:8888 add queue dest
[kgiusti@localhost src]$ qpid-config -a 127.0.0.1:8888 bind destx dest
[kgiusti@localhost src]$ qpid-route queue add 127.0.0.1:8888 127.0.0.1:2222 destx src
[kgiusti@localhost src]$ ../examples/messaging/spout -b 127.0.0.1:2222 --content ""ZZZ"" src
[kgiusti@localhost src]$ ../examples/messaging/drain -b 127.0.0.1:8888 -t 2 dest
Message(properties={spout-id:8c308c74-6b25-4408-8694-93ef8352a308:0, x-amqp-0-10.routing-key:src}, content='ZZZ')

<Kill Broker 127.0.0.1:2222, link fails over to 127.0.0.1:3333>

 From qpid-tool:


qpid: show 133
Object of type: org.apache.qpid.broker:link:_data(bc33c1b3-25cd-e0ce-04d7-ad684ed36d91)
    Attribute  133
    =================================================
    vhostRef   150
    host       127.0.0.1
    port       2222
    transport  tcp
    durable    False
    state      Operational
    lastError  Failed over to tcp:10.16.185.15:3333


Once this occurs, I am unable to delete the link:

[kgiusti@localhost src]$ qpid-route queue del 127.0.0.1:8888 127.0.0.1:2222 destx src
[kgiusti@localhost src]$ qpid-tool 127.0.0.1:8888


qpid: list
Summary of Objects by Type:
    Package                 Class         Active  Deleted
    =======================================================
    org.apache.qpid.broker  binding       14      0
    org.apache.qpid.broker  system        1       0
    org.apache.qpid.broker  broker        1       0
    org.apache.qpid.broker  bridge        1       0
    org.apache.qpid.broker  link          1       0
    org.apache.qpid.broker  subscription  5       0
    org.apache.qpid.broker  connection    2       0
    org.apache.qpid.broker  session       2       0
    org.apache.qpid.broker  queue         6       0
    org.apache.qpid.broker  exchange      9       0
    org.apache.qpid.broker  vhost         1       0


"
Bug,QPID-1474,12408816,Calling PollerHandle::~PollerHandle() before Poller::wait() causes crash,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"This is because DeletionManager::markForDeletion() is called inside a lock before DeletionManager::markAllUnusedInThisThread() creates any thread specific state to attach the deletion to. The result is that markForDeletion ends up deleting the corresponding PollerHandlePrivate which causes a lock assertion.
"
Bug,QPID-1148,12399040,c++ broker: need abstraction layer for flock and lockf posix calls.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,The broker code uses posix calls lockf and flock for file locking. These calls need to be moved to abstraction classes in qpid::sys so that porting work (in particular to windows) can replace the implementations without having to refactor top-level broker code.
Bug,QPID-3120,12500616,Queue reroute doesn't honor alternate exchange,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When invoking the reroute method on a queue, messages delivered to an exchange are dropped instead of being delivered to the exchange's alternate exchange if no bindings match."
Bug,QPID-2253,12442866, Cluster node shutsdown with inconsistent error,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem:

When running the ""test_failover"" test case in the qpid-python-testkit framework
where cluster nodes are shutdown and new members are added, a new node just
joined encounters an error of the form ""confirmed N but only sent N-1"" which is
only raised on the said member causing it to shut down as inconsistent.


Version-Release number of selected component (if applicable):
qpid trunk

How reproducible:
Always

Steps to Reproduce:
1. checkout svn
2. build c++ broker and cluster module
3. go to java/testkit/bin and run ./qpid-python-testkit

Actual results:

cluster2-5: 2009-12-04 14:44:35 notice cluster(192.168.1.103:14491 READY)
caught up, active cluster member.
cluster2-5: 2009-12-04 14:44:36 error Execution exception: invalid-argument:
anonymous.e3a66a8d-330d-47c2-b96d-bb0b1315248b: confirmed < (2+0) but only sent
< (1+0) (qpid/SessionState.cpp:151)
cluster2-5: 2009-12-04 14:44:36 critical cluster(192.168.1.103:14491
READY/error) local error 599 did not occur on member 192.168.1.103:14453:
invalid-argument: anonymous.e3a66a8d-330d-47c2-b96d-bb0b1315248b: confirmed <
(2+0) but only sent < (1+0) (qpid/SessionState.cpp:151)
cluster2-5: 2009-12-04 14:44:36 error Error delivering frames: local error did
not occur on all cluster members : invalid-argument:
anonymous.e3a66a8d-330d-47c2-b96d-bb0b1315248b: confirmed < (2+0) but only sent
< (1+0) (qpid/SessionState.cpp:151) (qpid/cluster/ErrorCheck.cpp:89)
cluster2-5: 2009-12-04 14:44:36 notice cluster(192.168.1.103:14491 LEFT/error)
leaving cluster cluster2-helaya:13958
cluster2-5: 2009-12-04 14:44:36 notice Shut down


Expected results:
There should not be any inconsistent errors.
"
Bug,QPID-4448,12616961,Credit checking messages for sending on 0-10 of messages from 1.0 results in seg fault,astitcher,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,thus restricting 1.0->0-10 interop
Bug,QPID-4704,12640857,Legacy store is building as a shared library rather than a module,mcpierce,mcpierce,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,The store builds as a shared library rather than a module. A simple fix would be to change the library type in the Cmake build files to fix this issue.
Bug,QPID-4223,12603233,[New HA] Completion isn't sent when queue that has acquired but unacknowledged messages is deleted,aconway,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"When testing the new HA in 0.18 (from the svn branch, revision 1370693), I've run into a problem where I can't run qpid-cpp-benchmark after I shut down one of the backups.  Here's the scenario:

Start 3 brokers (in my test on 3 different hosts) using the following command line:

qpidd --auth no --load-module ha.so --ha-cluster yes --ha-brokers-url <insert url here> --ha-replicate all

Promote 1 of the brokers to primary.  Run qpid-cpp-benchmark with the default options.  The test should succeed and provide results.  Next, quit 1 of the 2 backups.  Finally, run qpid-cpp-benchmark again.  This time, it hangs.  Looking at the output of ""qpid-stat -q,"" I see there are some unacked messages that have been delivered to the running qpid-receive process."
Bug,QPID-2666,12466736,"[C++ broker linux] Service init script does not handle config file with ""log-to-file"" and a relative path",kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The service start script for linux (located in qpid/cpp/etc in svn) when installed will fail if the ""log-to-file"" option is set in the qpidd.conf file with a relative path (eg log-to-file=my-log.txt); however an absolute path works ok.

If a relative path is used, the script's use of ""qpidd --check"" to obtain the PID of the newly started qpid daemon will fail (as it will attempt to open a log file in a directory for which it does not have permissions); hence the pid file will be empty. An error message is printed, but the daemon starts ok. However, the missing PID means that attempting to stop the service will fail, and an administrator will have to find and stop the process manually."
Bug,QPID-4556,12630133,QueueOptions::setSizePolicy() can cause exception,gsim,brad.hoekstra,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Calling QueueOptions::setSizePolicy() with maxSize > 2GB causes an exception in the C++ broken, which then generates an exception in the C++ client library.

This appears to be because the value is set as an int32 in the FieldTable. The fix appears to be fairly simple:

{noformat} 
Index: 0.20/cpp/src/qpid/client/QueueOptions.cpp
===================================================================
--- 0.20/cpp/src/qpid/client/QueueOptions.cpp	(revision 27169)
+++ 0.20/cpp/src/qpid/client/QueueOptions.cpp	(revision 27170)
@@ -49,8 +49,8 @@
 	
 void QueueOptions::setSizePolicy(QueueSizePolicy sp, uint64_t maxSize, uint32_t maxCount)
 {
-    if (maxCount) setInt(strMaxCountKey, maxCount);
-    if (maxSize) setInt(strMaxSizeKey, maxSize);
+    if (maxCount) setUInt64(strMaxCountKey, maxCount);
+    if (maxSize) setUInt64(strMaxSizeKey, maxSize);
     if (maxSize || maxCount){
         switch (sp)
         {
{noformat} "
Bug,QPID-2473,12460553,current libraries: new options needed to link with,aconway,jasan,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The little attached patch is vital to make current trunk
(r928701) compile on Fedora Rawhide with Boost 1.41.0.

The other line adds libpthread linking option. It works
but you may want to add it elsewhere if you choose
to do so."
Bug,QPID-2366,12446860,Windows C++ broker port written to stdout at startup is wrong,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When the SSL additions for Windows were committed, the port number that the broker writes to stdout at startup changed from the TCP port to the SSL port. This confused the test suite and caused most of the tests to fail."
Bug,QPID-2570,12463858,"Broker uses NotAllowedException for ACL violations, should use UnauthorisedAccessException",gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The broker uses NotAllowedException[1] in most places when authorisation fails. This seems wrong to me as NotAllowedException is used for specific types of invalid command requests (e.g. declaring an existing exchange with a different type, or trying to create exchanges with prohibited prefixes). As it stands it is not possible to reliably distinguish between these two very different situations in code.

A more appropriate exception for authorisation failures would be UnauthorisedAccessException[2] which is only used in one place (when a message is sent with a userid that differs from the authenticated id).

Obviously this breaks backwards compatibility to a degree, but I think in this case it is justified. At worst it would require applications to reconsider catching UnauthorizedAccessException wherever they are currently explicitly catching NotAllowedException.

[1] Described in specification as indicating: ""The peer tried to use a command a manner that is inconsistent with the rules described in the specification.""

[2] Described in specification as indicating: ""The client attempted to work with a server entity to which it has no access due to security settings.""
"
Bug,QPID-628,12379971,Broker deletes durable queues on connection closure.,gsim,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"asimon@redhat.com says:

I have attached a broker log. It shows that the broker tries to delete a
durable queue when the connection that was used to create it is closed.
This means that when we afterward try to query the broker about this
queue it always answers that this queue does not exist. I have the
feeling that this could well be an issue with the broker. 

 ./qpidd -t
2007-Oct-09 18:37:31 info Persistence not enabled, no recovery attempted.
2007-Oct-09 18:37:31 info Listening on port 5672
2007-Oct-09 18:37:40 debug INIT [0x833ce10]
2007-Oct-09 18:37:40 debug SENT: Frame[channel=0; ConnectionStartBody: version-major=0; version-minor=10; server-properties={}; mechanisms=PLAIN; locales=en_US]
2007-Oct-09 18:37:40 debug RECV: Frame[channel=0; ConnectionStartOkBody: client-properties={}; mechanism=PLAIN; response=guestguest; locale=utf8]
2007-Oct-09 18:37:40 debug SENT: Frame[channel=0; ConnectionTuneBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:40 debug RECV: Frame[channel=0; ConnectionTuneOkBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:40 debug RECV: Frame[channel=0; ConnectionOpenBody: virtual-host=test; capabilities=; insist=1]
2007-Oct-09 18:37:40 debug SENT: Frame[channel=0; ConnectionOpenOkBody: known-hosts=]
2007-Oct-09 18:37:40 debug INIT [0x837e0a0]
2007-Oct-09 18:37:40 debug SENT: Frame[channel=0; ConnectionStartBody: version-major=0; version-minor=10; server-properties={}; mechanisms=PLAIN; locales=en_US]
2007-Oct-09 18:37:40 debug RECV: Frame[channel=1; SessionOpenBody: detached-lifetime=0]
2007-Oct-09 18:37:40 debug RECV: Frame[channel=1; ExchangeDeclareBody: ticket=0; exchange=amq.topic; type=topic; alternate-exchange=; passive=0; durable=0; auto-delete=0; arguments={}]
2007-Oct-09 18:37:40 debug SENT: Frame[channel=1; SessionAttachedBody: session-id=abfb321b-9e9f-4d99-880c-a5be2505e235; detached-lifetime=0]
2007-Oct-09 18:37:41 debug RECV: Frame[channel=0; ConnectionStartOkBody: client-properties={}; mechanism=PLAIN; response=guestguest; locale=utf8]
2007-Oct-09 18:37:41 debug SENT: Frame[channel=0; ConnectionTuneBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:41 debug RECV: Frame[channel=0; ConnectionTuneOkBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:41 debug RECV: Frame[channel=0; ConnectionOpenBody: virtual-host=test; capabilities=; insist=1]
2007-Oct-09 18:37:41 debug SENT: Frame[channel=0; ConnectionOpenOkBody: known-hosts=]
2007-Oct-09 18:37:41 debug RECV: Frame[channel=1; SessionOpenBody: detached-lifetime=0]
2007-Oct-09 18:37:41 debug SENT: Frame[channel=1; SessionAttachedBody: session-id=e3cffef4-47f6-463f-883a-1d98261d9af0; detached-lifetime=0]
2007-Oct-09 18:37:42 debug RECV: Frame[channel=1; BindingQueryBody: ticket=0; exchange=amq.topic; queue=clientid:subscription0; routing-key=; arguments={}]
2007-Oct-09 18:37:42 debug SENT: Frame[channel=1; ExecutionResultBody: command-id=0; data=占?           ]
2007-Oct-09 18:37:42 debug RECV: Frame[channel=1; ExchangeDeclareBody: ticket=0; exchange=amq.topic; type=topic; alternate-exchange=; passive=0; durable=0; auto-delete=0; arguments={}]
2007-Oct-09 18:37:42 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:42 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=1; ranged-execution-set={}]
2007-Oct-09 18:37:42 debug RECV: Frame[channel=1; BindingQueryBody: ticket=0; exchange=; queue=clientid:subscription0; routing-key=; arguments={}]
2007-Oct-09 18:37:42 debug SENT: Frame[channel=1; ExecutionResultBody: command-id=2; data=占?           ]
2007-Oct-09 18:37:54 debug RECV: Frame[channel=1; QueueDeclareBody: ticket=0; queue=clientid:subscription0; alternate-exchange=; passive=0; durable=1; exclusive=1; auto-delete=0; arguments={}]
2007-Oct-09 18:37:54 info Can't create durable queue 'clientid:subscription0'. Persistence not enabled.
2007-Oct-09 18:37:54 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:54 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=3; ranged-execution-set={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; BindingQueryBody: ticket=0; exchange=amq.topic; queue=clientid:subscription0; routing-key=MyTopic3; arguments={}]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; ExecutionResultBody: command-id=4; data=占?
           ]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; QueueBindBody: ticket=0; queue=clientid:subscription0; exchange=amq.topic; routing-key=MyTopic3; arguments={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=5; ranged-execution-set={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageSubscribeBody: ticket=0; queue=clientid:subscription0; destination=1; no-local=0; confirm-mode=1; acquire-mode=0; exclusive=0; filter={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageFlowModeBody: destination=1; mode=1]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=7; ranged-execution-set={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageFlowBody: destination=1; unit=0; value=100]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageFlowBody: destination=1; unit=1; value=4294967295]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=9; ranged-execution-set={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageTransferBody: ticket=0; destination=amq.topic; confirm-mode=0; acquire-mode=0]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; header (133 bytes); properties={DeliveryProperties: discard-unroutable=0; redelivered=0; priority=0; delivery-mode=2; ttl=0; timestamp=1191947876587; expiration=0; exchange=amq.topic; routing-key=MyTopic3MessageProperties: content-length=0; message-id=ID:cca34fe3-3350-4530-a50d-60937e88f10a; correlation-id=; reply-to=ReplyTo: exchange-name=; routing-key=; content-type=text/plain; content-encoding=; type=; user-id=; app-id=; transaction-id=; security-token=; application-headers={}}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; content (5 bytes) Hello...]
2007-Oct-09 18:37:56 info Can't enqueue message onto 'clientid:subscription0'. Persistence not enabled.
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; MessageTransferBody: ticket=0; destination=1; confirm-mode=1; acquire-mode=0]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; header (133 bytes); properties={DeliveryProperties: discard-unroutable=0; redelivered=0; priority=0; delivery-mode=2; ttl=0; timestamp=1191947876587; expiration=0; exchange=amq.topic; routing-key=MyTopic3MessageProperties: content-length=0; message-id=ID:cca34fe3-3350-4530-a50d-60937e88f10a; correlation-id=; reply-to=ReplyTo: exchange-name=; routing-key=; content-type=text/plain; content-encoding=; type=; user-id=; app-id=; transaction-id=; security-token=; application-headers={}}]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; content (5 bytes) Hello...]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageCancelBody: destination=1]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; ExecutionSyncBody: ]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=1; ExecutionCompleteBody: cumulative-execution-mark=10; ranged-execution-set={}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; SessionCloseBody: ]
2007-Oct-09 18:37:56 info Received session.close
2007-Oct-09 18:37:56 debug RECV: Frame[channel=0; ConnectionCloseBody: reply-code=0; reply-text=client is closing; class-id=0; method-id=0]
2007-Oct-09 18:37:56 info Can't destroy durable queue 'clientid:subscription0'. Persistence not enabled.
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; MessageTransferBody: ticket=0; destination=amq.topic; confirm-mode=0; acquire-mode=0]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; header (133 bytes); properties={DeliveryProperties: discard-unroutable=0; redelivered=0; priority=0; delivery-mode=2; ttl=0; timestamp=1191947876722; expiration=0; exchange=amq.topic; routing-key=MyTopic3MessageProperties: content-length=0; message-id=ID:cf6ac83b-363c-403c-9691-5b80e8abd334; correlation-id=; reply-to=ReplyTo: exchange-name=; routing-key=; content-type=text/plain; content-encoding=; type=; user-id=; app-id=; transaction-id=; security-token=; application-headers={}}]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=1; content (6 bytes) Hello2...]
2007-Oct-09 18:37:56 debug INIT [0x837e568]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=0; ConnectionStartBody: version-major=0; version-minor=10; server-properties={}; mechanisms=PLAIN; locales=en_US]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=0; ConnectionStartOkBody: client-properties={}; mechanism=PLAIN; response=guestguest; locale=utf8]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=0; ConnectionTuneBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=0; ConnectionTuneOkBody: channel-max=32767; frame-max=65536; heartbeat=0]
2007-Oct-09 18:37:56 debug RECV: Frame[channel=0; ConnectionOpenBody: virtual-host=test; capabilities=; insist=1]
2007-Oct-09 18:37:56 debug SENT: Frame[channel=0; ConnectionOpenOkBody: known-hosts=]


q"
Bug,QPID-918,12393887,"Authentication password is logged when ""trace"" is enabled",,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If trace is enabled on the broker, the ""response"" field of a ""Start-Ok"" method is logged.  This field contains the authentication password in clear text.
"
Bug,QPID-2474,12460602,ACL file reader can trip vector iter validity checking,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The ACL file reading can trigger Windows Visual C++ consistency check on vector iterator decrement.

Running the C++ test suite's acl_test starts a broker with options:
--data-dir C:/qpid/trunk/build/src/tests/data_dir --acl-file policy.acl --auth no

This policy.acl file contains only:
acl allow all all

This trips VC checks in qpid::acl::AclReader::loadDecisionData(boost::shared_ptr<qpid::acl::AclData> d={...}) because the 'for' loop at line 92:
	for (rlCitr i = rules.end() - 1; cnt; i--, cnt--) {
tries to back i off the beginning of the vector.

"
Bug,QPID-4257,12605103,"Windows+SSL: Client hang on broker close, broker memory leak",,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Windows clients hang when broker dies via SSL connection - fetch never returns even w/ IMMEDIATE timeout.
Windows broker memory grows linearly with SSL connection count, leak per connection, until broker exhausts memory and crashes."
Bug,QPID-2440,12458634,clustered qpid: exchanges at 2nd broker not shown by qpid tools,kpvdr,xeop-nollarm,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"We run the brokers on nodes RGC001 and RGC002, both with the following configuration:
 
log-enable=info+
log-to-file=/var/lib/qpidd/data/15399/qpidd.log
log-to-syslog=no
auth=yes
acl-file=qpidd.acl
realm=QPID15399
data-dir=/var/lib/qpidd/data/15399
pid-dir=/var/lib/qpidd/data/15399
port=15399
num-jfiles=4
jfile-size-pgs=1
tpl-num-jfiles=4
tpl-jfile-size-pgs=1
cluster-name=QPID15399
cluster-url=amqp:tcp:RGC001:15399
### on machine RGC002 the URL is amqp:tcp:RGC002:15399
cluster-username=admin
cluster-password=admin
 
I start the broker on RGC001 and add an exchange and a queue:
 
RGC001 $ qpid-config -a admin/admin@localhost:15399 add exchange direct eurex.EXCHANGE --durable
RGC001 $ qpid-config -a admin/admin@localhost:15399 add queue eurex.QUEUE --durable --limit-policy reject --max-queue-count 10
 
These can be listed e.g. by qpid-config:
 
RGC001 $ qpid-config -a admin/admin@localhost:15399 queues eurex
Queue Name   Attributes
===================================
eurex.QUEUE  --durable --file-size=24 --file-count=8 --max-queue-count=10 --limit-policy=reject
 
RGC001 $ qpid-config -a admin/admin@localhost:15399 exchanges eurex
Type      Exchange Name   Attributes
=============================================
direct    eurex.EXCHANGE  --durable
 
Now I start the broker on RGC002 and check whether qpid-config shows me the queue and the exchange:
 
RGC002 $ qpid-config -a admin/admin@localhost:15399 queues eurex
Queue Name   Attributes
===================================
eurex.QUEUE  --durable --file-size=24 --file-count=8 --max-queue-count=10 --limit-policy=reject
 
RGC002 $ qpid-config -a admin/admin@localhost:15399 exchanges eurex
Type      Exchange Name   Attributes
=============================================
 
I.e. already in this simple scenario there is a problem with the exchanges.
The exchange is also not shown by qpid-stat and qpid-tool.
 
Now I ran qpid-cluster to check whether the brokers see each other, first on RGC001:
 
RGC001 $ qpid-cluster admin/admin@RGC001:15399
  Cluster Name: QPID15399
Cluster Status: ACTIVE
  Cluster Size: 2
       Members: ID=192.168.178.1:15051 URL=amqp:tcp:RGC001:15399
              : ID=192.168.178.2:24407 URL=amqp:tcp:RGC002:15399
 
Now on RGC002:
 
RGC002 $ qpid-cluster admin/admin@RGC002:15399
  Cluster Name: QPID15399
Cluster Status: ACTIVE
  Cluster Size: 2
       Members: ID=192.168.178.1:15051 URL=amqp:tcp:RGC001:15399
              : ID=192.168.178.2:24407 URL=amqp:tcp:RGC002:15399
 
Finally, to show that the exchange still exists in broker on RGC002, I try to create it but now with type topic:
 
RGC002 $ qpid-config -a admin/admin@localhost:15399 add exchange topic eurex.EXCHANGE --durable
Failed: SessionException - exception(error_code=530, command_id=serial(56), class_code=7, command_code=1, field_index=0, description=u'not-allowed: Exchange declared to be of type direct, requested topic (qpid/broker/SessionAdapter.cpp:116)', error_info={})

This problem has also been reported as Red Hat service request #1960092. "
Bug,QPID-1558,12411741,Reject ACL file if user names does not contain a realm,rajith,rajith,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"As per the discussion on QPID-1545, it was decided that we should reject an ACL file which contains user names without a realm."
Bug,QPID-1671,12415351,Client side of inter-broker links has no identity associated with connection,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"So when the destination broker (for a pull bridge) processes an incoming transfer (sent in response to a subscribe), Connection::getClientId() returns the empty string."
Bug,QPID-245,12359741,Java client hangs with C++ broker,,rgreig,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,JMS AMQP 0-x,,,,,,"Run a C++ broker, and any java client.

During the connection phase the broker emits:
---------------0x545a80
St9exception

The client outputs:

main 2007-01-03 21:26:29,477 INFO [qpid.client.transport.SocketTransportConnection] Attempting connection to localhost/127.0.0.1:5673
AnonymousIoService-1 2007-01-03 21:26:29,738 INFO [qpid.client.security.CallbackHandlerRegistry] Available SASL mechanisms: CRAM-MD5 PLAIN
"
Bug,QPID-243,12359738,Inconsistent use of paths in #includes,astitcher,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"
1. With the new release, I have to specify -I${QPID_REL}/include/qpidc,
-I${QPID_REL/include/qpidc/framing and -I${QPID_REL/include/qpidc/sys when
I build which is really naff.

This is because things like Connector.h do a #include
<framing/InputHandler.h>, but then ""framing/InputHandler.h"" only #include
<AMQFrame.h> and AMQFrame.h is located in the framing sub-directory.

"
Bug,QPID-3958,12551463,queue replication fails for messages with empty content frames,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"E.g. Generating messages via Java client and org.apache.qpid.example.Spout program
to a queue that is replicated to another broker fails with:

2012-04-18 08:46:30 error Connection 10.34.1.187:5672-10.34.1.197:49434 closed
by error: Unexpected command continuation frame.
(qpid/SessionState.cpp:68)(501)
"
Bug,QPID-1442,12408024,C++ broker performs smart completion of environment vars.,,ritchiem,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Summary:

If I have an env var QPID_WORK set and start the c++ broker it attempts to read the value as the 'worker-threads' value. 
If the value of QPID_WORK is set to an integer then things work as expected for c++ but not the Java broker. 

$ export QPID_WORK=""<VALUE OF QPID_WORK>""
$./qpidd --help
Error in environment variables: in option 'worker-threads': invalid option value '<VALUE OF QPID_WORK>'
Use --help to see valid options

"
Bug,QPID-2407,12456346,C++ SSL session can get bad buffer management,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Thanks to Cliff Jansen for alerting me to this problem.

It's possible for an SSL-negotiated session on Windows to end up with odd errors or an exception. One session I caught in the debugger ended with a ENOBUFS errors on a network receive; the buffer involved ended up having a data-start greater than the length of the buffer, and the calculated receive length for the operation was a negative value.

Can be reproduced using perftest on Windows; I ran against a Linux broker, but similar results can probably happen in either direction depending on the traffic pattern."
Bug,QPID-2297,12443774,"ACL policy won't allow ""."" in the realm for users added to a group",rajith,timpowers,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The following throws an error when it's included in the acl policy file because of the ""."" in the realm:

group admins username@EXAMPLE.COM

The following works properly and is allowed:

acl allow-log username@EXAMPLE.COM all
"
Bug,QPID-2076,12434192,C++ Broker assumes it can delete a pointer passed by message store plugin,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The 0.5 broker/message-store plugin arrangement has the plugin allocating an object derived from MessageStore and calling qpid::broker::Broker::setStore(MessageStore*) to allow the broker's normal operation to invoke methods through the pointer.

The passed MessageStore pointer is stored in a std::auto_ptr and the Broker destruction deletes the store. This is not valid in all cases. Particularly, on Windows, different DLLs can have different heaps. Memory allocated in one DLL (such as a plugin) can often not be deleted from a different DLL or executable (such as the broker) - it looks like freeing memory which was never allocated.

It also may be desireable in some cases to pass a pointer to qpid::broker::Broker::setStore() that is not dynamically allocated.

I propose changing the store pointer in qpid::broker::Broker from std::auto_ptr to boost::shared_ptr - this will allow the constructing DLL to control if, when, and how the memory is released."
Bug,QPID-556,12376618,c++ qpidd -d -s does not work in rmh/bdbstore build.,,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Starting qpidd with both --daemon and --store does not work when used in rhm/tests/system_test.sh called from the rhm make check.
It *does* work when called directly from the command line.
"
Bug,QPID-3963,12551622,A federated broker may not reconnect to a remote cluster on link failure.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"When a broker is federated with a cluster, the cluster informs the broker of the failover addresses that are valid for the cluster.  Should a cluster member fail, the broker will reconnect to another member of that cluster.

However, the federated broker only queries the cluster for these failover addresses when it first connects to the cluster.  Should the cluster topology change, the federated broker's list of available failover addresses will become out-of-date.  This can prevent the broker from correctly re-connecting on failure of a cluster member.

Example:
Given cluster with members C1 and C2, and a separate broker B, federate B to connect to C1.   On connecting to C1, B learns the addresses of C2 as an alternate failover address.  Now shutdown C1.  B will reconnect to C2, and learn that C2 is the only member of the cluster (ie. no failover addresses).   After B connects, restart C1 and let it join the cluster.  Then shutdown C2.   Since B does not know that C1 has become available again, B will not attempt to re-connect to it.  Instead, it tries to reconnect to C2 indefinately.

The expected behavior would be to have B reconnect to C1."
Bug,QPID-2728,12468955,Windows icon/version additions broke nightly builds,tross,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Recent additions to include version and icon resources in the Windows builds result in build errors. I don't know why I'm getting different errors on different builds, but here's what I see:

64-bit build:
One of these for each library:
1>.\windows\resources\qpidtypes-resource.rc(20) : fatal error RC1015: cannot open include file 'version-resource.h'.

See: http://www.riverace.com/CDash-1.4.2/viewBuildError.php?buildid=735 for all messages

32-bit build (configure error):
CMake Error in src/CMakeLists.txt:
  Cannot find source file ""qmf-resource.rc"".  Tried extensions .c .C .c++ .cc
  .cpp .cxx .m .M .mm .h .hh .h++ .hm .hpp .hxx .in .txx

"
Bug,QPID-3455,12520237,Large message sent over sasl_wrapper encryption layer causes infinite loop in broker,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,This is a result of an incorrectly set max-frame-size on the broker. The buffer used for decoding after decryption is therefore too small and the frame cannot be decoded.
Bug,QPID-1559,12411821,M4 RC6 Visual Studio projects missing some generated code file names,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The set of generated C++ files changed between RC5 and RC6, which causes compile failures in the Windows build. The project files must be regenerated to find the correct set of generated C++ sources."
Bug,QPID-3140,12501335,Invalid handling of qpid.max_size,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The argument processing code retrieves the value as a uint32 although the size in the queue policy is a uint64, this means that larger values of queue size cannot be specified."
Bug,QPID-3877,12544848,Modifying a message's headers may cause a broker crash.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Adjusting the message's TTL header can cause a crash if another thread is attempting to encode the same message.  The below trace is from valgrind while the store is in use:

==15071== Thread 4:
==15071== Invalid read of size 8
==15071==    at 0x52661F0: qpid::framing::DeliveryProperties::bodySize() const (DeliveryProperties.cpp:198)
==15071==    by 0x5266248: qpid::framing::DeliveryProperties::encodedSize() const (DeliveryProperties.cpp:209)
==15071==    by 0x52CC3D4: qpid::framing::AMQHeaderBody::encodedSize() const (AMQHeaderBody.h:45)
==15071==    by 0x52CAFEE: qpid::framing::AMQFrame::encodedSize() const (AMQFrame.cpp:46)
==15071==    by 0x4DB3B55: qpid::broker::Message::encodedHeaderSize() const (frame_functors.h:39)
==15071==    by 0x5C1FBFC: mrg::msgstore::MessageStoreImpl::msgEncode(std::vector<char, std::allocator<char> >&, boost::intrusive_ptr<qpid::broker::PersistableMessage> const&) (Messag\
eStoreImpl.cpp:1311)
==15071==    by 0x5C31E8D: mrg::msgstore::MessageStoreImpl::store(qpid::broker::PersistableQueue const*, mrg::msgstore::TxnCtxt*, boost::intrusive_ptr<qpid::broker::PersistableMessage\
> const&, bool) (MessageStoreImpl.cpp:1331)
==15071==    by 0x5C32A0B: mrg::msgstore::MessageStoreImpl::enqueue(qpid::broker::TransactionContext*, boost::intrusive_ptr<qpid::broker::PersistableMessage> const&, qpid::broker::Per\
sistableQueue const&) (MessageStoreImpl.cpp:1303)
==15071==    by 0x4DBE65F: qpid::broker::MessageStoreModule::enqueue(qpid::broker::TransactionContext*, boost::intrusive_ptr<qpid::broker::PersistableMessage> const&, qpid::broker::Pe\
rsistableQueue const&) (MessageStoreModule.cpp:125)
==15071==    by 0x4DCFF31: qpid::broker::Queue::enqueue(qpid::broker::TransactionContext*, boost::intrusive_ptr<qpid::broker::Message>&, bool) (Queue.cpp:811)
==15071==    by 0x4DD1951: qpid::broker::Queue::deliver(boost::intrusive_ptr<qpid::broker::Message>) (Queue.cpp:171)
==15071==    by 0x4D798DE: qpid::broker::DeliverableMessage::deliverTo(boost::shared_ptr<qpid::broker::Queue> const&) (DeliverableMessage.cpp:33)
==15071==  Address 0xca1d548 is 56 bytes inside a block of size 248 free'd
==15071==    at 0x4A0545F: operator delete(void*) (vg_replace_malloc.c:387)
==15071==    by 0x52CB195: qpid::framing::AMQFrame::cloneBody() (RefCounted.h:42)
==15071==    by 0x4DB37DE: qpid::broker::Message::getHeaderBody() (Message.cpp:351)
==15071==    by 0x4DB7471: qpid::framing::DeliveryProperties* qpid::broker::Message::getModifiableProperties<qpid::framing::DeliveryProperties>() (Message.h:208)
==15071==    by 0x4DB65E7: qpid::broker::Message::adjustTtl() (Message.cpp:416)
==15071==    by 0x4D7BB60: qpid::broker::DeliveryRecord::deliver(qpid::framing::Handler<qpid::framing::AMQFrame&>&, qpid::framing::SequenceNumber, unsigned short) (DeliveryRecord.cpp:\
80)
==15071==    by 0x4E1A9B9: qpid::broker::SessionState::deliver(qpid::broker::DeliveryRecord&, bool) (SessionState.cpp:380)
==15071==    by 0x4DFD345: qpid::broker::SemanticState::ConsumerImpl::deliver(qpid::broker::QueuedMessage&) (SemanticState.cpp:342)
==15071==    by 0x4DD519C: qpid::broker::Queue::dispatch(boost::shared_ptr<qpid::broker::Consumer>) (Queue.cpp:393)
==15071==    by 0x4E00759: qpid::broker::SemanticState::ConsumerImpl::doOutput() (SemanticState.cpp:741)
==15071==    by 0x52F174C: qpid::sys::AggregateOutput::doOutput() (AggregateOutput.cpp:59)
==15071==    by 0x4D6FC18: qpid::broker::Connection::doOutput() (Connection.cpp:354)
==15071==

Gordon correctly points out that the message lock must be held while the headers are being encoded.
"
Bug,QPID-603,12378477,c++ trunk broker crashes with 0-8 client.,,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Broker crashes if you run the 0-8 python tests. It should close the connection indicating an unsupported version as specified by AMQP.
Bug,QPID-2372,12446922,PeriodicTimerImpl addition broker Windows build,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Windows builds broke with error:
5>Broker.obj : error LNK2019: unresolved external symbol ""public: __cdecl qpid::sys::PeriodicTimerImpl::PeriodicTimerImpl(class qpid::sys::Timer &)"" (??0PeriodicTimerImpl@sys@qpid@@QEAA@AEAVTimer@12@@Z) referenced in function ""public: __cdecl qpid::broker::Broker::Broker(struct qpid::broker::Broker::Options const &)"" (??0Broker@broker@qpid@@QEAA@AEBUOptions@012@@Z)

Possibly PeriodicTimerImpl.cpp not added to cmake?"
Bug,QPID-2326,12444796,exchange.declare should throw a 404 - not found exception if the exchange type is unknown,gsim,rgodfrey,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,Python Test Suite,,,,,,"The C++ Broker returns a 503 error when an exchange is declared as being of a type which the broker does not recognize, and the python test ""testTypeNotKnown"" in exchange.py tests for this behaviour

However the AMQP0-10 spec (pg 217 of the PDF) says

Exception: exchange-type-not-found
 Error:        not-found
If the client attempts to create an exchange which the server does not recognize, an exception MUST be sent.

not-found is error code 404"
Bug,QPID-123,12356393,Sporadic failure on Python tests,gsim,cctrieloff,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"======================================================================
FAIL: test_ack (tests.basic.BasicTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/home/cctrieloff/apache/qpid/trunk/qpid/python/tests/basic.py"", line 167, in test_ack
    self.assertEqual(""One"", msg1.content.body)
AssertionError: 'One' != 'Three'

======================================================================
FAIL: test_recover_requeue (tests.basic.BasicTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File ""/home/cctrieloff/apache/qpid/trunk/qpid/python/tests/basic.py"", line 211, in test_recover_requeue
    self.assertEqual(""One"", msg1.content.body)
AssertionError: 'One' != 'Three'

----------------------------------------------------------------------
Ran 43 tests in 92.811s

FAILED (failures=2)"
Bug,QPID-2487,12461534,Tearing down one dynamic route may delete other independent routes in the federation.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Tearing down one dynamic federated route can cause other unrelated routes to be torn down if they involve the same queue.

Will attach a test script that exhibits the bug.

Originally found by Gordon Sim."
Bug,QPID-1545,12411054,ACL failure,rajith,arnaudsimon,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The c++ broker segfaults when an ACL file contains a group with a single user that has the same name as the group.
Ex ""group admin admin"""
Bug,QPID-4268,12605409,C++ Broker needs Acl support for limiting on-disk store,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The C++ Broker currently has Acl support for limiting the in-memory size of a queue and the maximum number of messages that the queue may contain.

When creating a queue a user may specify options qpid.max_size and qpid.max_count. Acl support exists to specify properties:
  queuemaxsizeupperlimit,  queuemaxsizelowerlimit,
  queuemaxcountupperlimit, queuemaxcountlowerlimit
to constrain the bounds of a queue that a user may create.

This jira issue adds similar support for options qpid.file_size and qpid.file_count. The Acl support shall add properties:
  filemaxsizeupperlimit,  filemaxsizelowerlimit,
  filemaxcountupperlimit, filemaxcountlowerlimit
to similarly constrain the file store settings.

This jira does NOT add new options to queue creation. Tool qpid-config already specifies these options and the broker and store process them. The jira simply provides a method for administrators to constrain users file settings.
"
Bug,QPID-3799,12540908,ACL processing by C++ broker produces unexpected results,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"There are several instances of C++ ACL-processing code that produce results that do not match what would be expected after reading the Developer Pages, ACL site page. Clean up of both the site page and the code in a few cases requires an agreement on the actual desired behaviour.

Some of the rule sets below are contrived and not something that a normal person would write. However, rule sets may be machine generated or they may be in a confused state due to cut and paste errors. Rule processing must be predictable regardless of how the rule sets came to be.

1. Conflicting permissions rules. Given the following rule set[1]:
    acl allow bob@QPID create queue
    acl deny  bob@QPID create queue
    acl allow all all

What happens when bob tries to create a queue? The site page suggests that the rules are processed in order and the first rule that matches defines the action to take. By that reading bob should be allowed to create a queue. In the C++ broker, however, the first 'acl allow' rule is discarded. Then the first rule to match is the deny rule.

Q1: What is the correct behaviour for the conflicting rules in rule set 1?


2. ACL lines greater that 1000 characters are silently truncated. ACL processing should stop and emit an error if lines are too long.


3. The C++ broker handles some numeric limits on queue creation but these limits are not documented in the wiki page.

We have the following rule set[2]:
       1. acl allow bob create queue maxqueuesize=1000
       2. acl deny  bob all    all

Line 1 allows bob to create queues as long as the qpid.max_size
argument in the queue_declare request is<= 1000.
Line 2 prevents bob from doing anything else.

We have another rule set[3]:
       1. acl allow bob create queue maxqueuesize=1000
       2. acl allow bob create queue maxqueuesize=10000
       3. acl deny  bob all    all

What happens when ACL processing gets to Line 1 when bob tries to create a queue with max_size = 2000? Line 1 disallows the creation but Line 2 allows it.
     * If code treats the numeric tests as another ""comparison criteria"" then Line 1 will not match. This allows processing to move to Line 2 where the action will be allowed.
     * If the code treats the numeric tests as a ""deny subclause"" then Line 1 will be a match and bob will be denied.

Q3: What should happen when bob tries to create a queue with max_size = 2000 using rule set [3]?

4. Numeric limits should work differently on deny rules[4].

       1. acl deny  bob create queue maxqueuesize=1000
       2. acl allow bob all    all

I suggest that when the numeric tests specifying max values are used as ""comparison criteria"" then:
  * In an allow rule the match is true when the user's value is ""less than or equal to"" the ACL max limit.
  * In a deny rule the match is true when the user's value is ""greater than"" the ACL max limit.

Q4: How should numeric limits be applied in deny rules?

I'm interested to know what folks think is the ""correct"" behaviour for these rules and/or how the Java broker would handle them.
"
Bug,QPID-1852,12425230,Logger::log isn't thread safe (by inspection),astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"In source file cpp/src/qpid/log/Logger.h Logger::log() uses the function localtime which is not thread saf

localtime() needs to be replaced with localtime_r() for threadsafety.

Incidentally sprintf() and most of the rest of the function can be replaced with strftime()."
Bug,QPID-4180,12600921,Occasional Buffer leak in qpidd,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Occasionally when running the tests with valgrind (make check) the stop_broker test fails with a memory leak of one IO buffer:

==13674== HEAP SUMMARY:
==13674==     in use at exit: 73,479 bytes in 188 blocks
==13674==   total heap usage: 4,794,669 allocs, 4,794,481 frees, 402,637,196 bytes allocated
==13674== 
==13674== 65,568 (32 direct, 65,536 indirect) bytes in 1 blocks are definitely lost in loss record 188 of 188
==13674==    at 0x4A06C8E: operator new(unsigned long) (vg_replace_malloc.c:261)
==13674==    by 0x535EDF4: qpid::sys::AsynchIOHandler::init(qpid::sys::AsynchIO*, qpid::sys::Timer&, unsigned int, int) (AsynchIOHandler.cpp:93)
==13674==    by 0x4EA98C1: qpid::sys::AsynchIOProtocolFactory::established(boost::shared_ptr<qpid::sys::Poller>, qpid::sys::Socket const&, qpid::sys::ConnectionCodec::Factory*, bool) (TCPIOPlugin.cpp:169)
==13674==    by 0x4EABF69: boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf4<void, qpid::sys::AsynchIOProtocolFactory, boost::shared_ptr<qpid::sys::Poller>, qpid::sys::Socket const&, qpid::sys::ConnectionCodec::Factory*, bool>, boost::_bi::list5<boost::_bi::value<qpid::sys::AsynchIOProtocolFactory*>, boost::_bi::value<boost::shared_ptr<qpid::sys::Poller> >, boost::arg<1>, boost::_bi::value<qpid::sys::ConnectionCodec::Factory*>, boost::_bi::value<bool> > >, void, qpid::sys::Socket const&>::invoke(boost::detail::function::function_buffer&, qpid::sys::Socket const&) (mem_fn_template.hpp:494)
==13674==    by 0x528623D: qpid::sys::posix::AsynchAcceptor::readable(qpid::sys::DispatchHandle&) (function_template.hpp:1013)
==13674==    by 0x5364582: boost::function1<void, qpid::sys::DispatchHandle&>::operator()(qpid::sys::DispatchHandle&) const (function_template.hpp:1013)
==13674==    by 0x53636D0: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (DispatchHandle.cpp:280)
==13674==    by 0x5293491: qpid::sys::Poller::run() (Poller.h:131)
==13674==    by 0x528B9B9: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==13674==    by 0x388FE07850: start_thread (in /lib64/libpthread-2.12.so)
==13674==    by 0x388F6E76DC: clone (in /lib64/libc-2.12.so)
==13674== 
==13674== LEAK SUMMARY:
==13674==    definitely lost: 32 bytes in 1 blocks
==13674==    indirectly lost: 65,536 bytes in 1 blocks
==13674==      possibly lost: 0 bytes in 0 blocks
==13674==    still reachable: 7,911 bytes in 186 blocks
==13674==         suppressed: 0 bytes in 0 blocks

"
Bug,QPID-3215,12504667,cached exchange reference can cause cluster inconsistencies if exchange is deleted/recreated,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"Description of problem:

SemanticState::route() uses a simple cache variable to avoid looking up the
exchange for every message. However if the exchange in question is deleted,
even if then recreated, this can cause inconsistencies in a cluster.

Version-Release number of selected component (if applicable):

1.3

How reproducible:

100% (Quite a contrived example though)

Steps to Reproduce:
1. start one cluster node
2. create an exchange, a queue and a binding between them

  qpid-config add exchange topic x
  qpid-config add queue q
  qpid-config bind x q k

3. start a session and send a message to the exchange with the relevant key
(leave session running)

  qpid-send --content-stdin --address x/k

then enter a few lines to send some messages

4. start a new cluster node
5. delete and recreate the exchange, this time add in a different binding

  qpid-config del exchange x
  qpid-config add exchange topic x
  qpid-config add queue q2
  qpid-config bind x q2 k  

6. send some more messages on the session from 3. with same exchange and key
(i.e. type in some more messages if using qpid-send as suggested)

  now have an inconsistency where the second node has some messages in q2 and
some (though fewer than first node) in q1, whereas for first node all the
messages are in q1

7. qpid-receive --address 'q2; {mode: browse}' --broker localhost:5673
--capacity 1 (assuming second node is 5673)

Actual results:

First node shutsdown with inconsistent error

Expected results:

No inconsistency, should be able to run the command in 7 against q or q2 on
either node and see the same results.
"
Bug,QPID-1787,12422042,Wrong parameter order of memset In cluster/Cpg.cpp,,chenta,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"I found out that the parameter order is wrong when using ""memset"" in Cpg.cpp at line 72
the original code is ::memset(&callbacks, sizeof(callbacks), 0) and it should be ::memset(&callbacks, 0, sizeof(callbacks));"
Bug,QPID-1721,12416429,Replication doesn't work correctly from late joining cluster nodes,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If cluster nodes are added after replication queues have been created and when they may have messages on them, replication from those new nodes does not behave correctly."
Bug,QPID-2403,12456050,Consistent management names for connections in a cluster.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,QMF,,,,,"Management objects representing connections in a broker are named for the remote end of the socket ip:port. In a cluster, a broker has normal connections and ""shadow"" connections representing a connection on another broker. The shadow connections are named ""[shadow]ip:port"" Management tools use this convention to ignore shadow connections and display only the local connections to a broker.

This is inconsistent with other management objects which are named identically in all brokers, and the problem is compounded because connections are containers for other objects (sessions, consumers) so inconsistency in the connection name makes the names of all the children inconsistent.

Commit r907123 fixed this by making the connection names consistent and adding a ""shadow"" property to the qmf Connection object. However this broke the Java builds. This JIRA is to discuss what the correct solution should be that works for both brokers."
Bug,QPID-4423,12615006,C++ Broker Dynamic and static federation should not declare existing queues,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When configuring either a dynamic or static federated link, it is possible to provide the name of an existing queue to utilize.  The issue is that the destination broker of the federated route will attempt to declare the queue regardless of whether or not it should be using an existing queue.  

This can result in a race condition if the pre-existing queue is not yet available on the source broker. When the destination broker creates a queue it will use default queue settings (i.e. trace/exclude, reject policy, default size limits) and not the desired configured settings that the queue will have when created properly on the source broker.

The proposal to fix this issue is if a queue name was provided during a bridge declaration then the broker should not attempt to declare the queue. When no name is provided then the broker may go ahead and declare an exclusive queue.
"
Bug,QPID-2109,12435984,Windows C++ broker doesn't react properly to ctrl-c,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the C++ broker on Windows gets a ctrl-c, the process gets killed without having a chance to properly clean up. This prevents the plugin finalizers from running, etc."
Bug,QPID-4378,12612485,C++ Broker deletes dynamic bridges too aggressively,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If a dynamic bridge's session has been detached while attempting to propagate a binding event, the broker will delete the bridge.  Normally, a detached bridge session will be automatically recovered during the maintenance periodic if possible. Needless to say, auto-deleting the bridge upon a session error prevents this normal recovery path from occurring.

This event can occur in a production system during broker startup/federation and also during source broker recovery since there is a potential race condition between creation of the source exchange and the creation of the dynamic bridge on the destination broker.

Log Message:
Sep 30 19:41:40 localhost qpidd[10497]: 2012-09-30 19:41:40 [Broker] error Cannot propagate binding for dynamic bridge as session has been detached, deleting dynamic bridge

Steps to reproduce:
# src broker: localhost:5801
# dst broker: localhost:5803
#
# Create exchange in dst broker
#
qpid-config -b localhost:5803 add exchange topic fed.topic

#
# create dynamic bridge
#
qpid-route dynamic add localhost:5803 localhost:5801 fed.topic

#
# create dst queue as bind target
#
qpid-config -b localhost:5803 add queue fed.topic.queue

#
# create binding on dest exchange
#
qpid-config -b localhost:5803   bind fed.topic fed.topic.queue
qpid-config -b localhost:5803 unbind fed.topic fed.topic.queue

# The unbind should not delete the bridge."
Bug,QPID-2402,12456036,qpid::messaging.Message::setTTL() unit ambiguity can cause unexpectected behavior,gsim,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid::messaging.Message::setTTL( boost::uint64_t ttl ) - does not declare its units.

The currently exposed time types are AbsTime and Duration, which seems to imply they should be used for encapsulating time.

When a Duration object is passed to setTTL, the inline operator int64_t() returns the member variable nanoseconds.

When this value is propagated to the broker, it is interpreted around  /cpp/src/qpid/broker/Message # 353 to be in millisecond units.

I would recommend:
- document Message.setTTL units clearly - pick ms or ns
  - if ms, then overload setTTL to take a Duration object so we can use without error by converting in setTTL
  - if ns, then somewhere downstream (OutgoingMessage#351 ?) the ns needs to get converted to ms

"
Bug,QPID-4127,12598247,"SystemInfo.isLocalHost(""::1"") returns false if there is no 'real' ipv6 address",gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"i.e. no non-loopback, global scope address"
Bug,QPID-3006,12495833,Broken acl check on link close,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"start broker 1 (in example below on 5672) with an acl containing:

acl allow bob@QPID all all
acl deny all all

and broker 2 (on 5673 in my case) with no acl. Then run

qpid-route -v add link bob/bob@localhost:5672 bill/bill@localhost:5673
qpid-route -v del link bob/bob@localhost:5672 bill/bill@localhost:5673

The latter fails as the wrong username is used in the attempted authorisation check (uses bill when it should be bob)."
Bug,QPID-3087,12499757,Bad handling of invalid queue arguments,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Tools,,,,,,"Passing bad arguments to queue-declare (e.g. max-count=3.14 or max-size='foo') currently results in those arguments being ignored, but being reported from queue-query or via qmf as they were originally specified. There is a further problem with qpid-config in these cases where it fails due to attempts to convert these values to integers and therefore does not list all queues."
Bug,QPID-2101,12435626,flow-to-disk not handled correctly for persistent messages that are enqueued on both durable and non-durable queues,,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If a persistent message is published to an exchange that routes that message to more than one queue, and if some of those queues are durable with flow-to-disk as the active policy and some are not, then its possible that the broker will release the content for the message due to exceeding the limit configured for the flow to disk policy on one queue. This will mean that delivery of the message from transient queues will fail as they are unable to reload the content."
Bug,QPID-4315,12607878,SSL federation doesn't work when used with hostname rather than IP,astitcher,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,The link is established but the link registry is unable to match the link to the connection as the management id used for the connection uses the IP address and not the hostname as specified.
Bug,QPID-4095,12596290,Boost 1.50.0 has removed filesystem version 2 from the library,astitcher,davin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,C++ Clustering,,,,,The build fails when building against boost 1.50.0 because version 0.16 and earlier require boost filesystem version 2 which has been removed from boost version 1.50.0.
Bug,QPID-1586,12412583,C++ broker crashes when a standard message is sent to a LVQ ,cctrieloff,arnaudsimon,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem: C++ broker crashes when a standard message is sent to a LVQ

Steps to reproduce are:
- Create a LVQ queue with key foo  
- Send 10 messages with the key foo
- Send a message without a key ===> segfault

"
Bug,QPID-2420,12457336,Windows SQL-based persistence loses prepared two-phase transactions on broker restart,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the C++ broker restarts after a 2PC transaction is prepared but not committed, the transaction is lost (as if an abort was done on the transaction) when the broker restarts."
Bug,QPID-4285,12606168,HA backups continuously disconnect / re-sync after attempting to replicate a deleted queue,aconway,dillaman,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Running qmf-stat on the primary broker shows that auto-delete queue XYZ exists, but running drain against the queue indicates that the queue does not really exist.  QMF is out-of-sync with the true state of the queue and as a result, the deleted queue was replicated to the backup broker.  When the backup attempted to subscribe to the queue, it received an error that the queue was deleted which results in the backup disconnecting/reconnecting to the primary and re-attempting the state replication.

Sample log output from backup:

Sep  4 14:51:26 itcm13 qpidd[10392]: 2012-09-04 14:51:26 [System] error resource-deleted: Queue XYZ has been deleted. (qpid/broker/Queue.cpp:1787)
Sep  4 14:51:26 itcm13 qpidd[10392]: 2012-09-04 14:51:26 [Broker] info Inter-broker link disconnected from 10.3.100.105:9006 Closed by peer
Sep  4 14:51:28 itcm13 qpidd[10392]: 2012-09-04 14:51:28 [System] info Connecting: 10.3.100.105:9006


Sample log output from the primary:

Sep  4 14:18:15 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:15 [HA] debug Primary: Known backup connected: host3:9006(ready)
Sep  4 14:18:15 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:15 [HA] debug Broker: Membership add: host3:9006(ready)
Sep  4 14:18:15 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:15 [HA] info Broker: Membership changed: host3:9006(ready) system-node1a-cluster:9006(recovering)
Sep  4 14:18:16 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:16 [System] debug DISCONNECTED [10.3.100.105:9006-10.3.100.13:19841]
Sep  4 14:18:16 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:16 [HA] debug Primary: Backup disconnected: host3:9006(ready)
Sep  4 14:18:16 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:16 [HA] debug Broker: Membership remove: 4ddb3222-e66d-4e6a-8c87-14e1a37332cf
Sep  4 14:18:16 system-node1a-cluster qpidd[8397]: 2012-09-04 14:18:16 [HA] info Broker: Membership changed: system-node1a-cluster:9006(recovering)


Backup bracktrace:

#0  qpid::broker::Queue::checkNotDeleted (this=0x4d97f70, c=<value optimized out>) at qpid/broker/Queue.cpp:1787
#1  0x0000003e1dbf67e4 in qpid::broker::Queue::getNextMessage (this=0x4d97f70, m=..., c=...) at qpid/broker/Queue.cpp:385
#2  0x0000003e1dbf688e in qpid::broker::Queue::dispatch (this=<value optimized out>, c=...) at qpid/broker/Queue.cpp:510
#3  0x00007f15139e62ba in qpid::ha::ReplicatingSubscription::getNext (q=..., from=..., result=...) at qpid/ha/ReplicatingSubscription.cpp:116
#4  0x00007f15139e4ebe in qpid::ha::QueueReplicator::initializeBridge (this=0x3868af0, bridge=..., sessionHandler=<value optimized out>) at qpid/ha/QueueReplicator.cpp:121


"
Bug,QPID-3291,12509192,Broker incorrectly sets TTL to 0 for messages about to expire,,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When qpid::broker::Message::adjustTtl() is called prior to delivering a message to a peer, it adjusts the TTL down to reflect the time the message spent in the broker.  For a message that has expired, it sets the TTL to 1.  The current logic calculates the remaining TTL as the difference, in nanoseconds, between the current time and the expiration time.  If this value is greater than 0, it converts the remaining TTL to milliseconds and sets it on the message; otherwise, it sets the TTL to 1.

This logic could result in a message that is about to expire receiving a TTL of 0.  This would occur if the remaining TTL is somewhere between 1 and 1,000,000 ns.  When the division occurs to convert to ms, it would result in some number between 0 and 1, which is rounded down to 0.  Instead, this value should be 1.

To fix this, the remaining TTL should be compared against 1,000,000.  If it is >= to that number, then the conversion can proceed successfully; otherwise, the TTL should be set to 1."
Bug,QPID-1963,12429270,segfault in TopicExchange::isBound(),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Due to lack of appropriate locking in TopicExchange::isBound() invocation of this method concurrent with modifications to the set of bindings managed by the topic is unsafe and causes segfaults. 
Bug,QPID-1550,12411271,C++ broker crashes periodically when handling connection closure,shuston,rgreig,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Periodically when running the .NET WCF client against the C++ broker running on windows, the broker crashes.

This occurs every 10 runs or thereabouts.

Logs and stacks attached."
Bug,QPID-2217,12441628,New qpid::Plugin::initOrder() not exported for Windows,aconway,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Windows broker build failed today (from the dashboard):

*Error* (first 5)
TCPIOPlugin.obj : error LNK2001: unresolved external symbol ""public: virtual int __thiscall qpid::Plugin::initOrder(void)const "" (?initOrder@Plugin@qpid@@UBEHXZ)


C:\qpid\trunk\build\src\Release\qpidbroker.dll : fatal error LNK1120: 1 unresolved externals
"
Bug,QPID-3280,12508435,Message throughput suffers in a cluster when TTL set,aconway,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When sending a large number of messages with nonzero TTLs to a cluster, overall message throughput drops by around 20-30% compared to messages with TTL 0."
Bug,QPID-1497,12409553,QueuePolicy gets inconsistent count and size  for failed transactions,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Occurs either if a prepared dtx transaction is rolled back, or if a tx transaction fails on commit (if a tx transaction or unprepared dtx transaction is explicitly rolled back the issue does not occur).

Impact is that the policy count and size are lower than reality and hence do not enforce the limit accurately."
Bug,QPID-3438,12519440,cluster auth failure increments cnx count,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If a cluster brokers are authenticating, and an attempted cnx fails due to an auth problem, the broker nevertheless increments its cnx counter.  Which means it eventually runs out of available connections -- even if there aren't any open.  :-("
Bug,QPID-639,12380445,we still need to include sizes for sized structs,gsim,rhs,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Currently the C++ broker doesn't include a size for sized structs such as reply-to. This has been implemented (but disabled) in the python and java clients.
Bug,QPID-3174,12503015,broker crash using rdma+sasl,kgiusti,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"This is sometimes very hard to observe.  I was lucky enough to see it three times in the space of 500 iterations yesterday, but now, with same code & scripts & system, I have no repetition after 6000 iterations.

my tree rev number is  1084895



Here is the backtrace -- all 3 have been identical:

      #0  0x0000003f8d030265 in raise (sig=<value optimized out>)
        at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
      #1  0x0000003f8d031d10 in abort () at abort.c:88
      #2  0x0000003f8d0296e6 in __assert_fail (
          assertion=0x2b28f90400aa ""completionsNeeded.get() > 0"",
          file=0x2b28f903fe58 ""./qpid/broker/AsyncCompletion.h"", line=167,
          function=0x2b28f9040440 ""void qpid::broker::AsyncCompletion::end(qpid::broker::AsyncCompletion::Callback&)"") at assert.c:78
      #3  0x00002b28f8fe2935 in qpid::broker::AsyncCompletion::end (this=0x2aaab60c2e50,
          cb=<value optimized out>) at ./qpid/broker/AsyncCompletion.h:167
      #4  0x00002b28f8fdf3f3 in qpid::broker::SessionState::handleContent (
          this=0x2aaabc4157d0, frame=..., id=<value optimized out>)
          at qpid/broker/SessionState.cpp:265
      #5  0x00002b28f8fdf830 in qpid::broker::SessionState::handleIn (this=0x2aaabc4157d0,
          frame=...) at qpid/broker/SessionState.cpp:355
      #6  0x00002b28f94799dc in qpid::amqp_0_10::SessionHandler::handleIn (
          this=0x2aaab0025680, f=...) at qpid/amqp_0_10/SessionHandler.cpp:93
      #7  0x00002b28f8f2622b in operator() (this=0x2aaab38cffa0, frame=...)
          at ./qpid/framing/Handler.h:42
      #8  qpid::broker::Connection::received (this=0x2aaab38cffa0, frame=...)
          at qpid/broker/Connection.cpp:164
      #9  0x00002b28f8ef8300 in qpid::amqp_0_10::Connection::decode (this=0x2aaabc47d240,
          buffer=<value optimized out>, size=<value optimized out>)
          at qpid/amqp_0_10/Connection.cpp:58
      #10 0x00002b28f94c25e5 in qpid::sys::cyrus::CyrusSecurityLayer::decode (
          this=0x2aaabc468480, input=0x2aaab2aa97d0 """", size=118)
          at qpid/sys/cyrus/CyrusSecurityLayer.cpp:59
      #11 0x00002b28f999c7d8 in qpid::sys::RdmaIOHandler::readbuff (this=0x2aaab002d9e0,
          buff=0xffffffffffffffff) at qpid/sys/RdmaIOPlugin.cpp:218
      #12 0x00002b28f9bba75a in boost::function2<void, Rdma::AsynchIO&, Rdma::Buffer*, std::allocator<boost::function_base> >::operator() (this=0x0, a0=..., a1=0x6)



here is my broker start script:

-------------- start script -----------------------

#! /bin/bash

export LD_LIBRARY_PATH=$TRUNK/qpid/cpp/src/.libs

QPID_SRC=$TRUNK/qpid/cpp/src
QPIDD=${QPID_SRC}/.libs/qpidd

echo $QPIDD

rm -rf /tmp/mick
mkdir /tmp/mick

$QPIDD                                        \
  --no-module-dir                             \
  --load-module ${QPID_SRC}/.libs/rdma.so     \
  --data-dir /tmp/mick/data_1                 \
  --auth=yes                                  \
  --mgmt-enable=yes                           \
  --port 5813                                 \
  --log-enable info+                          \
  --log-to-file /tmp/mick/qpidd_1.log         \
  --log-source yes                            \
  --sasl-config=${QPID_SRC}/tests/sasl_config \
  -d

echo ""started broker from $QPIDD""
----------- end script ------------------------


and here is my client iterator script;


---------------------- start script ---------------------
#! /bin/bash

rm core.* ~/.qpidd/core*

count=0
while [ $count -lt 10000 ]
do
  echo ""===========================================""
  echo ""TEST $count""
  echo ""===========================================""
  sleep 1
  core_files=`ls -l core.* ~/.qpidd/core* | wc -l`
  echo ""core files:  ${core_files}""

  if [ ${core_files} -gt 0 ]; then
    echo ""core files found!""
    exit 1
  else
    echo ""no core files found.""
  fi
  ./qpid-perftest --username zig --password zig --protocol rdma --broker 20.0.40.14 --port 5813 --qt 4 --count 10
  count=$(( $count + 1 ))
done
---------------------- end script -----------------------



the sasl config directory that the broker is pointing at was created by the script cpp/src/tests/sasl_test_setup.sh


also, you need to set  ""ulimit -l 131072""    (at least that value)   before starting the broker.
"
Bug,QPID-3984,12554218,HA tests fail in distribution,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The HA tests fail on an installed qpid distribution because they rely on scripts in the qpid/tools directory. This patch runs the tests conditionally, skipping them if the tools aren't available.
"
Bug,QPID-2518,12462531,Qpid C++ broker can easily be blocked by client trying to connect over SSL port,astitcher,xeop-nollarm,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"We are running a C++ broker as deamon with the following configuration:
 
log-enable=info+
log-to-file=/var/lib/qpidd/op_prod09/data/0097/qpidd.log
log-to-syslog=no
auth=yes
acl-file=qpidd.acl
realm=QPID0097
data-dir=/var/lib/qpidd/op_prod09/data/0097
pid-dir=/var/lib/qpidd/op_prod09/data/0097
port=20097
wait=30
num-jfiles=4
jfile-size-pgs=1
wcache-page-size=128
tpl-num-jfiles=4
tpl-jfile-size-pgs=1
tpl-wcache-page-size=128
ssl-cert-db=/var/lib/qpidd/op_prod09/data/0097
ssl-port=10097
ssl-cert-name=RGC001
ssl-cert-password-file=/var/lib/qpidd/op_prod09/data/0097/amq_cert_db.pwd
ssl-require-client-authentication=yes
cluster-name=QPID0097
cluster-url=amqp:tcp:172.16.45.198:20097
cluster-username=xxxxx
cluster-password=xxxxx
 
We tried to connect an application to the SSL port which does not ""talk"" the correct protocol. We simply used telnet:
$ telnet 172.16.45.198 10097
 
The result was (we waited at least 30 min, then killed the process running telnet):
The broker doesn't react anymore, no more new client connections can be established, the broker even cannot be stopped with ""qpidd -p 20097 -q"".
 
This way anybody in the world could easily block our service provided over a Qpid broker.
Is there a way to get around this? 

This issue has also been reported as Red Hat service request no. 2014266."
Bug,QPID-681,12382283,Queued Message raw Ptr -> managed ptr,cctrieloff,cctrieloff,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"
I have left the ptr raw until the consumer thread is extended to call up to the queue. From what I can work out it will be easier to close this raise case once that has been done. Will either apply shared ptr or queue name patch.

Carl."
Bug,QPID-4163,12599856,Deadlock between LinkRegistry and TimerTask locks,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Very occasionally (about 2% of runs), when running ha_tests.py in a long loop one of the brokers deadlocks with the attached stack trace. The problem is a call to TimerTask::cancel with the LinkRegsitry lock held, while another thread is in TimerTask::fire and waiting for the LinkRegistry lock."
Bug,QPID-2338,12445285,[C++ Broker] Ring queue does not properly implement byte size limits,jonathan.robie,rgodfrey,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"To test I created a queue on the C++ broker with a size limit of 512 bytes, and a policy of ""ring""

First I sent 5 messages each of size 100 bytes.
Then I sent a 6th 100 byte message - as expected this dequeued one of the existing messages

next I sent a single message of size 400 bytes
This caused only a single existing message to be dequeued, leading to 5 messages being enqueued with a total depth of 900 bytes (as reported by qpid-tool).  At this point I would have expected all but one of the existing messages to have been dequeued in order to make room for the 400 byte message

Finally I sent a single 1000 byte message.  This message in itself should have been too big for the queue, however it was enqueued; and only one 100 byte message was dequeued - leaving a total byte depth of 1800 bytes being enqueued."
Bug,QPID-3227,12505237,rdma layer may allow overrun of send buffers,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The rdma driver adds a small trailer to outbound buffers, however the size of this header is not accounted for when the buffer's size is passed to the codec.  If the codec fills all available buffer space, the rdma driver will overwrite the end of the buffer when adding the trailer.

Kudos to Chuck Rolke for helping root-cause this bug!"
Bug,QPID-1368,12406636,C++ broker AclModule.h uses names that conflict with Windows macros,,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"In qpid/cpp/src/qpid/broker/AclModule.h there are two names that conflict with Windows-defined macros: DELETE and ALTERNATE.

One way to resolve this is to undefine the Windows macros, like:

@@ -28,11 +28,19 @@
 #include <set>
 #include <string>
 
+// Windows has a system macro DELETE that conflicts with the Action enum, and
+// ALTERNATE that conflicts with the Property.
+// So undef them.
+#ifdef DELETE
+#undef DELETE
+#endif
+#ifdef ALTERNATE
+#undef ALTERNATE
+#endif
 
 namespace qpid {
 
 namespace acl {
-
 enum ObjectType {QUEUE, EXCHANGE, BROKER, LINK, ROUTE, METHOD, OBJECTSIZE}; // OBJECTSIZE must be last in list
 enum Action {CONSUME, PUBLISH, CREATE, ACCESS, BIND, UNBIND, DELETE, PURGE,
              UPDATE, ACTIONSIZE}; // ACTIONSIZE must be last in list


Another way is to change DELETE and ALTERNATE to some other names. The text strings ""delete"" and ""alternate"" need not change - just the enum names.

Thoughts?
"
Bug,QPID-1988,12430389,unhang failover_soak in case of broker error,,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Currently failover_soak will deliberately leave its other brokers alive if one of them exits unexpectedly.
But this makes failover_soak a bad citizen in multi-test systems like ""make check"".

The added line of code in this patch makes this exit-path from the program the same as all others.



"
Bug,QPID-3457,12520287,qpid::Msg::str() method not exported,aconway,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Trunk r1161742 added a Msg::str() method to cpp/src/qpid/Msg.cpp - this method is not marked with an extern decorator, so it's not visible outside qpidcommon (where Msg.cpp is built) on Windows. This causes build errors on Windows, with unresolved external references to the method."
Bug,QPID-4421,12614851,C++ Broker Issue with reusing link channel Id number too soon,,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Following on to QPID-4392

As you add and remove replicated queues within an HA broker, bridges are opened and closed for each queue.  Closing a bridge immediately re-adds the associated channel number into an available pool.  As a result, when the old bridge (channel X) is closed it sends a ""detach"" command to the broker and the new bridge (assigned the same channel X) sends an ""attach"" command.  The broker will eventually respond with a ""detached"" command which was meant for the original bridge on channel X.  Unfortunately, the new bridge on channel X handles this detached command from the broker and flags the bridge as detached.  This process can then repeat for several cycles until it break out of the detach/attach/detached race.

In addition to the detach/attach/detached race, the immediate re-use of channel numbers appears to create other issues like the following:

Nov  2 11:26:40 itcm31 qpidd[12122]: 2012-11-02 11:26:40 [Protocol] error Execution exception: invalid-argument: anonymous.qpid.bridge_session_qpid.replicator-Queue1.b64c23e6-cb01-4297-8935-c12b40
804ae2_84209514-2e58-4fb9-8d37-7c2440f5f144: confirmed < (2+0) but only sent < (0+0) (qpid/SessionState.cpp:154)

This issue may be worked around by assigning channel Id numbers from the pool in increasing serial order and not immediately reusing a deallocated Id. Although this does not fix the problem of the race condition it will provide relief.
"
Bug,QPID-2459,12459632,nss headers assumed to be in nss3 directory,,neilw,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"nss headers assumed to be in nss3 directory. On Debian derivatives they are in /usr/include/nss.

Configure needs to check that and sort it out. 

See

qpid/sys/ssl/check.cpp
qpid/sys/ssl/check.h
qpid/sys/ssl/util.cpp
qpid/sys/ssl/SslSocket.cpp

"
Bug,QPID-4658,12637589, XML exchange does not update statistics when no binding key matches routing key,jross,eallen,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If no binding key for a XML exchange matches the routing key of incoming message, then QMF statistics of the exchange are not updated - while msgIn, msgDrop, byteIn and byteDrop should be updated.
"
Bug,QPID-1473,12408786,C++ build process must generate MaxMethodBodySize.h on build platform,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The release process generates needed C++ code from the various definitions, including MaxMethodBodySize.h, which is very important. However, the MaxMethodBodySize.h generated during release may not be appropriate for all targets. In particular, it is not compatible with what's generated on Windows and results in some static assertion failures that some method bodies are too big. (MAXMETHODBODYSIZE is 148 on Linux, 456 on Windows!)

The fix for this is to have the Windows Visual Studio solution include a project to build the MaxMethodBodySize.h file. I have a project ready and will commit it soon."
Bug,QPID-1974,12429800,LVQ state is not replicated to new cluster nodes correctly,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If an LVQ with messages on it is replicated to a new joiner in a cluster, the state of that queue on this joiner may not match the state of the same queue on the node from which it received the update."
Bug,QPID-2435,12458274,Deadlock can occur during the registration of a qmf agent,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The ""publishNow"" feature in ManagementAgent::addObject causes a message to be sent.  The call chain violates the required locking hierarchy and may, in rare cases, cause the broker to deadlock."
Bug,QPID-2996,12495371,qmf/SchemaMethod.cpp fails to compile on s390,tross,sharkcz,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"qmf/SchemaMethod.cpp fails to compile on s390 with the following error

libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../include -I../include -I. -I=. -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -DQPID_LIBEXEC_DIR=\""/usr/libexec/qpid\"" -O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m31 -march=z9-109 -mtune=z10 -DNDEBUG -O3 -c qmf/SchemaMethod.cpp  -fPIC -DPIC -o qmf/.libs/SchemaMethod.o
qmf/SchemaMethod.cpp: In member function 'void qmf::SchemaMethodImpl::encodeV1(qpid::management::Buffer&) const':
qmf/SchemaMethod.cpp:166:38: error: ambiguous overload for 'operator=' in 'map.std::map<_Key, _Tp, _Compare, _Alloc>::operator[] [with _Key = std::basic_string<char>, _Tp = qpid::types::Variant, _Compare = std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const std::basic_string<char>, qpid::types::Variant> >, mapped_type = qpid::types::Variant, key_type = std::basic_string<char>](((const std::map<std::basic_string<char>, qpid::types::Variant>::key_type&)(& std::basic_string<char>(((const char*)""argCount""), ((const std::allocator<char>&)((const std::allocator<char>*)(& std::allocator<char>()))))))) = ((const qmf::SchemaMethodImpl*)this)->qmf::SchemaMethodImpl::arguments.std::list<_Tp, _Alloc>::size [with _Tp = qmf::SchemaProperty, _Alloc = std::allocator<qmf::SchemaProperty>, std::list::size_type = long unsigned int]()'
../include/qpid/types/Variant.h:98:32: note: candidates are: qpid::types::Variant& qpid::types::Variant::operator=(bool)
../include/qpid/types/Variant.h:99:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(uint8_t)
../include/qpid/types/Variant.h:100:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(uint16_t)
../include/qpid/types/Variant.h:101:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(uint32_t)
../include/qpid/types/Variant.h:102:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(uint64_t)
../include/qpid/types/Variant.h:103:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(int8_t)
../include/qpid/types/Variant.h:104:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(int16_t)
../include/qpid/types/Variant.h:105:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(int32_t)
../include/qpid/types/Variant.h:106:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(int64_t)
../include/qpid/types/Variant.h:107:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(float)
../include/qpid/types/Variant.h:108:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(double)
../include/qpid/types/Variant.h:113:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(const qpid::types::Variant&)
../include/qpid/types/Variant.h:114:32: note:                 qpid::types::Variant& qpid::types::Variant::operator=(const qpid::types::Uuid&)
make[3]: Leaving directory `/builddir/build/BUILD/qpid-0.8/cpp/src'
make[3]: *** [qmf/SchemaMethod.lo] Error 1

I think an explicit typecast of the arguments.size() call will solve it.

excerpt from /usr/include/c++/4.5.1/s390-redhat-linux/bits/c++config.h
...
/* Define if size_t is unsigned int. */
/* #undef _GLIBCXX_SIZE_T_IS_UINT */
...

link to Fedora/s390x build system - http://s390.koji.fedoraproject.org/koji/taskinfo?taskID=281714
"
Bug,QPID-2605,12464654,Recovered messages larger than 65523 bytes result in framing violation (),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"To reproduce:

1. send durable message of 65524 bytes or greater to a durable queue
2. restart broker
3. try to receiver the message

This fails with e.g.  framing-error: Frame size too small 0."
Bug,QPID-2231,12442358,Cluster + store fails with default data-directory,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"A broker started with cluster and store enabled and using the Unix default data-directory ""$HOME/.qpidd"" fails with 
  Daemon startup failed: boost::filesystem::path: invalid name "".qpidd"" in path: ""/home/remote/aconway/.qpidd""
It would also fail for any user-selected directory name that does not conform to boost ""portable filename"" syntax.

The fix is to use boost ""native"" paths rather than the default portable paths."
Bug,QPID-2587,12463996,PollableCondition test fails on Windows,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The PollableCondition test in unit_tests fails on Windows; once the condition is set, it is cleared after being dispatched. It should remain set until cleared."
Bug,QPID-3491,12523348,windows c++ build with MSSQL storage cannot start with persisted messages in the store,shuston,bpedman,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Problem:
Using ONLY the C++ Windows broker with the MSSQL storage provider I cannot start the broker if I have messages persisted in the store. I have tested the Java broker on Windows with the BDB store, and the C++ broker on Linux with the BDB store (I think it's BDB...) and neither of them have this problem, so I am assuming it is just a problem with the MSSQL storage provider.

Steps to reproduce:
- get the C++ broker up and running on Windows with the MSSQL storage provider
- run qpid-config add exchange news-service topic --durable
- run qpid-config add queue mytopicq --durable
- run qpid-config bind news-service mytopicq *.news
- Modify the spout script and set durable to True on the Message
- Run spout news-service/usa.news
- Shut down the broker
- Try to start the broker

Results:
It fails to start with the following output:
2011-09-15 01:10:42 notice MSSQL: Database located: QpidStore
2011-09-15 01:10:42 critical Unexpected error: Error recovering
messages: Unknown error 0x800A0BB9: Arguments are of the wrong type,
are out of acceptable range, or are in conflict with one another.

Comments:
This should probably be a blocker, but since I have gotten the Java broker up and running with the BDB store I am not terribly concerned about this now...though it is still a big issue"
Bug,QPID-4633,12635939,C++ broker compile error on RHEL 5 g++ 4.1.2,astitcher,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Build on RHEL 5 is recently getting this error:

cc1plus: warnings being treated as errors
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/posix/SocketFDPlugin.cpp:64: warning:
 ?쁰pid::sys::SocketFDPlugin??has a field ?쁰pid::sys::SocketFDPlugin::options??wh
ose type uses the anonymous namespace
make[2]: *** [src/CMakeFiles/qpidbroker.dir/qpid/broker/posix/SocketFDPlugin.o] 
"
Bug,QPID-1724,12416585,Replication throughput is limited by that of a single federation link,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Allowing the work to be divided between multiple links would offer one means of improving this.
Bug,QPID-2376,12447012,"C++ broker build broken at 20:00 Thurs Jan 28, 2010",kgiusti,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The overnight Linux trunk cmake build broke last night; errors are listed here:
http://www.riverace.com/CDash-1.4.2/viewBuildError.php?buildid=398

From the looks of the error, I'm guessing that this change may be involved:
       SaslAuthenticator.cpp Revision: 904293 by kgiusti
        QPID-2374: Null authenticator now checks for SSL if --encryption-required specified

"
Bug,QPID-638,12380396,broker assertion failure during ChannelCloseOkTest,,rhs,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"planitia% src/qpidd
2007-Oct-13 21:55:13 error Error [30000] Unknown field table value type: ! (qpid/framing/Value.cpp:96)
lt-qpidd: qpid/sys/Dispatcher.cpp:361: void qpid::sys::DispatchHandle::dispatchCallbacks(qpid::sys::Poller::EventType): Assertion `false' failed.
Aborted
"
Bug,QPID-3252,12506656,Regression: broker no longer explicitly flushes messages to store on execution.sync or when sync command bit set.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"In the previous release of the broker, an execution.sync command, or a message.transfer command with a sync flag would cause the broker to explicitly flush the message(s) and pend until the flushes complete.  In the new asynchronous model, the broker does not initiate a flush under these scenarios.  Without explicitly flushing, the completion of a message.transfer/execution.sync may delay for an unacceptable amount of time (ex. 1sec+) when used with store.
"
Bug,QPID-1917,12428267,the java async profile is failing due to suspicous broker behavior when async store is loaded,kpvdr,rhs,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The async profile fails when running against the cpp broker with persistence enabled. I've analyzed the cause, and it appears that MessageListenerMultiConsumerTest.testAsynchronousRecieve is running successfully, however the messages that it sends and then consumes are erroneously recovered the next time the broker restarts, and this causes failures in many subsequent tests.

I've included the log output from the test run. I've modified MessageListenerMultiConsumerTest to generate a random UUID to identify each test run, and marked each message with this test-id. This makes it clear that the messages which were consumed according to the logs here:

TEST-org.apache.qpid.client.MessageListenerMultiConsumerTest.testAsynchronousRecieve.out

Are actually resent in the test that follows here:

TEST-org.apache.qpid.client.MessageListenerMultiConsumerTest.testRecieveInterleaved.out

The broker logging in the first file indicates that the broker did receive the acknowledgment for the messages in question, and the second file shows those messages being sent anyways. Note that there is a broker restart in between the two tests."
Bug,QPID-2470,12460345,Broker does not honour flow-to-disk policy on recovery,kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The broker implements a flow-to-disk strategy as a means of retaining message content when a queue policy is exceeded. In this strategy, message content (whether persistent or transient) is written to the store, then released from memory. Before the message may be consumed, the message content must be retrieved from the store.

If a broker is stopped while there is flow-to-disk content containing persistent messages, then the broker fails to honour the policy when that content is restored. The policy itself is recovered, however, all message content is restored, even if it violates that policy. In cases where the flow-to-disk content is greater than the available memory, the broker may become unresponsive or fail in its recovery owing to memory starvation."
Bug,QPID-3447,12519693,Creating invalid federation link causes file descriptor leak,astitcher,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Specifying invalid IP address of destination broker causes repeatable file
descriptor leak.

Steps to Reproduce:
1. qpid-route -v link add localhost 10:17700
(alternativelly, create a dynamic route like    qpid-route dynamic add localhost 10:17700 amq.direct )
2. lsof -p $(pgrep qpidd) | grep ""can't identify protocol""

Since then, lsof will show ""can't identify protocol"" file descriptors whose number is increasing in time."
Bug,QPID-4011,12556466,TestIsLocalHost unit_test fails with if machine name resolves to loopback address,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,C++ Clustering,,,,,The new SystemInfo::isLocalHost() code doesn't check correctly for interface addresses that resolve to the loopback address.
Bug,QPID-947,12394539,update python and cpp management to use 0-10 final,rhs,rhs,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,Python Client,,,,,,"The management agent inside the cpp broker, as well as its counterpart inside the 0-10 client both use the 0-10 preview version of the protocol. These must be updated to the 0-10 final version."
Bug,QPID-2636,12465894,disconnect() callback on broker results in leaked connections,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,E.g. run qpid-perftest --size 10 --count 10000 --nsubs 500 --npubs 500 and then kill the client process while running. Then run qpid-stat -c. This often results in connections not being properly deleted (and still being reported by qpid-stat). 
Bug,QPID-1873,12426143,Queue durability does not propagate in cluster newbie broker update.,gsim,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When a newbie broker is added to a cluster, it will hallucinate all of its queues as durable.  
It happens because the encode / decode stuff in src/qpid/broker/Queue.cpp  just doesn't propagate the actual durability status of queues.
It assumes that all queues are durable.

"
Bug,QPID-3033,12497511,Bug 674183 - Segmentation fault while processing session.attach,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,See https://bugzilla.redhat.com/show_bug.cgi?id=674183
Bug,QPID-1458,12408375,C++ common compile error in VC9 Release mode,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"When building C++ common library in Release mode, the following compile errors appear:

1>C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\xutility(419) : error C2664: 'qpid::InlineAllocator<BaseAllocator,Max>::InlineAllocator(const qpid::InlineAllocator<BaseAllocator,Max> &)' : cannot convert parameter 1 from 'qpid::InlineAllocator<BaseAllocator,Max>' to 'const qpid::InlineAllocator<BaseAllocator,Max> &'
1>        with
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        Reason: cannot convert from 'qpid::InlineAllocator<BaseAllocator,Max>' to 'const qpid::InlineAllocator<BaseAllocator,Max>'
1>        with
1>        [
1>            BaseAllocator=std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\xutility(417) : while compiling class template member function 'std::_Container_base_aux_alloc_real<_Alloc>::_Container_base_aux_alloc_real(_Alloc)'
1>        with
1>        [
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\vector(421) : see reference to class template instantiation 'std::_Container_base_aux_alloc_real<_Alloc>' being compiled
1>        with
1>        [
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\vector(439) : see reference to class template instantiation 'std::_Vector_val<_Ty,_Alloc>' being compiled
1>        with
1>        [
1>            _Ty=qpid::Range<qpid::framing::SequenceNumber>,
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        .\qpid/InlineVector.h(42) : see reference to class template instantiation 'std::vector<_Ty,_Ax>' being compiled
1>        with
1>        [
1>            _Ty=qpid::Range<qpid::framing::SequenceNumber>,
1>            _Ax=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        .\qpid/RangeSet.h(168) : see reference to class template instantiation 'qpid::InlineVector<T,Max>' being compiled
1>        with
1>        [
1>            T=qpid::Range<qpid::framing::SequenceNumber>,
1>            Max=3
1>        ]
1>        c:\ace\exported\qpid\trunk\qpid\cpp\src\qpid\framing\SequenceSet.h(31) : see reference to class template instantiation 'qpid::RangeSet<T>' being compiled
1>        with
1>        [
1>            T=qpid::framing::SequenceNumber
1>        ]

This problem does not occur with VC8, nor with VC9 in Debug mode."
Bug,QPID-2936,12479509,XML exchange only creates external variables from application headers that are strings,jonathan.robie,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When using an XQuery expression such as

declare variable $control external;
$control mod 2 = 0

the XML exchange currently only creates external XQuery variables from strings.  For example, if I set an application header to 4, the XML exchange does not create an external variable for it.  On the other hand, if I set the header to ""4"" (a string), the XML exchange will create an external variable for it.

It would be useful if the XML exchange supported other application header data types.

I tested this on the latest code from trunk, approx. r1033046."
Bug,QPID-4031,12558675,Deadlock when destroying a broker Link,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Very unlikely, but if the Link's maintenance timer fires at the moment the Link is destroyed, a deadlock can occur."
Bug,QPID-3478,12522290,Windows Visual Studio 2010 warning C4251 'needs to have dll interface' qpid::amqp_0_10::MapCodec::contentType,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"File cpp/include/qpid/amqp_0_10/Codecs.h has code to the effect of:

class QPID_COMMON_EXTERN MapCodec
{
  public:
    static const std::string contentType;
  private:
};

VS2010 warns that exporting a std::string from a DLL may have unexpected consequences.

One possible solution is from

http://www.eggheadcafe.com/software/aspnet/30952961/a-solution-to-warning-c4251--class-needs-to-have-dllinterface.aspx

2. You can define a wrapper class that has no inline functions and defines all the potentially compiler-generated functions (default ctor, copy ctor, dtor, and assignment operator) and dllexport that.

Other discussion of this issue:

http://stackoverflow.com/questions/2132747/warning-c4251-when-building-a-dll-that-exports-a-class-containing-an-atlcstring
"
Bug,QPID-3107,12500294,Messages following a queue's Alternate-Exchange do not follow the exchange's Alternate-Exchange,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When a queue is deleted, any messages within the queue are delivered to that
queue's alternate exchange.  If no bindings in that exchange match, then the
messages are dropped.  This happens even if the exchange has and alternate
exchange.

"
Bug,QPID-2925,12479043,MSSQL-based message store throws uncaught exception if db recovery throws an error,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the MS SQL-based persistence store tries to recover a sql catalog and gets an error, the resultant com error isn't caught and ends up aborting the process without any diagnostic output to say why."
Bug,QPID-4240,12604245,#NAME?,gsim,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The new option --link-maintenance-interval is misspelled in cpp/src/qpid/broker/Broker.cpp line 172. It currently is spelt without the second ""n"" - ""--link-maintenace-interval""

Also this option has no documentation string."
Bug,QPID-3443,12519664,the C++ broker uses the wrong exception type when clients try to modify the default exchange,gsim,robbie,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Various test cases in AddressBasedDestinationTest are failing on the C++ test profiles, due to an exception being returned indicating the client tried to modify the default exchange. The exception is a NOT_ALLOWED, but the 0-10 spec says this should be met with an ILLEGAL_ARGUMENT exception.

Eg:


Testcase: testDestinationOnSend took 0.207 sec
        Caused an ERROR
Error registering consumer: org.apache.qpid.AMQException: ch=0 id=0 ExecutionException(errorCode=NOT_ALLOWED, commandId=4, classCode=7, commandCode=4, fieldI
ndex=0, description=not-allowed: Bind not allowed for default exchange (qpid/broker/Broker.cpp:920), errorInfo={}) [error code 530: not allowed]
javax.jms.JMSException: Error registering consumer: org.apache.qpid.AMQException: ch=0 id=0 ExecutionException(errorCode=NOT_ALLOWED, commandId=4, classCode=
7, commandCode=4, fieldIndex=0, description=not-allowed: Bind not allowed for default exchange (qpid/broker/Broker.cpp:920), errorInfo={}) [error code 530: n
ot allowed]
        at org.apache.qpid.client.AMQSession$4.execute(AMQSession.java:2057)
        at org.apache.qpid.client.AMQSession$4.execute(AMQSession.java:2000)
        at org.apache.qpid.client.AMQConnectionDelegate_0_10.executeRetrySupport(AMQConnectionDelegate_0_10.java:325)
        at org.apache.qpid.client.AMQConnection.executeRetrySupport(AMQConnection.java:570)
        at org.apache.qpid.client.failover.FailoverRetrySupport.execute(FailoverRetrySupport.java:102)
        at org.apache.qpid.client.AMQSession.createConsumerImpl(AMQSession.java:1998)
        at org.apache.qpid.client.AMQSession.createConsumer(AMQSession.java:971)
        at org.apache.qpid.test.client.destination.AddressBasedDestinationTest.testDestinationOnSend(AddressBasedDestinationTest.java:1119)
        at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:243)
        at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:128)
Caused by: org.apache.qpid.AMQException: ch=0 id=0 ExecutionException(errorCode=NOT_ALLOWED, commandId=4, classCode=7, commandCode=4, fieldIndex=0, descripti
on=not-allowed: Bind not allowed for default exchange (qpid/broker/Broker.cpp:920), errorInfo={}) [error code 530: not allowed]
        at org.apache.qpid.client.AMQSession_0_10.setCurrentException(AMQSession_0_10.java:1058)
        at org.apache.qpid.client.AMQSession_0_10.sync(AMQSession_0_10.java:1038)
        at org.apache.qpid.client.AMQSession_0_10.sendQueueBind(AMQSession_0_10.java:377)
        at org.apache.qpid.client.AMQSession$2.execute(AMQSession.java:678)
        at org.apache.qpid.client.failover.FailoverNoopSupport.execute(FailoverNoopSupport.java:67)
        at org.apache.qpid.client.AMQSession.bindQueue(AMQSession.java:674)
        at org.apache.qpid.client.AMQSession.registerConsumer(AMQSession.java:2854)
        at org.apache.qpid.client.AMQSession.access$500(AMQSession.java:120)
        at org.apache.qpid.client.AMQSession$4.execute(AMQSession.java:2034)

"
Bug,QPID-3543,12526705,C++ Broker: auto-acknowledged messages are not being dequeued properly,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Bug introduced by https://issues.apache.org/jira/browse/QPID-3346 prevents messages that are auto-acknowledged from being correctly dequeued.  Example: run qpid-perftest, then examine the perftest queue via qpid-stat -q command.  The number of dequeues is incorrectly set to zero."
Bug,QPID-2429,12458114,headers exchange does not match correctly on a map entry with a null value,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Such an entry should match any value. 
Bug,QPID-1866,12425925,Durable plug-in exchanges cause broker failure on recovery,,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When an exchange, of a type supplied by a plug-in, is declared as durable, the broker crashes on subsequent startup and recovery.

Apparently, the store is recovered before plugin exchanges are registered.  When recovered, the exchange type is unknown.
"
Bug,QPID-1685,12415565,Ring queue fails with resource-limit-exceeded exception,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Ring queue (in non-strict mode) should always replace oldest messages to make
way for new messages so this error should never occur. "
Bug,QPID-2063,12433669,ACL does not check queuename (or routingkey) on bind,rajith,platten,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"ACL allows binding to a queue to which access should be denied. e.g.

ACL:
acl deny  tester@QPID all queue name=baz
acl allow tester@QPID bind exchange name=foo queuename=bar routingkey=foo.bar

The following command succeed and it shouldn't
qpid-config -a baclo/baclo@localhost bind foo baz foo.bar

I believe this is because SessionAdapter::ExchangeHandlerImpl::bind is not checking either queueName or routingKey. I.e.
    AclModule* acl = getBroker().getAcl();
    if (acl) {
        if (!acl->authorise(getConnection().getUserId(),acl::ACT_BIND,acl::OBJ_EXCHANGE,exchangeName,routingKey) )

should read:
    AclModule* acl = getBroker().getAcl();
    if (acl) {
        std::map<acl::Property, std::string> params;
        params.insert(make_pair(acl::PROP_QUEUENAME, queueName));
        params.insert(make_pair(acl::PROP_ROUTINGKEY, routingKey));
        if (!acl->authorise(getConnection().getUserId(),acl::ACT_BIND,acl::OBJ_EXCHANGE,exchangeName,&params) )
"
Bug,QPID-1261,12402928,Deadlock when using rdma,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,The upcoming rdma transport uses a slightly different threading model and can deadlock due to the message lock being held across notify calls on consumers in qpid/broker/Queue.cpp (lock ordering issues with SessionState::lock).
Bug,QPID-1957,12428997,FrameDecoder's append() function accesses out-of-range if appending 0 bytes,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The append() function in qpid/framing/FrameDecoder.cpp tries to take the address of out-of-range bytes if appending 0 bytes. Although no bytes will actually be written, the [] operator throws an out of range exception in Visual Studio, which is correct since the address of an element that doesn't exist is being requested.

This fixes it:

Index: src/qpid/framing/FrameDecoder.cpp
===================================================================
--- src/qpid/framing/FrameDecoder.cpp   (revision 788779)
+++ src/qpid/framing/FrameDecoder.cpp   (working copy)
@@ -32,7 +32,8 @@
 /** Append up to n bytes from start of buf to end of bytes. */
 void append(std::vector<char>& bytes, Buffer& buffer, size_t n) {
     size_t oldSize = bytes.size();
-    n = std::min(n, size_t(buffer.available()));
+    if ((n = std::min(n, size_t(buffer.available()))) == 0)
+        return;
     bytes.resize(oldSize+n);
     char* p = &bytes[oldSize];
     buffer.getRawData(reinterpret_cast<uint8_t*>(p), n);
"
Bug,QPID-2938,12479623,Logging excessive warnings in Timer code affects performance.,aconway,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"The Timer code logs a warning if a timer callback is started late or overruns the start time for the next callback.

In cases where there are a lot of these warnings, the time taken to do the logging itself severly worsens the situation. You can provoke such a warnings storm  by starting a broker in a cluster and running:

qpid-cpp-benchmark -q4  --send-arg --ttl=10000

The log shows timer events that are increaesingly late and overrun by up to 30 seconds, and the test is very slow to complete, I gave up after 2 minutes when the lateness was up to 90 seconds.

This warning storm has also been seen with out clustering but with a store, see https://bugzilla.redhat.com/show_bug.cgi?id=629756"
Bug,QPID-1424,12407626,"Compile error in C++ broker, SessionManager.cpp",shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"In this method in cpp/src/qpid/broker/SessionManager.cpp there's a compile error on Windows:

void SessionManager::eraseExpired() {
    // Called with lock held.
    if (!detached.empty()) {
        Detached::iterator keep = std::lower_bound(
            detached.begin(), detached.end(), now(),
            boost::bind(std::less<AbsTime>(), boost::bind(&SessionState::expiry, _1), _2));

It doesn't like the boost::bind(&SessionState::expiry, _1):

C:\Program Files (x86)\boost\boost_1_35_0\boost/bind.hpp(279) : error C2664: 'bool std::less<_Ty>::operator ()(const _Ty &,const _Ty &) const' : cannot convert parameter 2 from 'qpid::broker::SessionState' to 'const qpid::sys::AbsTime &'
1>        with
1>        [
1>            _Ty=qpid::sys::AbsTime
1>        ]
1>        Reason: cannot convert from 'qpid::broker::SessionState' to 'const qpid::sys::AbsTime'
1>        No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called
1>        C:\Program Files (x86)\boost\boost_1_35_0\boost/bind/bind_template.hpp(76) : see reference to function template instantiation 'R boost::_bi::list2<A1,A2>::operator ()<bool,F,boost::_bi::list2<const qpid::sys::AbsTime &,qpid::broker::SessionState &>>(boost::_bi::type<T>,F &,A &,long)' being compiled
1>        with
1>        [
1>            R=bool,
1>            A1=boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,
1>            A2=boost::arg<2>,
1>            F=std::less<qpid::sys::AbsTime>,
1>            T=bool,
1>            A=boost::_bi::list2<const qpid::sys::AbsTime &,qpid::broker::SessionState &>
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 8\VC\include\xutility(314) : see reference to function template instantiation 'bool boost::_bi::bind_t<R,F,L>::operator ()<_Ty2,_Ty1>(const A1 &,A2 &)' being compiled
1>        with
1>        [
1>            R=boost::_bi::unspecified,
1>            F=std::less<qpid::sys::AbsTime>,
1>            L=boost::_bi::list2<boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,boost::arg<2>>,
1>            _Ty2=qpid::sys::AbsTime,
1>            _Ty1=qpid::broker::SessionState,
1>            A1=qpid::sys::AbsTime,
1>            A2=qpid::broker::SessionState
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 8\VC\include\algorithm(2304) : see reference to function template instantiation 'bool std::_Debug_lt_pred<_Pr,T,_Ty>(_Pr,_Ty1 &,const _Ty2 &,const wchar_t *,unsigned int)' being compiled
1>        with
1>        [
1>            _Pr=boost::_bi::bind_t<boost::_bi::unspecified,std::less<qpid::sys::AbsTime>,boost::_bi::list2<boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,boost::arg<2>>>,
1>            T=qpid::broker::SessionState,
1>            _Ty=qpid::sys::AbsTime,
1>            _Ty1=qpid::broker::SessionState,
1>            _Ty2=qpid::sys::AbsTime
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 8\VC\include\algorithm(2318) : see reference to function template instantiation '_FwdIt std::_Lower_bound<boost::void_ptr_iterator<VoidIter,T>,_Ty,__w64 int,_Pr>(_FwdIt,_FwdIt,const _Ty &,_Pr,_Diff *)' being compiled
1>        with
1>        [
1>            _FwdIt=boost::void_ptr_iterator<std::_Vector_iterator<void *,std::allocator<void *>>,qpid::broker::SessionState>,
1>            VoidIter=std::_Vector_iterator<void *,std::allocator<void *>>,
1>            T=qpid::broker::SessionState,
1>            _Ty=qpid::sys::AbsTime,
1>            _Pr=boost::_bi::bind_t<boost::_bi::unspecified,std::less<qpid::sys::AbsTime>,boost::_bi::list2<boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,boost::arg<2>>>,
1>            _Diff=__w64 int
1>        ]
1>        .\qpid\broker\SessionManager.cpp(91) : see reference to function template instantiation '_FwdIt std::lower_bound<boost::void_ptr_iterator<VoidIter,T>,qpid::sys::AbsTime,boost::_bi::bind_t<R,F,L>>(_FwdIt,_FwdIt,const _Ty &,_Pr)' being compiled
1>        with
1>        [
1>            _FwdIt=boost::void_ptr_iterator<std::_Vector_iterator<void *,std::allocator<void *>>,qpid::broker::SessionState>,
1>            VoidIter=std::_Vector_iterator<void *,std::allocator<void *>>,
1>            T=qpid::broker::SessionState,
1>            R=boost::_bi::unspecified,
1>            F=std::less<qpid::sys::AbsTime>,
1>            L=boost::_bi::list2<boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,boost::arg<2>>,
1>            _Ty=qpid::sys::AbsTime,
1>            _Pr=boost::_bi::bind_t<boost::_bi::unspecified,std::less<qpid::sys::AbsTime>,boost::_bi::list2<boost::_bi::bind_t<const qpid::sys::AbsTime &,boost::_mfi::dm<qpid::sys::AbsTime,qpid::broker::SessionState>,boost::_bi::list1<boost::arg<1>>>,boost::arg<2>>>
1>        ]

"
Bug,QPID-3931,12549510,x-qpid.cluster-update exchange existing but hidden,aconway,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Description of problem:
Having a broker in a cluster, it creates x-qpid.cluster-update fanout exchange
via that it receives updates from an elder node. The problem is the exchange is
still present after the update finishes, and moreover _nothing_ lists the
exchange (try qpid-config exchanges, qpid-tool, etc.).

The exchange can be used for a regular message traffic - see reproducer for
details.

Note it is a security flaw also - having an exchange never listed, nowhere
documented (BZ to be raised and linked), but able to be used. Constructing
ACLs, one can easily miss it, e.g.

Note that on qpid 0.10, the exchange is named qpid.cluster-update (without ""x-""
prefix).


Version-Release number of selected component (if applicable):
any (tried on qpid 0.12)


How reproducible:
100%


Steps to Reproduce:
1. Have 2 node cluster (brokers A and B)

2. Start broker A, create a queue:
qpid-config add queue testQueue

3. Start broker B that will be updated from broker A

4. Check in any way x-qpid.cluster-update exchange is not visible:
qpid-config exchanges | grep x-qpid.cluster-update
qpid-tool -> list exchange

5. Create a binding from the exchange:
qpid-config bind x-qpid.cluster-update testQueue

6. Send some messages to the exchange:
./spout -c 10 x-qpid.cluster-update

7. Check the queue gets the messages:
qpid-stat -q


Actual results:
All steps succeed, step 7 shows the queue has 10 messages


Expected results:
Step 5 should fail with ""no such exchange exists"" error

"
Bug,QPID-2458,12459625,nspr.h file assumed to be in nspr4 directory,gsim,neilw,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"qpid/sys/ssl/SslSocket.h includes <nspr4/nspr.h>. On Debian systems this header is at /usr/include/nspr/nspr.h. The configure system needs to detect the location of the header.

"
Bug,QPID-4590,12632910,running amqp 1.0 without management causes crash,gsim,astitcher,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"run a broker
    qpidd -m 0

Connect with qpid-receive using amqp1.0:

qpid-receive -a foo --connection {protocol:amqp1.0}

The broker crashes during connections establishment:
qpidd: /usr/include/boost/smart_ptr/shared_ptr.hpp:424: T* boost::shared_ptr<T>::operator->() const [with T = qmf::org::apache::qpid::broker::Connection]: Assertion `px != 0' failed.
Aborted (core dumped)

The stacktrace is: (omitted irrelevant top and bottom of stack trace for brevity)

#5  0x00007ffff6bf0666 in qpid::broker::amqp::ManagedConnection::setSaslMechanism (this=0x701100, mechanism=""ANONYMOUS"")
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/ManagedConnection.cpp:68
#6  0x00007ffff6c01830 in qpid::broker::amqp::Sasl::init (this=0x7010a0, 
    mechanism=""ANONYMOUS"", response=0x7fffffffa710)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Sasl.cpp:128
#7  0x00007ffff75d5afd in qpid::amqp::(anonymous namespace)::SaslInitReader::onString (this=0x7fffffffa6f0, h=...)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/SaslServer.cpp:125
#8  0x00007ffff75bf7ff in qpid::amqp::Decoder::readValue (this=0x7fffffffa750, 
    reader=..., code=161 '\241', descriptor=0x0)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:253
#9  0x00007ffff75bf0fa in qpid::amqp::Decoder::readOne (this=0x7fffffffa750, 
    reader=...)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:173
#10 0x00007ffff75bf025 in qpid::amqp::Decoder::read (this=0x7fffffffa750, 
    reader=...)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:164
#11 0x00007ffff75d623c in qpid::amqp::SaslServer::onStartList (this=0x7010a8, 
    count=3, arguments=..., descriptor=0x7fffffffb1e8)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/SaslServer.cpp:170
#12 0x00007ffff75bfd92 in qpid::amqp::Decoder::readList (this=0x7fffffffb270, 
    reader=..., size=39, count=3, descriptor=0x7fffffffb1e8)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:336
#13 0x00007ffff75bfbb2 in qpid::amqp::Decoder::readList32 (
    this=0x7fffffffb270, reader=..., descriptor=0x7fffffffb1e8)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:30---Type <return> to continue, or q <return> to quit---
3
#14 0x00007ffff75bfa22 in qpid::amqp::Decoder::readValue (this=0x7fffffffb270, 
    reader=..., code=208 '\320', descriptor=0x7fffffffb1e8)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:273
#15 0x00007ffff75bf0fa in qpid::amqp::Decoder::readOne (this=0x7fffffffb270, 
    reader=...)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:173
#16 0x00007ffff75bf025 in qpid::amqp::Decoder::read (this=0x7fffffffb270, 
    reader=...)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Decoder.cpp:164
#17 0x00007ffff75d2082 in qpid::amqp::Sasl::read (this=0x7010a8, 
    data=0x7ffff1661010 """", available=59)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/amqp/Sasl.cpp:86
#18 0x00007ffff6c00efb in qpid::broker::amqp::Sasl::decode (this=0x7010a0, 
    buffer=0x7ffff1661010 """", size=59)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Sasl.cpp:51
#19 0x00007ffff75ab2f4 in qpid::sys::AsynchIOHandler::readbuff (
    this=0x7fffdc000b00, buff=0x7fffdc001930)
    at /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp:125
"
Bug,QPID-3964,12551747,Incorrect ACL checks for passive declares,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,The broker checks for a 'create' permission when responding to a passive declare. This is not correct as a passive declare explicitly *does not* create the exchange/queue in question.
Bug,QPID-2373,12446927,Durable exchange state not replicated to broker joining cluster,kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Description of problem:
If a durable exchange exists in a cluster, and a broker joins the cluster, the durable exchange is not listed for the new broker.

How reproducible:
100%

Steps to Reproduce:
1. Start a broker in a cluster at <address1>
2. Run 'qpid-config -a <address1> add exchange ExDurable direct --durable'
3. Run 'qpid-config -a <address1> add exchange Ex direct'
4. Run 'qpid-config -a <address1> exchanges' to see both newly created
exchanges
5. Start another broker within the cluster at <address2>.
6. Run 'qpid-config -a <address2> exchanges'.

Actual results:
The output shows only exchange 'Ex' and not 'ExDurable'.

Expected results:
Both exchanges should be there.

Additional info:
Durable queues seem to work.
You get the same problem if you start both brokers initially, then create the durable exchange (it appears in both), then shut down one broker and bring it back up (the durable exchange disappears).    "
Bug,QPID-2523,12462574,"When reloading a large acl file while acl lookup is in progress, the broker core dumps",rajith,rajith,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Description of problem:
When reloading a large acl file , the broker core dumps.
This surfaced while running the attached reproducer.

How reproducible:
Always -  reproducer attached.

Steps to Reproduce:
1. Start the broker with the acl module and and --acl-file /tmp/policy.acl
2. The initial acl file should contain only ""acl allow all all""
3. run the message_sender.py (This program will keep on publishing to
amq.direct)
4. run acl_reloader.py with --mode allow | deny a few times

Actual results:
The broker core dumps.

Expected results:
The broker should continue to work after reloading the acl file properly.

Additional info:

Following is the backtrace from the code dump.

   1.
      (gdb) bt
   2.
      #0  0x00cbe422 in __kernel_vsyscall ()
   3.
      #1  0x00183781 in raise () from /lib/libc.so.6
   4.
      #2  0x0018504a in abort () from /lib/libc.so.6
   5.
      #3  0x001c1619 in __libc_message () from /lib/libc.so.6
   6.
      #4  0x001c7a71 in malloc_printerr () from /lib/libc.so.6
   7.
      #5  0x001ca363 in munmap_chunk () from /lib/libc.so.6
   8.
      #6  0x040a1681 in operator delete(void*) () from /usr/lib/libstdc++.so.6
   9.
      #7  0x0035243e in qpid::acl::AclData::clear (this=0x8221328) at
qpid/acl/AclData.cpp:40
  10.
      #8  0x003524ad in qpid::acl::AclData::~AclData (this=0x8221328,
__in_chrg=<value optimized out>) at qpid/acl/AclData.cpp:259
  11.
      #9  0x003515a8 in checked_delete<qpid::acl::AclData> (x=<value optimized
out>) at /usr/include/boost/checked_delete.hpp:34
  12.
      #10 boost::detail::sp_counted_impl_p<qpid::acl::AclData>::dispose
(x=<value optimized out>) at /usr/include/boost/detail/sp_counted_impl.hpp:78
  13.
      #11 0x0034e50b in boost::detail::sp_counted_base::release (this=<value
optimized out>) at /usr/include/boost/detail/sp_counted_base_gcc_x86.hpp:145
  14.
      #12 ~shared_count (this=<value optimized out>) at
/usr/include/boost/detail/shared_count.hpp:216
  15.
      #13 ~shared_ptr (this=<value optimized out>) at
/usr/include/boost/shared_ptr.hpp:165
  16.
      #14 qpid::acl::Acl::authorise (this=<value optimized out>) at
qpid/acl/Acl.cpp:86
  17.
      #15 0x00add720 in qpid::broker::SemanticState::route (this=0x82218a0,
msg={p_ = 0xb5644868}, strategy=@0xb61fe178)
  18.
          at qpid/broker/SemanticState.cpp:447
  19.
      #16 0x00ade215 in qpid::broker::SemanticState::handle (this=0x82218a0,
msg={p_ = 0xb5644868}) at qpid/broker/SemanticState.cpp:415
  20.
............"
Bug,QPID-3199,12503979,Severe but difficult to diagnose lock error in qpid::sys::StateMonitor,astitcher,astitcher,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,"The qpid::sys::StateMonitor class has 4 member functions liker this:
  void waitFor(Enum s) { ScopedWait(*this); while (s != state) wait(); }

However the ScopeWait(*this); is in error, because it creates a temporary ScopedWait and then immediately destroys it. Instead of locking this and then unlocking it at the end of the function execution.

What was meant was:
  void waitFor(Enum s) { ScopedWait w(*this); while (s != state) wait(); }

which creates a local variable w which is destroyed at the end of the function execution unlocking this.

It is possible that the compiler/options we use do not actually exhibit this bug. As the correct behaviour may not actually be implemented by all compilers.

If this bug exhibits it might show as StateMonitor::waitFor() never detecting the desired state for instance. It is remarkable that this code has been in the codebase for 3.5 years and we've not noticed any bug caused by it.

This bug was detected by the work on QPID-3004: The clang++ compiler detected that the value being returned by the constructor was not being used at all."
Bug,QPID-1719,12416300,Management object IDs out of sync on cluster,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,Due to update session not using id from exclusive range (which in turn was a regression from a lost update as a result of dump->update renaming r737971).
Bug,QPID-2175,12439421,C++ broker should use userid@domain when authenticating messages.,rajith,rajith,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"The c++ broker currently strips the domain from the user id when authenticating messages.
This is to accommodate the java client issue defined in QPID-2174

Once that is fixed the c++ broker should take the domain into account when authenticating messages.
If a message contains a user id without a domain, the broker should use the realm as the default domain."
Bug,QPID-2507,12462073,C++ broker can deadlock when processing a bind.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Rarely happens, but I was lucky enough to catch this on the debugger.

Broker locks due to lock inversion.   Here's the flow:

thread 1 (broker): 
1) gets bind request for the management topic exchange
2) binds to the management topic exchange  [takes topic->lock]
3) attempts to call management agent allocId() [takes mgmt agent->userLock]

At the same time:

thread 4 (mgmt agent periodic timer)
1) periodic processing [takes mgmt agent->userLock]
2) call topicexchange::route() [takes topic->lock]

thread one holds the topic->lock, tries to take mgmt agent->userLock
thread four holds mgmt agent->userLock, tries to take topic->lock

deadlock."
Bug,QPID-4675,12639590,[AMQP 1.0] handle receiving link from direct exchange even with no filter specified,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"If you create a receiver from a direct exchange without specifying a subject filter, then the broker detaches the link due to not having a binding ley. However it would be better (as is the case for 0-10) to simply use the empty string in that case."
Bug,QPID-2062,12433665,ACL processing does not handle wildcards correctly,rajith,platten,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"There seems to be a problem processing wildcards in ACL. e.g.

ACL:
acl allow tester@QPID unbind exchange  name=foo queuename=bar routingkey=foo.*

Command:
qpid-config -a tester/tester@localhost unbind foo bar foo.bar

Broker:
2009-aug-21 11:47:42 info ACL Deny id:tester@QPID action:unbind ObjectType:exchange Name:foo
2009-aug-21 11:47:42 error Execution exception: not-allowed: ACL denied exchange unbind request from tester@QPID (qpid/broker/SessionAdapter.cpp:203)

I believe this is due to a bug in AclData::lookup
    }else if (!matchProp(paramItr->second, pMItr->second)){
should read
    }else if (!matchProp(pMItr->second, paramItr->second)){


"
Bug,QPID-3352,12513803,Federation bridge doesn't recover from session errors,tross,dillaman,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"When creating a federated route (bridge) to another broker, if the bridge's AMQP session encounters an error (such as a queue reaching its maximum capacity upon delivery), messages stop flowing.  Additionally, if during broker bootstrapping, if the source queue/exchange does not yet exist, the bridge never attempts to recover.  Finally, when simulating a network failure, dynamically created bridge queues are not always recreated for dynamic federation routes.

"
Bug,QPID-3153,12501758,sasl_fed_ex_*_cluster tests should test for aisexec running,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,use ais_exec to make sure that aisexec is actually running.  also use with_ais_group to force proper group membership for openais.
Bug,QPID-1891,12427149,fix declaration problems with boost 1_33_1,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Under Boost 1.33.1, the use of     boost::starts_with    caused compilation problems like this:

    /usr/include/boost/algorithm/string/iterator_range.hpp:289: error: make_iterator_range is already declared in this scope


So I replaced it with C stdlib equivalents."
Bug,QPID-2392,12455496,Powershell scripts not included in release source kits,shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,The release process for 0.6 didn't contain the Powershell scripts for the C++ broker/client test suite on Windows.
Bug,QPID-3304,12510092,Tagged federation messages in a transaction can cause subsequent dequeue to fail,kpvdr,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"E.g. with Error dequeuing message, persistence id not set (MessageStoreImpl.cpp:1355) (exact error depends on store used).

To reproduce, bind a durable queue to an exchange with a given binding key the set up a route between that same exchange on two brokers with the 'source broker' being the one with the durable queue bound to it. Then bind a queue on the 'destination' broker with the same binding key as used for the durable queue. Then publish a transactional message to the source brokers exchange with a matching routing key. The message will be enqueued on both the durable queue and the federation routes temporary bridge queue. However the persistence id for the message, set when enqueueing on the durable queue is lost and subsequent attempts to dequeue to fail.

The problem is that the copy-on-write strategy used to workaround QPID-2670 means that the message on which the persistent store id is set is not then pushed onto the appropriate queues, the copy is (and the copy may not have the persistence id set on it). "
Bug,QPID-4022,12558180,C++ Broker connection limits by host ip and by user name can get confused,chug,chug,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"The current ACL module uses the ConnectionObserver to watch the life cycle of connections. It tries to disallow the creation of too many connections by a user or from an IP address. However, the method is uses is flawed especially in the cluster case.

A better strategy to use it to provide approvers in the ConnectionObserver scheme and then to call them:
1. Limits by IP address are disapproved in the ConnectionFactories. If the limit is reached then the factory does not create the connection codec and the connection never begins a life cycle. This is enforced at the same point in code as the per-broker --max-connection limit using similar enforcement methods.

2. Limits by user name are disapproved at the same point as user authentication happens. Details to follow.
"
Bug,QPID-4634,12635941,C++ broker Boost-related compile errors,astitcher,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"These compile errors started appearing recently:


/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp:34:33: error: boost/make
_shared.hpp: No such file or directory
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp: In copy co
nstructor ?쁞oost::ptr_sequence_adapter<std::basic_string<char, std::char_traits<
char>, std::allocator<char> >, std::vector<void*, std::allocator<void*> >, boost
::heap_clone_allocator>::ptr_sequence_adapter(const boost::ptr_sequence_adapter<
std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vec
tor<void*, std::allocator<void*> >, boost::heap_clone_allocator>&)??
/usr/include/boost/ptr_container/detail/reversible_ptr_container.hpp:294: error:
 ?쁞oost::ptr_container_detail::reversible_ptr_container<Config, CloneAllocator>:
:reversible_ptr_container(const boost::ptr_container_detail::reversible_ptr_cont
ainer<Config, CloneAllocator>&) [with Config = boost::ptr_container_detail::sequ
ence_config<std::basic_string<char, std::char_traits<char>, std::allocator<char>
 >, std::vector<void*, std::allocator<void*> > >, CloneAllocator = boost::heap_c
lone_allocator]??is private
/usr/include/boost/ptr_container/ptr_sequence_adapter.hpp:148: error: within thi
s context

/usr/include/boost/ptr_container/ptr_vector.hpp: In copy constructor ?쁞oost::ptr
_vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, 
boost::heap_clone_allocator, std::allocator<void*> >::ptr_vector(const boost::pt
r_vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
 boost::heap_clone_allocator, std::allocator<void*> >&)??
/usr/include/boost/ptr_container/ptr_vector.hpp:35: note: synthesized method ?쁞o
ost::ptr_sequence_adapter<std::basic_string<char, std::char_traits<char>, std::a
llocator<char> >, std::vector<void*, std::allocator<void*> >, boost::heap_clone_
allocator>::ptr_sequence_adapter(const boost::ptr_sequence_adapter<std::basic_st
ring<char, std::char_traits<char>, std::allocator<char> >, std::vector<void*, st
d::allocator<void*> >, boost::heap_clone_allocator>&)??first required here 
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp: In copy constructor ?쁰p
id::broker::MessageSelectorEnv::MessageSelectorEnv(const qpid::broker::MessageSe
lectorEnv&)??
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp:89: note: synthesized me
thod ?쁞oost::ptr_vector<std::basic_string<char, std::char_traits<char>, std::all
ocator<char> >, boost::heap_clone_allocator, std::allocator<void*> >::ptr_vector
(const boost::ptr_vector<std::basic_string<char, std::char_traits<char>, std::al
locator<char> >, boost::heap_clone_allocator, std::allocator<void*> >&)??first r
equired here 

/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp: In member function ?쁞oo
l qpid::broker::Selector::filter(const qpid::broker::Message&)??
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp:175: note: synthesized m
ethod ?쁰pid::broker::MessageSelectorEnv::MessageSelectorEnv(const qpid::broker::
MessageSelectorEnv&)??first required here 
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp: In function ?쁞oost::sha
red_ptr<qpid::broker::Selector> qpid::broker::returnSelector(const std::string&)
??
/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp:185: error: ?쁬ake_shared
??is not a member of ?쁞oost??/qpidbuilds/trunk/qpid/cpp/src/qpid/broker/Selector.cpp:185: error: expected pri
mary-expression before ????token
make[2]: *** [src/CMakeFiles/qpidbroker.dir/qpid/broker/Selector.o] Error 1
"
Bug,QPID-1449,12408202,C++ broker on Windows with --mgmt-enable no triggers crash setting up client,shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"If the C++ broker is started on Windows with --mgmt-enable no, the exchange to set up a new client causes an assert in the C++ library. This is because the federation tag doesn't have an associated string - when encoding the value for qpid.federation_tag, the value is invalid.

When running on Linux with the same option, the qpid.federation_tag value is an empty string."
Bug,QPID-3549,12527186,A queue created with qpid.last_value_queue=0 behaves like a last-value-queue,tross,tross,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"When creating a queue, the broker only looks to see if the boolean arguments are present, not whether they are present and True.  Therefore, explicitly stating qpid.last_value_queue=0 will still result in last-value-queue semantics.

This may be a general problem with boolean arguments."
Bug,QPID-2347,12446016,Subscribers are never notified if queue is deleted from under them,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,a resource-deleted exception should be thrown
Bug,QPID-2481,12461238,Deadlock in Qpid 0.6,tross,detzi,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Hi,

I think I've found a deadlock while running the cpp broker 0.6. Since strace does not report any activity in the borker I attached with the gdb. Here's the gdb output:

Listing of threads:

(gdb) info thr
  10 Thread 0x417f9950 (LWP 5061)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  9 Thread 0x41ffa950 (LWP 5062)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  8 Thread 0x427fb950 (LWP 5063)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  7 Thread 0x42ffc950 (LWP 5064)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  6 Thread 0x437fd950 (LWP 5065)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  5 Thread 0x40e3c950 (LWP 5066)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
* 4 Thread 0x43ffe950 (LWP 5067)  0x00007f3655944176 in pthread_rwlock_rdlock () from /lib/libpthread.so.0
  3 Thread 0x447ff950 (LWP 5068)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  2 Thread 0x45000950 (LWP 5069)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
  1 Thread 0x7f3657f21770 (LWP 5060)  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0


When switching to thread 4 and examining the mutex I found that the mutex's owner is thread 6 (__writer = 5065).

(gdb) thr 4
[Switching to thread 4 (Thread 0x43ffe950 (LWP 5067))]#0  0x00007f3655944176 in pthread_rwlock_rdlock () from /lib/libpthread.so.0
(gdb) bt
#0  0x00007f3655944176 in pthread_rwlock_rdlock () from /lib/libpthread.so.0
#1  0x00007f3657981b80 in qpid::sys::RWlock::rlock (this=0x178bcf8) at ../include/qpid/sys/posix/Mutex.h:141
#2  0x00007f3657981e2d in ScopedRlock (this=0x43fec700, l=@0x178bcf8) at ../include/qpid/sys/Mutex.h:53
#3  0x00007f3657a3f52c in qpid::broker::TopicExchange::route (this=0x178bcc0, msg=@0x43fec850, routingKey=@0x43fecb40) at qpid/broker/TopicExchange.cpp:300
#4  0x00007f3657a6a5ee in qpid::broker::ManagementExchange::route (this=0x178bcb0, msg=@0x43fec850, routingKey=@0x43fecb40, args=0x0)
    at qpid/management/ManagementExchange.cpp:52
#5  0x00007f3657a4e635 in qpid::management::ManagementAgent::sendBuffer (this=0x7f3657ef0010, buf=@0x43fecad0, length=138, exchange=
        {px = 0x43fecb10, pn = {pi_ = 0x8a43fec870}}, routingKey=
        {static npos = 18446744073709551615, _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, _M           _p = 0x43fecb40 ""짢횥016\025\v6\177""}}) at qpid/management/ManagementAgent.cpp:317
#6  0x00007f3657a58c55 in qpid::management::ManagementAgent::addObject (this=0x7f3657ef0010, object=0x7f35be205680, persistId=0, publishNow=true)
    at qpid/management/ManagementAgent.cpp:207
#7  0x00007f365793fc42 in Connection (this=0x7f35be242900, out_=0x7f35be23b228, broker_=@0x17816a0, mgmtId_=@0x7f364c59b0e8, ssf=0, isLink_=false, objectId=0)
    at qpid/broker/Connection.cpp:101
#8  0x00007f36579fb1bc in qpid::broker::SecureConnectionFactory::create (this=0x1787ef0, v={major_ = 0 '\0', minor_ = 10 '\n'}, out=@0x7f364c59b0e0, 
    id=@0x7f364c59b0e8, conn_ssf=0) at qpid/broker/SecureConnectionFactory.cpp:50
#9  0x00007f365741eabe in qpid::sys::AsynchIOHandler::readbuff (this=0x7f364c59b0e0, buff=0x7f363996fbb0) at qpid/sys/AsynchIOHandler.cpp:147
#10 0x00007f3657a6d74f in boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator() (
    this=0x7f35be2447a0, p=0x7f364c59b0e0, a1=@0x7f35be244640, a2=0x7f363996fbb0) at /usr/include/boost/bind/mem_fn_template.hpp:274
#11 0x00007f3657a6ebdb in boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> >::operator()<boost::_mfi::mf2<void, qpid           ::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&> > (
    this=0x7f35be2447b0, f=@0x7f35be2447a0, a=@0x43ffd850) at /usr/include/boost/bind.hpp:371
#12 0x00007f3657a6ec4f in boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost           ::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >::operator()<qpid::sys::AsynchIO, qpid::sys::AsynchIOBufferBase*> (
    this=0x7f35be2447a0, a1=@0x7f35be244640, a2=@0x43ffd888) at /usr/include/boost/bind/bind_template.hpp:61
#13 0x00007f3657a6eca1 in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sy           s::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, void, qpid::sys           ::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke (function_obj_ptr=@0x7f35be2447a0, a0=@0x7f35be244640, a1=0x7f363996fbb0)
    at /usr/include/boost/function/function_template.hpp:152
#14 0x00007f36572ce1f9 in boost::function2<void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator() (this=0x7f35be244798, a0=@0x7f35be244640, 
    a1=0x7f363996fbb0) at /usr/include/boost/function/function_template.hpp:989
#15 0x00007f36572c3c56 in qpid::sys::posix::AsynchIO::readable (this=0x7f35be244640, h=@0x7f35be244648) at qpid/sys/posix/AsynchIO.cpp:435
#16 0x00007f36572cbc87 in boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>::operator() (this=0x7f35be244660, p=0x7f35be244640, 
    a1=@0x7f35be244648) at /usr/include/boost/bind/mem_fn_template.hpp:162
#17 0x00007f36572cc7c5 in boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::posix::A           synchIO, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> > (this=0x7f35be244670, f=@0x7f35be244660, a=@0x43ffdc40)
    at /usr/include/boost/bind.hpp:292
#18 0x00007f36572cc82f in boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::v           alue<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >::operator()<qpid::sys::DispatchHandle> (this=0x7f35be244660, a1=@0x7f35be244648)
    at /usr/include/boost/bind/bind_template.hpp:32
#19 0x00007f36572cc879 in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sy           s::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke (
    function_obj_ptr=@0x7f35be244660, a0=@0x7f35be244648) at /usr/include/boost/function/function_template.hpp:152
#20 0x00007f36574288a3 in boost::function1<void, qpid::sys::DispatchHandle&>::operator() (this=0x7f35be244658, a0=@0x7f35be244648)
    at /usr/include/boost/function/function_template.hpp:989
#21 0x00007f3657420afb in qpid::sys::DispatchHandle::processEvent (this=0x7f35be244648, type=qpid::sys::Poller::READABLE) at qpid/sys/DispatchHandle.cpp:278
#22 0x00007f36572dccf2 in qpid::sys::Poller::Event::process (this=0x43ffde20) at ./qpid/sys/Poller.h:123
#23 0x00007f36572dc23b in qpid::sys::Poller::run (this=0x17809d0) at qpid/sys/epoll/EpollPoller.cpp:483
#24 0x00007f36574288f7 in qpid::sys::Dispatcher::run (this=0x7fffcd3894b0) at qpid/sys/Dispatcher.cpp:37
#25 0x00007f36572d2743 in runRunnable (p=0x7fffcd3894b0) at qpid/sys/posix/Thread.cpp:35
#26 0x00007f3655940fc7 in start_thread () from /lib/libpthread.so.0
#27 0x00007f3655c255ad in clone () from /lib/libc.so.6
#28 0x0000000000000000 in ?? ()
(gdb) frame 1
#1  0x00007f3657981b80 in qpid::sys::RWlock::rlock (this=0x178bcf8) at ../include/qpid/sys/posix/Mutex.h:141
141     ../include/qpid/sys/posix/Mutex.h: No such file or directory.
        in ../include/qpid/sys/posix/Mutex.h
(gdb) p *this
$12 = {<boost::noncopyable_::noncopyable> = {<No data fields>}, rwlock = {__data = {__lock = 0, __nr_readers = 0, __readers_wakeup = 1, __writer_wakeup = 0, 
      __nr_readers_queued = 1, __nr_writers_queued = 0, __writer = 5065, __shared = 0, __pad1 = 0, __pad2 = 0, __flags = 0}, 
    __size = ""\000\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000\001\000\000\000\000\000\000\000횋횥023"", '\0' <repeats 26 times>, ""6\177\000"", 
    __align = 0}}


Switching to thread 6 we can see that the mutex owner is thread 4 (__owner = 5067).


(gdb) thr 6
[Switching to thread 6 (Thread 0x437fd950 (LWP 5065))]#0  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
(gdb) bt
#0  0x00007f3655947384 in __lll_lock_wait () from /lib/libpthread.so.0
#1  0x00007f3655942c0b in _L_lock_312 () from /lib/libpthread.so.0
#2  0x00007f3655942631 in pthread_mutex_lock () from /lib/libpthread.so.0
#3  0x00007f36578bcc76 in qpid::sys::Mutex::lock (this=0x7f3657ef00f0) at ../include/qpid/sys/posix/Mutex.h:116
#4  0x00007f36578bcf23 in ScopedLock (this=0x437fa590, l=@0x7f3657ef00f0) at ../include/qpid/sys/Mutex.h:33
#5  0x00007f3657a4cac2 in qpid::management::ManagementAgent::allocateId (this=0x7f3657ef0010, object=0x7f35b1c13c10) at qpid/management/ManagementAgent.cpp:1288
#6  0x00007f3657975542 in Binding (this=0x7f35b1c13c10, _key=@0x437fa820, _queue={px = 0x437fa780, pn = {pi_ = 0x437fa820}}, parent=0x178bd30, _args=
            {values = {_M_t = {_M_impl = {<std::allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char>            >, boost::shared_ptr<qpid::framing::FieldValue> > > >> = {<__gnu_cxx::new_allocator<std::_Rb_tree_node<std::pair<const std::basic_string<char, std::char_traits<ch           ar>, std::allocator<char> >, boost::shared_ptr<qpid::framing::FieldValue> > > >> = {<No data fields>}, <No data fields>}, _M_key_compare = {<std::binary_function<           std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>> = {<No data            fields>}, <No data fields>}, _M_header = {_M_color = 24689968, _M_parent = 0x437fa780, _M_left = 0x437fa820, _M_right = 0x7f35b1c13c10}, _M_node_count = 0}}}}, 
    origin=@0x437fa830) at qpid/broker/Exchange.cpp:328
#7  0x00007f3657a402f6 in qpid::broker::TopicExchange::bind (this=0x178bcc0, queue={px = 0x437fa8c0, pn = {pi_ = 0x178bcc0}}, routingKey=@0x437faa20, 
    args=0x7f35b1c0e888) at qpid/broker/TopicExchange.cpp:209
#8  0x00007f3657a6a45f in qpid::broker::ManagementExchange::bind (this=0x178bcb0, queue={px = 0x437faa50, pn = {pi_ = 0x178bcb0}}, routingKey=@0x437faa20, 
    args=0x7f35b1c0e888) at qpid/management/ManagementExchange.cpp:60
#9  0x00007f3657a1dc9b in qpid::broker::SessionAdapter::ExchangeHandlerImpl::bind (this=0x7f35b1c0b800, queueName=@0x7f35b1c0e870, exchangeName=@0x7f35b1c0e878, 
    routingKey=@0x7f35b1c0e880, arguments=@0x7f35b1c0e888) at qpid/broker/SessionAdapter.cpp:189
#10 0x00007f36573206c8 in qpid::framing::ExchangeBindBody::invoke<qpid::framing::AMQP_ServerOperations::ExchangeHandler> (this=0x7f35b1c0e860, 
    invocable=@0x7f35b1c0b800) at ./qpid/framing/ExchangeBindBody.h:88
#11 0x00007f3657319316 in qpid::framing::AMQP_ServerOperations::ExchangeHandler::Invoker::visit (this=0x437fada0, body=@0x7f35b1c0e860)
    at qpid/framing/ServerInvoker.cpp:642
#12 0x00007f3657328121 in qpid::framing::ExchangeBindBody::accept (this=0x7f35b1c0e860, v=@0x437fada0) at ./qpid/framing/ExchangeBindBody.h:92
#13 0x00007f365731b3b8 in qpid::framing::AMQP_ServerOperations::Invoker::visit (this=0x437fae50, body=@0x7f35b1c0e860) at qpid/framing/ServerInvoker.cpp:353
#14 0x00007f3657328121 in qpid::framing::ExchangeBindBody::accept (this=0x7f35b1c0e860, v=@0x437fae50) at ./qpid/framing/ExchangeBindBody.h:92
#15 0x00007f3657a3c975 in qpid::framing::invoke<qpid::broker::SessionAdapter> (target=@0x7f35b1c0b7e8, body=@0x7f35b1c0e860) at ./qpid/framing/Invoker.h:67
#16 0x00007f3657a35e43 in qpid::broker::SessionState::handleCommand (this=0x7f35b1c0b4b0, method=0x7f35b1c0e860, id=@0x437fb100)
    at qpid/broker/SessionState.cpp:197
#17 0x00007f3657a362b8 in qpid::broker::SessionState::handleIn (this=0x7f35b1c0b4b0, frame=@0x437fbce0) at qpid/broker/SessionState.cpp:329
#18 0x00007f3657a3af3b in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(q           pid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle (this=0x7f35b1c0b640, t=@0x437fbce0)
    at ./qpid/framing/Handler.h:67
#19 0x00007f36573d59da in qpid::amqp_0_10::SessionHandler::handleIn (this=0x7f35b1c0c770, f=@0x437fbce0) at qpid/amqp_0_10/SessionHandler.cpp:93
#20 0x00007f3657a3af3b in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(q           pid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn(qpid::framing::AMQFrame&))>::handle (this=0x7f35b1c0c780, t=@0x437fbce0)
    at ./qpid/framing/Handler.h:67
#21 0x00007f365794110b in qpid::framing::Handler<qpid::framing::AMQFrame&>::operator() (this=0x7f35b1c0c780, t=@0x437fbce0) at ./qpid/framing/Handler.h:42
#22 0x00007f365794dec1 in qpid::broker::ConnectionHandler::handle (this=0x7f35b1c10120, frame=@0x437fbce0) at qpid/broker/ConnectionHandler.cpp:70
#23 0x00007f365793e4e8 in qpid::broker::Connection::received (this=0x7f35b1c0ff40, frame=@0x437fbce0) at qpid/broker/Connection.cpp:138
#24 0x00007f36578ffb36 in qpid::amqp_0_10::Connection::decode (this=0x7f35b1c602b0, buffer=0x7f35be3822c0 ""\017\001"", size=71)
    at qpid/amqp_0_10/Connection.cpp:58
#25 0x00007f36579f9fff in qpid::broker::SecureConnection::decode (this=0x7f35b1a42fe0, buffer=0x7f35be3822c0 ""\017\001"", size=71)
    at qpid/broker/SecureConnection.cpp:42
#26 0x00007f365741e59d in qpid::sys::AsynchIOHandler::readbuff (this=0x7f35be206e80, buff=0x7f35be0fe6b0) at qpid/sys/AsynchIOHandler.cpp:134
#27 0x00007f3657a6d74f in boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator() (
    this=0x7f35be209090, p=0x7f35be206e80, a1=@0x7f35be208f30, a2=0x7f35be0fe6b0) at /usr/include/boost/bind/mem_fn_template.hpp:274
#28 0x00007f3657a6ebdb in boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> >::operator()<boost::_mfi::mf2<void, qpid           ::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list2<qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*&> > (
    this=0x7f35be2090a0, f=@0x7f35be209090, a=@0x437fc850) at /usr/include/boost/bind.hpp:371
#29 0x00007f3657a6ec4f in boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost           ::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >::operator()<qpid::sys::AsynchIO, qpid::sys::AsynchIOBufferBase*> (
    this=0x7f35be209090, a1=@0x7f35be208f30, a2=@0x437fc888) at /usr/include/boost/bind/bind_template.hpp:61
#30 0x00007f3657a6eca1 in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::sys::AsynchIOHandler, qpid::sy           s::AsynchIO&, qpid::sys::AsynchIOBufferBase*>, boost::_bi::list3<boost::_bi::value<qpid::sys::AsynchIOHandler*>, boost::arg<1>, boost::arg<2> > >, void, qpid::sys           ::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::invoke (function_obj_ptr=@0x7f35be209090, a0=@0x7f35be208f30, a1=0x7f35be0fe6b0)
    at /usr/include/boost/function/function_template.hpp:152
#31 0x00007f36572ce1f9 in boost::function2<void, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator() (this=0x7f35be209088, a0=@0x7f35be208f30, 
    a1=0x7f35be0fe6b0) at /usr/include/boost/function/function_template.hpp:989
#32 0x00007f36572c3c56 in qpid::sys::posix::AsynchIO::readable (this=0x7f35be208f30, h=@0x7f35be208f38) at qpid/sys/posix/AsynchIO.cpp:435
#33 0x00007f36572cbc87 in boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>::operator() (this=0x7f35be208f50, p=0x7f35be208f30, 
    a1=@0x7f35be208f38) at /usr/include/boost/bind/mem_fn_template.hpp:162
#34 0x00007f36572cc7c5 in boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> >::operator()<boost::_mfi::mf1<void, qpid::sys::posix::A           synchIO, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> > (this=0x7f35be208f60, f=@0x7f35be208f50, a=@0x437fcc40)
    at /usr/include/boost/bind.hpp:292
#35 0x00007f36572cc82f in boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::v           alue<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >::operator()<qpid::sys::DispatchHandle> (this=0x7f35be208f50, a1=@0x7f35be208f38)
    at /usr/include/boost/bind/bind_template.hpp:32
#36 0x00007f36572cc879 in boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, qpid::sy           s::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke (
---Type <return> to continue, or q <return> to quit---q    
function_obj_Quit
(gdb) frame 3
#3  0x00007f36578bcc76 in qpid::sys::Mutex::lock (this=0x7f3657ef00f0) at ../include/qpid/sys/posix/Mutex.h:116
116     ../include/qpid/sys/posix/Mutex.h: No such file or directory.
        in ../include/qpid/sys/posix/Mutex.h
(gdb) p *this
$13 = {<boost::noncopyable_::noncopyable> = {<No data fields>}, mutex = {__data = {__lock = 2, __count = 1, __owner = 5067, __nusers = 1, __kind = 1, 
      __spins = 0, __list = {__prev = 0x0, __next = 0x0}}, 
    __size = ""\002\000\000\000\001\000\000\000횏횥023\000\000\001\000\000\000\001"", '\0' <repeats 22 times>, __align = 4294967298}}


Let's summarize:

[5067] thread 4 tries a readlock on the mutex (which is already (write)locked by thread 6)
[5065] thread 6 tries a lock on the mutex (which is already owned/locked by thread 4)

I experience such things quiet often. 

Regards,
Daniel
"
Bug,QPID-3170,12502710,"Deleting/restoring dynamic federation routes, brokers will not relearn remote bindings that match local keys.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Should a dynamic federation route be deleted, then restored, remote bindings that use the same key as local bindings are not restored."
Bug,QPID-561,12377259,c++ broker using incorrect value for xa-ok.,,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,JMS AMQP 0-x,,,,,"The qpidd broker uses the constant XA_OK=8, but the 0-10 XML defines xa-ok=0. The value 8 looks like a 0-9 throwback.
It appears that python uses the incorrect value also, since changing it to - broke the python xa tests with the broker.

constants.h now provides generated C++ constants for all AMQP constants define in XML, we should replace all hand-written constants with constants based on the generated ones."
Bug,QPID-4193,12601582,Multi-link Federation links may not recover during a failover,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"Occasionally the cluster federation multilink failover test will fail with the following error:


cluster_tests.ShortTests.test_federation_multilink_failover ................................................................................................................... fail
Error during test:  Traceback (most recent call last):
    File ""/home/kgiusti/Desktop/work/qpid/trunk/build/qpid/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/kgiusti/Desktop/work/qpid/trunk/qpid/cpp/src/tests/cluster_tests.py"", line 992, in test_federation_multilink_failover
      assert self._verify_federation(src_cluster[1], ""FedX/two"", dst_cluster[1], ""destQ2"")
  AssertionError
Totals: 2 tests, 1 passed, 0 skipped, 0 ignored, 1 failed"
Bug,QPID-2965,12491844,Latest source build fails with --without-sasl argument to configure,mgoulish,badone,Closed,Fixed,2013-07-29 18:38,C++,C++ Broker,,,,,,,"git clone git://git.apache.org/qpid.git

./configure --prefix=/home/brad/working/installs --without-sasl

The build fails with;

libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../include -I../include -I. -I=. -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -DQPID_LIBEXEC_DIR=\""/home/brad/working/installs/libexec/qpid\"" -g -O2 -MT qpid/SaslFactory.lo -MD -MP -MF qpid/.deps/SaslFactory.Tpo -c qpid/SaslFactory.cpp  -fPIC -DPIC -o qpid/.libs/SaslFactory.o
qpid/SaslFactory.cpp:48:21: error: prototype for 'std::auto_ptr<qpid::Sasl> qpid::SaslFactory::create(const std::string&, const std::string&, const std::string&, const std::string&, int, int)' does not match any in class 'qpid::SaslFactory'
./qpid//SaslFactory.h:37:25: error: candidate is: std::auto_ptr<qpid::Sasl> qpid::SaslFactory::create(const std::string&, const std::string&, const std::string&, const std::string&, int, int, bool)
make[3]: *** [qpid/SaslFactory.lo] Error 1
make[3]: Leaving directory `/home/brad/working/src/qpid/qpid/cpp/src'
make[2]: *** [all-recursive] Error 1
make[2]: Leaving directory `/home/brad/working/src/qpid/qpid/cpp/src'
make[1]: *** [all] Error 2
make[1]: Leaving directory `/home/brad/working/src/qpid/qpid/cpp/src'
make: *** [all-recursive] Error 1
"
Bug,QPID-2357,12446362,Broker boot sequence doesn't synchronize when clustered.,aconway,jrd,Closed,Fixed,2013-07-29 15:53,C++,C++ Broker,,,,,,,"I discovered this when debugging something else.  If you start broker 1 with a data-dir, and broker 2 with no data-dir or a different one, you can (almost always) end up with a different boot sequence.  That means if you cluster these two together, when the updatee gets updates, he'll use different OIDs that the master.
"
Bug,QPID-2132,12437537,qmf-agent crashes occasionally on Control-C,,kgiusti,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,,,,,,,"Reproducible on trunk.

Run the qmf-agent (cpp/examples), hit control-C to interrupt it - segfaults about 1 or 2 times out of ten.

Race condition on cleanup of ManagementAgentImpl class.  I'll post a patch shortly....

"
Bug,QPID-644,12380600,Broker core dump when running JMS tests,,arnaudsimon,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,,,,,,,"this is the backtrace:
#0  qpid::framing::FrameSet::getContentSize (this=0x9d)
    at /usr/lib/gcc/i386-redhat-linux/4.1.2/../../../../include/c++/4.1.2/bits/stl_iterator.h:650
#1  0x00561712 in qpid::broker::Message::contentSize (this=0x1)
    at qpid/broker/Message.cpp:200
#2  0x00546316 in qpid::broker::DeliveryRecord::subtractFrom (this=0x9a4d47f0, 
    prefetch=@0x9a4d47d8) at qpid/broker/DeliveryRecord.cpp:146
#3  0x005830ef in qpid::broker::SemanticState::acknowledged (this=0x9a4d4798, 
    delivery=@0x9a4d47f0) at qpid/broker/SemanticState.cpp:397
#4  0x0058c1f1 in std::for_each<std::_List_iterator<qpid::broker::DeliveryRecord>, boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::broker::SemanticState, qpid::broker::DeliveryRecord const&>, boost::_bi::list2<boost::_bi::value<qpid::broker::SemanticState*>, boost::arg<1> > > > (__first={_M_node = 0x9a4d47e8}, 
    __last={_M_node = 0x9feb3f8}, __f=
        {f_ = {f_ = {__pfn = 0x5830c0 <qpid::broker::SemanticState::acknowledged(qpid::broker::DeliveryRecord const&)>, __delta = 0}}, l_ = {a1_ = {t_ = 0x9a4d4798}, a2_ = {<No data fields>}}})
    at /usr/include/boost/bind/mem_fn_template.hpp:149
#5  0x005848f1 in qpid::broker::SemanticState::ack (this=0x9a4d4798, first=
      {value = 2}, last={value = 2}, cumulative=false)
    at qpid/broker/SemanticState.cpp:369
#6  0x00584f83 in qpid::broker::SemanticState::ackRange (this=0x9a4d4798, 
    first={value = 2}, last={value = 2}) at qpid/broker/SemanticState.cpp:349
#7  0x00573e54 in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::broker::SemanticState, qpid::framing::SequenceNumber, qpid::framing::SequenceNumber>, boost::_bi::list3<boost::_bi::value<qpid::broker::SemanticState*>, boost::arg<1>, boost::arg<2> > >, void, qpid::framing::SequenceNumber, qpid::framing::SequenceNumber>::invoke (
---Type <return> to continue, or q <return> to quit---
    function_obj_ptr=
      {obj_ptr = 0x9a4d3ff0, const_obj_ptr = 0x9a4d3ff0, func_ptr = 0x9a4d3ff0, data = ""占?}"
Bug,QPID-548,12375872,Default queue for channel only set if declaration creates the queue,gsim,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,,,,,,,"The default queue for a channel is only set if the declaration creates the queue. It should be set to whatever queue was specified in the last declaration, regardless of whether the queue was created or not."
Bug,QPID-2171,12439395,"No checks made for reserved exchange names ""amq.*"" and ""qpid.*""",kpvdr,kpvdr,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,,,,,,,"The AMQP specification requires that exchange names starting with ""amq."" are reserved, and that a user must not be allowed to create exchanges starting with this string.

Similarly, exchanges starting with the string ""qpid."" have been reserved for system exchanges that are a part of the Qpid implementation but not specified in the AMQP specification.

Currently these checks are not being made by the broker. The broker should check the names of exchanges when they are declared from the client and return a 530 (not allowed) error if they start with either of these reserved strings. A test to check this functionality should be included with the fix."
Bug,QPID-52,12353771,"C++ build fails on RHEL 4, unordered_map not available.",aconway,aconway,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"c++ broker no longer builds on RHEL4. In 
particular the <tr1/memory> & <tr1/unordered_map> includes in FieldTable 
were causing errors"
Bug,QPID-1727,12416743,C++ broker does support flow to disk for non durable queues,,ritchiem,Closed,Fixed,2013-07-29 14:20,C++,C++ Broker,,,,,,,"Summary:

Currently Flow to Disk only works on durable queues. As a results the QueueBrowsingFlowToDiskTest is failing in the 0-10/C++ profile."
Bug,QPID-1364,12406592,C++ xml build failure: missing xqilla/xqilla-simple.hpp,,shuston,Closed,Fixed,2013-07-29 14:16,C++,C++ Broker,,,,,,,"Apparantly a missing prerequisite isn't detected/accounted for. The build gets:

mkdir qpid/xml/.libs
g++ -DHAVE_CONFIG_H -I. -I. -I. -Igen -I./gen -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -g -O2 -MT qpid/xml/XmlExchange.lo -MD -MP -MF qpid/xml/.deps/XmlExchange.Tpo -c qpid/xml/XmlExchange.cpp -fPIC -DPIC -o qpid/xml/.libs/XmlExchange.o
In file included from qpid/xml/XmlExchange.cpp:24:
qpid/xml/XmlExchange.h:30:36: xqilla/xqilla-simple.hpp: No such file or directory
In file included from qpid/xml/XmlExchange.cpp:24:
qpid/xml/XmlExchange.h:42: error: `XQQuery' was not declared in this scope

and things go downhill from there.
"
Bug,QPID-1495,12409537,[C++] Trunk Build Broken,,danushka,Closed,Fixed,2013-07-29 14:01,C++,C++ Broker,,,,,,,"I get the following error while building Qpid C++ with the latest SVN checkout, revision 722014.

qpid/broker/Message.cpp:349: error: no matching function for call to 'swap(boost::function<void ()(const boost::intrusive_ptr<qpid::broker::Message>&)>*&, boost::function<void ()(const boost::intrusive_ptr<qpid::broker::Message>&)>*&)'"
Bug,QPID-903,12393150,Federation (inter-broker) links cause C++ broker to hang,,tross,Closed,Fixed,2013-07-29 14:00,C++,C++ Broker,,,,,,,"When creating a ""Bridge"" queue for broker federation, the destination broker hangs and can only be stopped with a ""kill -9"".

To reproduce:

- Run two brokers.  Can be on the same host with different ports.
- Using the mgmt-cli utility, invoke the ""Connect"" method on the destination broker using the host and port of the source broker.
- Find the resultant ""link"" object.
- Invoke the ""Bridge"" method on the link object with the following arguments:

        src  amq.direct  routing-key 0 0
"
Bug,QPID-4692,12640340,ACL queue quotas are not updated when auto delete queues are deleted,chug,eallen,Closed,Fixed,2013-04-04 13:43,C++,C++ Broker,,,,,,,"When auto delete queues are deleted, the acl quotas are not being decremented. This can cause a user's quota to fill up. A broker restart is required to clear the situation."
Bug,QPID-2967,12492027,Windows broker fails to destroy connections if client exits abruptly,chug,chug,Closed,Fixed,2013-03-12 19:36,C++,C++ Broker,,,,,,,"Start the broker with a small number of connections:
  qpidd --auth no --no-data-dir --max-connections 2

Run a 'server' program, one that never exits on its own, and kill it with ^C. After doing this for the max-number of connections the server will not accept any more connections. Internally to the broker the Connection objects are never destroyed.

If the broker's client exits normally then the connection is destroyed properly. You can run HelloWorld against the windows broker beyond the max-connections count with no problem.

I know that ""the broker is not supported on Windows"" but the same problem is there for clients when the  broker goes away abruptly.



"
Bug,QPID-4435,12615969,Reconnect on connect failure hangs at third address to try,astitcher,astitcher,Closed,Fixed,2012-11-13 22:19,C++,C++ Broker,C++ Client,,,,,,"Necessary conditions to trigger hang:

* You are connecting to a name that resolves to 3 or more underlying network addresses.
* The first 2 addresses refuse the connection (there is no daemon listening on the appropriate port at that address).

In this case the client will attempt to connect to the third resolved address, but will hang forever waiting.

If you look at a server log that is listening on the third address then you will eventually see:
   ... error Connection ... No protocol received closing
because the server has received the connection and made the initial reply but has not heard back in the alloted time."
Bug,QPID-982,12394996,C++ rubygen code generator sensitive to ruby version.,,aconway,Closed,Fixed,2012-09-18 22:33,C++,C++ Broker,C++ Client,,,,,,"ruby generator does not work with some 1.8.6 versions of ruby, as discussed on qpid-dev:

> On Tue, Apr 29, 2008 at 1:41 PM, Gordon Sim <gsim@redhat.com> wrote:
> 
>> Senaka Fernando wrote:
>>
>>> My version of ruby is,
>>>
>>> ruby 1.8.6 (2007-06-07 patchlevel 36) [i486-linux]
>>>
>> The problem does appear to be related to ruby version. Arnaud hit the same
>> problem with 1.8.6.111 and on upgrading to 1.8.6.114 the problem went away
>> and the files were generated as expected.
>>"
Bug,QPID-4142,12599095,C++ broker connection counting username error when used in ha cluster and auth is EXTERNAL,chug,chug,Closed,Fixed,2012-09-07 20:33,C++,C++ Broker,,,,,,,"In a cluster setup with auth enabled and set to EXTERNAL then the Acl connection counting does not get the correct username associated with a shadowed connection.

The cluster member that accepts the connection accounts for the correct user name. Other cluster members that receive shadow connections see user name 'anonymous'."
Bug,QPID-3004,12495825,Qpid does not compile cleanly with clang++ compiler (2.8),,astitcher,Closed,Fixed,2011-05-09 21:05,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"The Clang project C++ compiler has got to the point where it can now compile the qpid C++ code.

There are some advantages of using this compiler over the GCC compiler that we've previously been using for Unix compiles:
  Much better error messages:
  Faster compiles
and of course there are disadvantages too.

In general I believe there is no portable code just ported code, but code that compiles under the most environments will naturally be the most portable and I'd assert the most bug free too. Therefore I think it is to the benefit of the Qpid if we get the C++ code to compile under clang++ too.

Currently there appear to be a vast number of warnings of the form:

In file included from ../../src-working/cpp/src/qpid/client/SessionImpl.h:35:
./qpid/framing/AMQP_ClientOperations.h:54:30: warning: extra ';' inside a class [-pedantic]
        ConnectionHandler(){};
                             ^

[You'll note that there is an indicator of where in the line the error occurs too as well as just the line no. - the variable pitch font messes it up though]

And there are some smaller number of actual compile errors."
Bug,QPID-2997,12495518,C++ broker creates duplicate management objects under rapid create/delete/create scenarios.,kgiusti,kgiusti,Closed,Fixed,2011-01-18 14:54,C++,C++ Broker,,,,,,,"When a management object (a queue, for example) is rapidly created, deleted and then recreated, the management agent in the broker may duplicate the object.  This only happens when the recreate cycle is done entirely within the mgmt periodic interval (default: 10 seconds)."
Bug,QPID-2916,12478587,C++ broker & Python client will silently truncate strings whose length is greater than the max length supported by the type.,kgiusti,kgiusti,Closed,Fixed,2010-10-28 21:41,C++,C++ Broker,C++ Client,Python Client,,,,,"While testing QMF, I attempted to send a string of length > 255 bytes as a str8.  Both the broker and the python client will encode the string by either truncating it, or incorrectly truncating the length."
Bug,QPID-2754,12469937,C++ broker crashes due to management object database corruption,kgiusti,kgiusti,Closed,Fixed,2010-10-28 13:02,C++,C++ Broker,QMF,,,,,,"Under high loads, the broker will occasionally crash in the ManagementAgent::handleGetQueryLH() or ManagementAgent::periodicProcessing() methods.   Valgrind also indicates invalid memory references from within these methods."
Bug,QPID-2460,12459635,configure doesn't check for presence of libtool correctly,,neilw,Closed,Fixed,2010-03-19 17:12,C++,C++ Broker,,,,,,,"If libtool is missing from the system, configure doesn't pick that up - breaking the 'make check' process."
Bug,QPID-2170,12439353,Enqueuing a durable message with SQL persistence provider loaded throws 501 exception,shuston,jbird,Closed,Fixed,2009-11-03 23:01,C++,C++ Broker,,,,,,,"This is related to Qpid-2168, but happens when the QpidStore database already exists at broker startup.

In this scenario, there are three durable exchanges (""E1"", ""E2"", ""E3"") and three durable queues (""Q1"", ""Q2"", ""Q3"") already declared. The smoke test tries to declare three durable bindings, between like-numbered exchanges and queues, with routing keys of the form keyN, where N is the same digit. It gets through declaring all three bindings with any failures, but immediately after that the connection is closed. This operation works without the SQL persistence provider loaded."
Bug,QPID-2050,12433084,leak of bridge objects,tross,kgiusti,Closed,Fixed,2009-11-02 17:48,C++,C++ Broker,,,,,,,"Link::cpp incorrectly re-inserts closed bridge objects back on the active vector, creating a leak.
Will shortly attach patch with fix and testcase

-K"
Bug,QPID-2080,12434777,crash when attempting to modify an exchange's alternate,tross,kgiusti,Closed,Fixed,2009-11-02 17:47,C++,C++ Broker,,,,,,,"C++ broker asserts due to a null pointer dereference when user attempt to re-declare an existing exchange, but add a new alternate exchange.
Will attach example test script that reproduces the problem."
Bug,QPID-2045,12432819,crash when destroying a federation link with a dynamic bridge,tross,kgiusti,Closed,Fixed,2009-11-02 17:46,C++,C++ Broker,,,,,,,"While experimenting with the Federation tests, I managed to cause a crash in the broker.  My modified test creates two bridges, but only calls ""bridge.close()"" on one of the bridges.  This results in a broker crash.  I will attach my test shortly.  I am running the latest trunk as of today (8/11/2009).  Thanks,

-K

----

pure virtual method called
terminate called without an active exception

Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7ffff5001910 (LWP 8354)]
0x00007ffff65032f5 in raise () from /lib64/libc.so.6
Missing separate debuginfos, use: debuginfo-install boost-1.37.0-6.fc11.x86_64 cyrus-sasl-lib-2.1.22-22.fc11.x86_64 e2fsprogs-libs-1.41.4-12.fc11.x86_64 glibc-2.10.1-4.x86_64 libgcc-4.4.0-4.x86_64 libstdc++-4.4.0-4.x86_64 nss-softokn-freebl-3.12.3.99.3-2.11.3.fc11.x86_64
(gdb) where
warning: (Internal error: pc 0x7ffff76e55de in read in psymtab, but not in symtab.)

warning: (Internal error: pc 0x7ffff76e55de in read in psymtab, but not in symtab.)

warning: (Internal error: pc 0x7ffff76e5590 in read in psymtab, but not in symtab.)

#0  0x00007ffff65032f5 in raise () from /lib64/libc.so.6
#1  0x00007ffff6504b20 in abort () from /lib64/libc.so.6
#2  0x0000003d972c3e15 in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6
#3  0x0000003d972c2236 in ?? () from /usr/lib64/libstdc++.so.6
#4  0x0000003d972c2263 in std::terminate() () from /usr/lib64/libstdc++.so.6
#5  0x0000003d972c2b3f in __cxa_pure_virtual () from /usr/lib64/libstdc++.so.6
#6  0x00007ffff7abd565 in qpid::broker::Exchange::propagateFedOp (this=0x7ffff0034620, routingKey=""ft-key.one.#"", tags="""", op=""U"", origin="""") at qpid/broker/Exchange.cpp:237
#7  0x00007ffff7b34975 in qpid::broker::TopicExchange::unbind (this=<value optimized out>, queue=<value optimized out>, constRoutingKey=<value optimized out>) at qpid/broker/TopicExchange.cpp:267
#8  0x00007ffff7af6911 in qpid::broker::QueueBindings::unbind (this=0x7ffff0040058, exchanges=<value optimized out>, queue={px = 0x7ffff003fe10, pn = {pi_ = 0x7ffff003b370}}) at qpid/broker/QueueBindings.cpp:39
#9  0x00007ffff7aed1be in qpid::broker::Queue::unbind (this=<value optimized out>, exchanges=@0x20a2, shared_ref=<value optimized out>) at qpid/broker/Queue.cpp:849
#10 0x00007ffff7aed390 in qpid::broker::Queue::tryAutoDelete (broker=@0x629bb0, queue={px = 0x7ffff003fe10, pn = {pi_ = 0x7ffff003b370}}) at qpid/broker/Queue.cpp:927
#11 0x00007ffff7b0e728 in qpid::broker::SemanticState::cancel (this=<value optimized out>, c=<value optimized out>) at qpid/broker/SemanticState.cpp:342
#12 0x00007ffff7b12726 in qpid::broker::SemanticState::~SemanticState (this=0x7ffff00340c8, __in_chrg=<value optimized out>) at qpid/broker/SemanticState.cpp:73
#13 0x00007ffff7b2f858 in qpid::broker::SessionState::~SessionState (this=0x7ffff0033ef0, __in_chrg=<value optimized out>) at qpid/broker/SessionState.cpp:96
#14 0x00007ffff7b2825a in ~auto_ptr (this=<value optimized out>, __in_chrg=<value optimized out>) at /usr/lib/gcc/x86_64-redhat-linux/4.4.0/../../../../include/c++/4.4.0/backward/auto_ptr.h:168
#15 qpid::broker::SessionHandler::handleDetach (this=<value optimized out>, __in_chrg=<value optimized out>) at qpid/broker/SessionHandler.cpp:70
#16 0x00007ffff76e478a in qpid::amqp_0_10::SessionHandler::detach (this=0x7ffff0000b40, name=""test-session"") at qpid/amqp_0_10/SessionHandler.cpp:176
#17 0x00007ffff76a5e33 in qpid::framing::SessionDetachBody::invoke<qpid::framing::AMQP_AllOperations::SessionHandler> (invocable=<value optimized out>, this=<value optimized out>) at ../include/qpid/framing/SessionDetachBody.h:63
#18 qpid::framing::AMQP_AllOperations::SessionHandler::Invoker::visit (invocable=<value optimized out>, this=<value optimized out>) at qpid/framing/AllInvoker.cpp:744
#19 0x00007ffff76e55df in qpid::framing::invoke<qpid::amqp_0_10::SessionHandler> (target=<value optimized out>, body=@0x6) at ./qpid/framing/Invoker.h:67
#20 0x00007ffff76e1765 in qpid::amqp_0_10::SessionHandler::invoke (this=0x0, m=@0x6) at qpid/amqp_0_10/SessionHandler.cpp:72
#21 0x00007ffff76e2c00 in qpid::amqp_0_10::SessionHandler::handleIn (this=0x7ffff0000b40, f=@0x7ffff50004d0) at qpid/amqp_0_10/SessionHandler.cpp:82
#22 0x00007ffff7a9ab23 in qpid::framing::Handler<qpid::framing::AMQFrame&>::operator() (t=<value optimized out>, this=<value optimized out>) at ./qpid/framing/Handler.h:42
#23 qpid::broker::Connection::received (t=<value optimized out>, this=<value optimized out>) at qpid/broker/Connection.cpp:136
#24 0x00007ffff7a7e8e8 in qpid::amqp_0_10::Connection::decode (this=0x7ffff00012a0, buffer=<value optimized out>, size=<value optimized out>) at qpid/amqp_0_10/Connection.cpp:58
#25 0x00007ffff770c0b4 in qpid::sys::AsynchIOHandler::readbuff (this=0x7ffff00356d0, buff=0x7ffff0043530) at qpid/sys/AsynchIOHandler.cpp:113
#26 0x00007ffff7657c44 in boost::function2<bool, qpid::sys::AsynchIO&, qpid::sys::AsynchIOBufferBase*>::operator() (this=<value optimized out>, a0=@0x20a2, a1=0x6) at /usr/include/boost/function/function_template.hpp:989
#27 0x00007ffff7655e29 in qpid::sys::posix::AsynchIO::readable (this=0x7ffff0035d60, h=<value optimized out>) at qpid/sys/posix/AsynchIO.cpp:452
#28 0x00007ffff7712b74 in boost::function1<void, qpid::sys::DispatchHandle&>::operator() (this=<value optimized out>, a0=@0x20a2) at /usr/include/boost/function/function_template.hpp:989
#29 0x00007ffff770f8ac in qpid::sys::DispatchHandle::processEvent (this=0x7ffff0035d68, type=qpid::sys::Poller::READABLE) at qpid/sys/DispatchHandle.cpp:278
#30 0x00007ffff766316a in qpid::sys::Poller::Event::process (this=<value optimized out>) at ./qpid/sys/Poller.h:123
#31 qpid::sys::Poller::run (this=<value optimized out>) at qpid/sys/epoll/EpollPoller.cpp:476
#32 0x00007ffff7659baa in qpid::sys::(anonymous namespace)::runRunnable (p=0x209e) at qpid/sys/posix/Thread.cpp:35
#33 0x00007ffff62ba86a in start_thread () from /lib64/libpthread.so.0
#34 0x00007ffff65ae39d in clone () from /lib64/libc.so.6
#35 0x0000000000000000 in ?? ()
(gdb) "
Bug,QPID-2168,12439351,C++ broker crashes when declaring durable binding with SQL persistence provider loaded,shuston,jbird,Closed,Fixed,2009-10-31 2:02,C++,C++ Broker,,,,,,,"The SQL persistence provider creates the QpidStore database on startup if it is not already present. The first time I run the smoke test after this, declaring durable exchanges and queues succeeds, but declaring the first durable binding (between a durable exchange and a durable queue) causes the broker to crash. This same set of operations works fine if the persistence provider is not loaded.

ChildEBP          RetAddr
00cbc68c 66cde9ad MSVCR90D!get_pgmptr+0x1c5
00cbc9c8 66cb02ee MSVCR90D!abort+0x2d
00cbc9fc 66cb19e0 MSVCR90D!terminate+0x6e
00cbca10 66cb1b26 MSVCR90D!_FrameUnwindFilter+0x40
00cbd02c 66cb1c15 MSVCR90D!_FrameUnwindFilter+0x186
00cbd04c 66cb151a MSVCR90D!_FrameUnwindFilter+0x275
00cbd0c4 66cb11d7 MSVCR90D!_ValidateWrite+0x4ba
00cbd0f4 66cb04ac MSVCR90D!_ValidateWrite+0x177
00cbd130 772cb6d1 MSVCR90D!_CxxFrameHandler3+0x2c
00cbd154 772cb6a3 ntdll32!RtlUnwind+0x25c
00cbd1fc 772aee57 ntdll32!RtlUnwind+0x22e
00cbd580 66caf8f2 ntdll32!KiUserExceptionDispatcher+0xf
00cbd5c0 676b2da9 MSVCR90D!CxxThrowException+0x52
00cbd5e0 676b2b20 mssql_stored!_com_raise_error(
                        HRESULT hr = 0x80040e2f,
                        struct IErrorInfo * perrinfo = 0x00000000`03b3ce60)+0x39
00cbd610 676a322d mssql_stored!_com_issue_errorex(
                        HRESULT hr = 0x80040e2f,
                        struct IUnknown * punk = 0x00000000`072a58f0,
                        struct _GUID * riid = 0x00000000`676c2a24 {0000050e-0000-0010-8000-00aa006d2ea4})+0xd0
00cbd654 676a1a89 mssql_stored!Recordset15::Update(
                        class _variant_t * Fields = 0x00000000`676d1638,
                        class _variant_t * Values = 0x00000000`676d1638)+0xbd
00cbd77c 67684d6c mssql_stored!qpid::store::ms_sql::BindingRecordset::add(
                        unsigned int64 exchangeId = 0,
                        class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * queueName = 0x00000000`02ed7258,  // this is ""Q1"" as expected
                        class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * routingKey = 0x00000000`02edc0ac,     // this is ""key1"" as expected
                        class qpid::framing::FieldTable * args = 0x00000000`02edc0cc)+0x3b9
00cbd8b8 6708520e mssql_stored!qpid::store::ms_sql::MSSqlProvider::bind(
                        class qpid::broker::PersistableExchange * exchange = 0x00000000`02ed33b8,
                        class qpid::broker::PersistableQueue * queue = 0x00000000`02ed7240,
                        class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * key = 0x00000000`02edc0ac,
                        class qpid::framing::FieldTable * args = 0x00000000`02edc0cc)+0xec
00cbd8dc 5aaee2af stored!qpid::store::MessageStorePlugin::bind(
                        class qpid::broker::PersistableExchange * exchange = 0x00000000`02ed33b8,
                        class qpid::broker::PersistableQueue * queue = 0x00000000`02ed7240,
                        class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * key = 0x00000000`02edc0ac,
                        class qpid::framing::FieldTable * args = 0x00000000`02edc0cc)+0x4e
00cbd998 5ab3d50f qpidbrokerd!qpid::broker::MessageStoreModule::bind(
                        class qpid::broker::PersistableExchange * e = 0x00000000`02ed33b8,
                        class qpid::broker::PersistableQueue * q = 0x00000000`02ed7240,
                        class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * k = 0x00000000`02edc0ac,
                        class qpid::framing::FieldTable * a = 0x00000000`02edc0cc)+0x8f
"
Bug,QPID-2169,12439352,Cannot delete durable exchanges or queues with SQL persistence provider loaded,shuston,jbird,Closed,Fixed,2009-10-31 2:01,C++,C++ Broker,,,,,,,"After declaring a durable exchange or queue with the SQL persistence provider loaded, and then cycling the broker, attempting to delete the exchange or queue results in a 501 reply, ""operation is not allowed in this context"", and the broker closes the connection.

This is a trace where the client program does a passive exchangeDeclare to determine whether exchange ""E1"" exists, then tries to exchangeDelete it. Each operation is done in a separate session.

2009-10-27 20:56:31 notice Broker running
2009-10-27 20:56:44 debug RECV [127.0.0.1:52120] INIT(0-10)
2009-10-27 20:56:44 trace SEND Immediate ContentInd to=console.obj.1.0.org.apache.qpid.broker.connection
2009-10-27 20:56:44 trace SENT 127.0.0.1:52120 INIT(0-10)
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionStartBody: server-properties={qpid.federation_tag:V2:36:str16(9f3a2960-0efc-44be-ab38-59f6a673427b)}; mechanisms=str16{V2:9:str16(ANONYMOUS)}; locales=str16{V2:5:str16(en_US)}; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionStartOkBody: client-properties={qpid.client_pid:F4:int32(5032),qpid.client_ppid:F4:int32(0),qpid.client_process:V2:0:str16(),qpid.session_flow:F4:int32(1)}; mechanism=ANONYMOUS; response=xxxxxx; locale=en_US; }]
2009-10-27 20:56:44 warning SASL: No Authentication Performed
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionTuneBody: channel-max=32767; max-frame-size=65535; heartbeat-min=0; heartbeat-max=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionTuneOkBody: channel-max=32767; max-frame-size=65535; heartbeat=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionOpenBody: virtual-host=; capabilities=void{}; insist=1; }]
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionOpenOkBody: known-hosts=str16{V2:26:str16(amqp:tcp:157.56.26.94:5672)}; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionAttachBody: name=amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e; }]
2009-10-27 20:56:44 debug SessionState::SessionState anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: 00D5EFA8
2009-10-27 20:56:44 debug anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: attached on broker.
2009-10-27 20:56:44 debug Attached channel 1 to anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e
2009-10-27 20:56:44 debug anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: ready to send, activating output.
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionAttachedBody: name=amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e; }]
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionRequestTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 debug anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: receiver command-point set to: (0+0)
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=1; {ExchangeQueryBody: name=amq.failover; }]
2009-10-27 20:56:44 trace anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: recv cmd 0: {ExchangeQueryBody: name=amq.failover; }
2009-10-27 20:56:44 debug Exception constructed: Exchange not found: amq.failover (..\..\src\qpid\broker\ExchangeRegistry.cpp:90)
2009-10-27 20:56:44 debug anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: receiver marked completed: 0 incomplete: { } unknown-completed: { [0,0] }
\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00; }lovere5bcc2e4-5c00-43b1-b668-e1461640e74e: sent cmd 0: {ExecutionResultBody: command-id=0; value=\x07\x01
\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00; }]120]: Frame[BEbe; channel=1; {ExecutionResultBody: command-id=0; value=\x07\x01
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionCompletedBody: commands={ [0,0] }; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionDetachBody: name=amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e; }]
2009-10-27 20:56:44 debug anonymous.amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e: detached on broker.
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=1; {SessionDetachedBody: name=amq.failovere5bcc2e4-5c00-43b1-b668-e1461640e74e; code=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionAttachBody: name=fbc3e964-770a-4582-9e7d-43e8ba55b121; }]
2009-10-27 20:56:44 debug SessionState::SessionState anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: 00D5EFA8
2009-10-27 20:56:44 debug anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: attached on broker.
2009-10-27 20:56:44 debug Attached channel 2 to anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121
2009-10-27 20:56:44 debug anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: ready to send, activating output.
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionAttachedBody: name=fbc3e964-770a-4582-9e7d-43e8ba55b121; }]
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionRequestTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 debug anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: receiver command-point set to: (0+0)
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=2; {ExchangeDeclareBody: exchange=E1; type=direct; alternate-exchange=; passive=1; arguments={}; }]
2009-10-27 20:56:44 trace anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: recv cmd 0: {ExchangeDeclareBody: exchange=E1; type=direct; alternate-exchange=; passive=1; arguments={}; }
2009-10-27 20:56:44 debug anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: receiver marked completed: 0 incomplete: { } unknown-completed: { [0,0] }
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionCompletedBody: commands={ [0,0] }; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionDetachBody: name=fbc3e964-770a-4582-9e7d-43e8ba55b121; }]
2009-10-27 20:56:44 debug anonymous.fbc3e964-770a-4582-9e7d-43e8ba55b121: detached on broker.
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=2; {SessionDetachedBody: name=fbc3e964-770a-4582-9e7d-43e8ba55b121; code=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionAttachBody: name=575c998c-42b5-4c81-a3ea-8e9373bd43b7; }]
2009-10-27 20:56:44 debug SessionState::SessionState anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7: 00D5EFA8
2009-10-27 20:56:44 debug anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7: attached on broker.
2009-10-27 20:56:44 debug Attached channel 3 to anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7
2009-10-27 20:56:44 debug anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7: ready to send, activating output.
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionAttachedBody: name=575c998c-42b5-4c81-a3ea-8e9373bd43b7; }]
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionRequestTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionCommandPointBody: command-id=0; command-offset=0; }]
2009-10-27 20:56:44 debug anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7: receiver command-point set to: (0+0)
2009-10-27 20:56:44 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=3; {SessionTimeoutBody: timeout=0; }]
2009-10-27 20:56:44 trace RECV [127.0.0.1:52120]: Frame[BEbe; channel=3; {ExchangeDeleteBody: exchange=E1; }]
2009-10-27 20:56:44 trace anonymous.575c998c-42b5-4c81-a3ea-8e9373bd43b7: recv cmd 0: {ExchangeDeleteBody: exchange=E1; }
2009-10-27 20:56:45 debug Exception constructed: Error deleting exchange E1: Operation is not allowed in this context.
2009-10-27 20:56:45 error Unexpected exception: Error deleting exchange E1: Operation is not allowed in this context.
2009-10-27 20:56:45 error Connection 127.0.0.1:52120 closed by error: Error deleting exchange E1: Operation is not allowed in this context.(501)
2009-10-27 20:56:45 trace SENT [127.0.0.1:52120]: Frame[BEbe; channel=0; {ConnectionCloseBody: reply-code=501; reply-text=Error deleting exchange E1: Operation is not allowed in this context.; }]
2009-10-27 20:56:45 debug DISCONNECTED [127.0.0.1:52120]"
Bug,QPID-1737,12416869,qpid C++ will not build with WinSDK 7,shuston,jmansion,Closed,Fixed,2009-09-01 22:00,C++,C++ Broker,,,,,,,"I'm trying to build M4 of AMQP on XP with the Win7 SDK Beta, and I'm seeing that

Manageable::STATUS_INVALID_PARAMETER

is being expanded to:

Manageable::((DWORD )0xC000000DL);

I think this is because src\qpid/sys/windows/uuid.h has included rpc.h and included a lot of the SDK as a result.

STATUS_INVALID_PARAMETER is defined in ntstatus.h and winnt.h.

The include structure is rather Byzantine - I see there's a JIRA to tidy things up, though that is focussed on client applications.

I suspect that one way or another this will bite again even if sufficient 'undefs' are added in the code now.

I know this is Microsoft's bad for namespace pollution, but the practical answer is to change the name of this constant. 
"
Bug,QPID-1722,12416469,Use of gethostbyname() in Socket.cpp isn't thread safe,astitcher,astitcher,Closed,Fixed,2009-03-09 21:22,C++,C++ Broker,C++ Client,,,,,,"Using gethostbyname() like this in multiple threads at once (for instance connecting simultaneously) may cause client/broker crashes

The best fix is to replace the old API used with the re-entrant and more featureful getaddrinfo() API
"
Bug,QPID-634,12380100,c++ broler hangs/dies during MessageListenerMultiConsumerTest,gsim,rajith,Closed,Fixed,2008-07-04 2:54,C++,C++ Broker,,,,,,,"When running org.apache.qpid.client.MessageListenerMultiConsumerTest the c++ broker hangs and then crashes.
Below is the log from the broker. I will try to reproduce this again, get a stack dump and attach it to the JIRA.

Looks like the broker had a lock issue while trying to add credit to a
destination. Below is the log from the broker.

2007-Oct-09 21:56:46 debug SENT: Frame[channel=2; ExecutionCompleteBody:
cumulative-execution-mark=3; ranged-execution-set={}]
2007-Oct-09 21:56:46 debug Credit check for destination 1 byteCredit:
4294967295 msgCredit: 0
2007-Oct-09 21:56:46 debug Credit check for destination 1 byteCredit:
4294967295 msgCredit: 1
2007-Oct-09 21:56:46 debug Message delivered for destination 1
2007-Oct-09 21:56:46 debug RECV: Frame[channel=1; MessageFlowBody:
destination=1; unit=0; value=1]
2007-Oct-09 21:56:46 debug Message Credit Requested for 1: 1
2007-Oct-09 21:56:46 trace Exception: Error [50016] Device or resource
busy (./qpid/sys/posix/Mutex.h:155)
terminate called after throwing an instance of 'qpid::sys::PosixError'
  what():  Error [50016] Device or resource busy
(./qpid/sys/posix/Mutex.h:155)
Aborted
"
Bug,QPID-1063,12396140,"under Boost 103200, command line args with ""="" didn't work",,mgoulish,Closed,Fixed,2008-06-26 12:17,C++,C++ Broker,,,,,,,"under Boost 103200, command line args with ""="" didn't work
i.e. ""a=b"" was seen as an arg hose name was ""a=b"".

(not a boost problem -- a qpid problem)

"
Bug,QPID-1054,12395944,Startup failures not reported when in daemon mode,gsim,gsim,Closed,Fixed,2008-06-26 8:28,C++,C++ Broker,,,,,,,"If broker is started with -d option any startup failures (port in use, data dir not found etc) are not echoed to the console."
Bug,QPID-1048,12395798,Dispatch of durable message from non-durable queue held up if message is also enqueued asynchronously on durable queue,gsim,gsim,Closed,Fixed,2008-06-26 8:28,C++,C++ Broker,,,,,,,"If two queues, one durable one non-durable, are bound such that they receive the same durable message delivery from each queue will currently be held up until the asynchronous enqueue completes. However the non-durable queue will never be notified of this completion and so the dispatch will stall until another message or consumer event triggers it."
Bug,QPID-1098,12396988,Final 0-10 specification reqiures empty struct to be returned if queried queue is not found,gsim,gsim,Closed,Fixed,2008-06-26 8:19,C++,C++ Broker,,,,,,,currently a not-found exception is sent instead
Bug,QPID-1100,12396999,crash when config file contains commented-out commands.,tross,mgoulish,Closed,Fixed,2008-06-20 22:10,C++,C++ Broker,,,,,,,"when the config file contains lines that are commented out  (with #)  we  SEGV.

"
Bug,QPID-1042,12395688,"Record of deliveries not kept for non-acquired, non-accepted subscriptions in credit flow mode",gsim,gsim,Closed,Fixed,2008-05-12 14:02,C++,C++ Broker,,,,,,,This prevents the messages subsequently being acquired.
Bug,QPID-6347,12771038,queue_event_generation option clean-up,tross,iboverma,Resolved,Fixed,2019-10-02 19:17,C++,C++ Broker,,,,,,,"The queue_event_generation queue option was related to queue replication that is not supported anymore, but the option remains present in the source code and may be set on queues. The option is also still available in qpid-config (--generate-queue-events=<n>).  We should remove all code related to this option."
Bug,QPID-7860,13087239,[cpp] Build produces deprecation warnings on recent Fedora,jross,jross,Resolved,Fixed,2017-10-27 14:17,C++,C++ Broker,C++ Client,,,,,,"{noformat}
-- Found SWIG: /usr/bin/swig (found version ""3.0.11"") 
-- Found PythonLibs: /usr/lib64/libpython2.7.so (found version ""2.7.13"") 
-- Found Perl: /usr/bin/perl (found version ""5.24.1"") 
-- Found PerlLibs: /usr/lib64/libperl.so (found version ""5.24.1"") 
-- Building Python bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/python/CMakeLists.txt:35 (swig_add_module)


CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qmf2/python/CMakeLists.txt:35 (swig_add_module)


-- Building Ruby bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/ruby/CMakeLists.txt:48 (swig_add_module)


CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qmf2/ruby/CMakeLists.txt:39 (swig_add_module)


-- Building Perl bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/perl/CMakeLists.txt:31 (swig_add_module)


-- Configuring done
-- Generating done
-- Build files have been written to: /home/jross/code/qpid-cpp/bld
{noformat}"
Bug,QPID-7131,12948159,snd-settle-mode advertised is always 'mixed',gsim,gsim,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,,,,,,,"Would be nicer to echo what the subscriber has requested. (The actual settlement is already as requested, and mixed isn't wrong exactly, but it is not as right as it might be!)."
Bug,QPID-6654,12848711,mgmt-disable option set to false causes segv on CentOS 6.3,gsim,calille,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"Running the 0.34 cpp broker on a CentOS 6.3 installation and noticed that when the --mgmt-enable is set to false the broker core dumps when qpid-receive attempts a connection 

If I remove the --mgmt-enable option the broker runs fine.

>> /usr/local/sbin/qpidd --auth no  --mgmt-enable 0
2015-07-23 14:43:53 [Broker] notice Broker (pid=52418) start-up
2015-07-23 14:43:53 [Security] notice SSL plugin not enabled, you must set --ssl-cert-db to enable it.
2015-07-23 14:43:53 [Store] warning Message store plugin: No storage providers available.
2015-07-23 14:43:53 [Broker] notice SASL disabled: No Authentication Performed
2015-07-23 14:43:53 [Network] notice Listening on TCP/TCP6 port 5672
Segmentation fault (core dumped)

>> /usr/local/bin/qpid-receive -f -b 'xxxxxxx:5672' -a amq.topic/foo


Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ffff5cb3700 (LWP 52455)]
0x0000003b9069d258 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()
   from /usr/lib64/libstdc++.so.6
(gdb) where
#0  0x0000003b9069d258 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()
   from /usr/lib64/libstdc++.so.6
#1  0x00007ffff7c5afb0 in getOsName (this=0x7ffff0001510, c=..., isClient=<value optimized out>) at /root/qpid-cpp-0.34/src/qpid/broker/System.h:57
#2  qpid::broker::ConnectionHandler::Handler::Handler (this=0x7ffff0001510, c=..., isClient=<value optimized out>) at /root/qpid-cpp-0.34/src/qpid/broker/ConnectionHandler.cpp:126
#3  0x00007ffff7c5b733 in qpid::broker::ConnectionHandler::ConnectionHandler (this=<value optimized out>, connection=..., isClient=false) at /root/qpid-cpp-0.34/src/qpid/broker/ConnectionHandler.cpp:112
#4  0x00007ffff7c56f78 in qpid::broker::amqp_0_10::Connection::Connection (this=0x7ffff0000f90, out_=0x7ffff0000a18, broker_=..., mgmtId_=""qpid.172.16.168.158:5672-172.16.168.158:55302"", external=...,
    link_=false, objectId_=0) at /root/qpid-cpp-0.34/src/qpid/broker/amqp_0_10/Connection.cpp:150
#5  0x00007ffff7c22c56 in qpid::broker::ProtocolRegistry::create_0_10 (this=0x64b278, out=<value optimized out>, id=""qpid.172.16.168.158:5672-172.16.168.158:55302"", external=...,
    brokerActsAsClient=false) at /root/qpid-cpp-0.34/src/qpid/broker/Protocol.cpp:89
#6  0x00007ffff77305a7 in qpid::sys::AsynchIOHandler::readbuff (this=0x7fffe8000aa0, buff=0x7fffe8001940) at /root/qpid-cpp-0.34/src/qpid/sys/AsynchIOHandler.cpp:152
#7  0x00007ffff76aed8e in operator() (this=0x7fffe8000b60, h=...) at /usr/include/boost/function/function_template.hpp:1013
#8  qpid::sys::posix::AsynchIO::readable (this=0x7fffe8000b60, h=...) at /root/qpid-cpp-0.34/src/qpid/sys/posix/AsynchIO.cpp:453
#9  0x00007ffff7734ce3 in boost::function1<void, qpid::sys::DispatchHandle&>::operator() (this=<value optimized out>, a0=<value optimized out>) at /usr/include/boost/function/function_template.hpp:1013
#10 0x00007ffff7733976 in qpid::sys::DispatchHandle::processEvent (this=0x7fffe8000b68, type=qpid::sys::Poller::READABLE) at /root/qpid-cpp-0.34/src/qpid/sys/DispatchHandle.cpp:280
#11 0x00007ffff76d4add in process (this=0x64b740) at /root/qpid-cpp-0.34/src/qpid/sys/Poller.h:131
#12 qpid::sys::Poller::run (this=0x64b740) at /root/qpid-cpp-0.34/src/qpid/sys/epoll/EpollPoller.cpp:522
#13 0x00007ffff76c8e8a in qpid::sys::(anonymous namespace)::runRunnable (p=<value optimized out>) at /root/qpid-cpp-0.34/src/qpid/sys/posix/Thread.cpp:35
#14 0x0000003b852079d1 in start_thread () from /lib64/libpthread.so.0
#15 0x0000003b84ee88fd in clone () from /lib64/libc.so.6"
Bug,QPID-6661,12849576,[AMQP 1.0] heartbeat anomalies,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"The first heartbeat is often sent after the full idle period, whereas subsequent heartbeats are sent twice as frequently. This happens on both broker and client. This is a result of the periodic timer task that triggers the heartbeats being out of sync with the times computed by proton.

Also on the client, occasionally a heartbeat is missed. This is in part due to the issue above, but also occasionally due to timing of incoming heartbeats with respect to the timer task, resulting in proton emitting the heartbeat but it not actually being written to the wire."
Bug,QPID-6717,12860389,selector can match incorrectly due to different type for values,astitcher,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,,,,,,,"E.g. a selector ""x BETWEEN 1 AND 10"" would match for a value of x=""foo"", because of the way the logic is implemented for the between expression, or a selector ""x NOT IN ('a', 'b', 'c')"" would match where x=1, though it should not due to the type mismatch.

From JMS spec: ""Only like type values can be compared. One exception is that it is valid to compare exact numeric values and approximate numeric values"""
Bug,QPID-5025,12660694,DeliveryRecord::committed() doesn't check if delivery is already ended,gsim,gsim,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,Prior to 0.20 this causes a segfault. Since 0.20 it is handled much better but would be nice to fix for consistency (since e.g. dequeue() does do the check). Marking as minor since it has not real impact on latest version.
Bug,QPID-5362,12679994,Linearstore: No store tools exist for examining the journals,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"There are no tools which can off-line (ie when the broker is not running) examine the linearstore journal files and empty file pools. It would be useful to be able to:

1. Manage the state of the empty file pool(s), and to add/remove different partitions and pools containing different file sizes;
2. Examine any journal files present and view the still-enqueued messages that may be present;
3. Examine the transaction prepared list journal and determine which transactions (if any) are incomplete or in an inconsistent state."
Bug,QPID-5107,12666330,Trace queue&session deletion statistics show zero values for some counters everytime,,pmoravec,Closed,Fixed,2016-09-06 16:35,C++,C++ Broker,,,,,,,"Description of problem:
qpid trace/logs statistics about object deletion. However some of these data are wrong. In particular msgDepth for a queue is everytime zero (and msgTotalDequeues equals to msgTotalEnqueues despite no consumer was subscribed to the queue), or unackedMessages for a session is zero everytime as well.


Version-Release number of selected component (if applicable):
qpid 0.22


How reproducible:
100%


Steps to Reproduce:
1) msgDepth:0 for queue:
echo ""auth=no"" > /etc/qpid/qpidd.conf
echo ""trace=yes"" >> /etc/qpid/qpidd.conf
echo ""log-to-file=/tmp/qpidd.log"" >> /etc/qpid/qpidd.conf
rm -rf /var/lib/qpidd/* /tmp/qpidd.log
service qpidd restart
qpid-send -m 123 -a ""testQueue; {create:always, delete:always}""
sleep 10  # just to let periodic processing to run & print out the stats
grep ""Mgmt delete queue"" /tmp/qpidd.log


Actual results:
2013-08-29 14:05:38 [Model] trace Mgmt delete queue. id:testQueue Statistics: {acquires:123, bindingCount:0, bindingCountHigh:0, bindingCountLow:0, byteDepth:0, byteFtdDepth:0, byteFtdDequeues:0, byteFtdEnqueues:0, bytePersistDequeues:0, bytePersistEnqueues:0, byteTotalDequeues:0, byteTotalEnqueues:0, byteTxnDequeues:0, byteTxnEnqueues:0, consumerCount:0, consumerCountHigh:0, consumerCountLow:0, discardsLvq:0, discardsOverflow:0, discardsPurge:0, discardsRing:0, discardsSubscriber:0, discardsTtl:0, flowStopped:False, flowStoppedCount:0, messageLatencyAvg:0, messageLatencyCount:0, messageLatencyMax:0, messageLatencyMin:0, msgDepth:0, msgFtdDepth:0, msgFtdDequeues:0, msgFtdEnqueues:0, msgPersistDequeues:0, msgPersistEnqueues:0, msgTotalDequeues:123, msgTotalEnqueues:123, msgTxnDequeues:0, msgTxnEnqueues:0, releases:0, reroutes:0, unackedMessages:0, unackedMessagesHigh:0, unackedMessagesLow:0}


Expected results:
acquires:0
msgTotalDequeues:0
(several other counters are supposed to be wrong as well like byteFtdDequeues)



2) Reproducer for unackedMessages:0 for session:
qpid-send -m 11 -a ""myQueue; {create:always}""
qpid-receive -m 100 -a ""myQueue; {create:always}"" -f

(in another terminal)
qpid-tool
list connection
call <ID_of_qpid-receive-connection> close

and now check result:

grep Tx /tmp/qpidd.log | grep session

should return ""unackedMessages:11"" but returns zero.
"
Bug,QPID-5654,12705773,[linearstore] Set default cmake build to exclude linearstore on 0.28 release,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:23,C++,C++ Broker,,,,,,,"Currently cmake builds both legacystore and linearstore. It is suggested that since both stores cannot run at the same time, and that linearstore is still experimental that the build of linearstore be excluded from cmake unless it is specifically enabled."
Bug,QPID-5660,12706453,[legacystore] Python tests fail with syntax error on Python 2.4,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:23,C++,C++ Broker,,,,,,,"Recent tests of legacystore on older versions of linux that use Python 2.4.x fail because of a syntax error:

{{except jerr.NonExistentRecordError as err:}}

This version of Python did not use the {{as}} syntax, but rather the {{,}} syntax:

{{except jerr.NonExistentRecordError, err:}}

The fix should be trivial, replacing all instances of the later syntax with the earlier syntax, and which is still accepted by later versions of Python 2.x."
Bug,QPID-5487,12689279,[linearstore] Replace use of /dev/urandom with c random generator calls,kpvdr,kpvdr,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"The use of /dev/urandom for random numbers is considered unfriendly to other systems on a machine that might depend upon this source.

The current use-case is for Journal serial numbers; the randomness of the C rand() call should be good enough, but it requires a 64-bit number. Construct this using several smaller numbers from rand() or random()"
Bug,QPID-5321,12678349,qpid-tool doesn't properly display exceptions which occurred when calling some methods,gsim,scholzj,Closed,Fixed,2016-09-06 16:21,C++,C++ Broker,,,,,,,"When an exception occurs during a call of some method from qpid-tool, the actual exception is not displayed:

qpid: call 152 purge 0 {""filter_type"":""header_match_str"",""filter_params"":{""header_key"":""status"",""header_value"":""suda""}}
*Exception in do_call: %r*

intstead of:

qpid: call 152 purge 0 {""filter_type"":""header_match_str"",""filter_params"":{""header_key"":""status"",""header_value"":""licha""}}
*Exception in do_call: Timeout()*

This is because when the exception is catched in the do_call method, it doesn't format the printed statement properly, because a "","" is used as a separator instead of ""%"".

I would attach a patch, but since it is just one character change, it does't seem necessary:

Index: src/py/qpid-tool
===================================================================
--- src/py/qpid-tool	(revision 1540216)
+++ src/py/qpid-tool	(working copy)
@@ -144,7 +144,7 @@
     try:
       self.dataObject.do_call(data)
     except Exception, e:
-      print ""Exception in do_call: %r"", e
+      print ""Exception in do_call: %r"" % e
 
   def do_EOF(self, data):
     print ""quit""
"
Bug,QPID-1759,12417287,Unit tests fail on Fedora 10 when gcc-debuginfo is installed,,tross,Closed,Fixed,2016-09-06 12:45,C++,C++ Broker,,,,,,,"When gcc-debuginfo is installed, the unit tests fail because the ephemeral port cannot be determined for the broker.

After digging a little further, I determined that streams do not handle numeric data.  For example, if I put the following line in the broker code:

    std::cout << ""string "" << 45 << "" string2"" << std::endl;

the output seen on the console is:

    string

The number and any following text is lost (probably due to a null-terminator being incorrectly inserted).

Note that this does not affect normal broker operation, nor does it affect the python system tests.  It only affects the broker running in the unit test environment."
Bug,QPID-1317,12405785,Memory leaks in C++ broker,,rajika,Closed,Fixed,2016-09-06 12:45,C++,C++ Broker,,,,,,,"Here is the valigrind log.  Most of the errors occurs due to uninitialized arguments which pass to system calls. The proper initialization of the arguments  would fix the problem. 

[rajika@localhost sbin]$ valgrind ./qpidd --auth no
==16853== Memcheck, a memory error detector.
==16853== Copyright (C) 2002-2007, and GNU GPL'd, by Julian Seward et al.
==16853== Using LibVEX rev 1804, a library for dynamic binary translation.
==16853== Copyright (C) 2004-2007, and GNU GPL'd, by OpenWorks LLP.
==16853== Using valgrind-3.3.0, a dynamic binary instrumentation framework.
==16853== Copyright (C) 2000-2007, and GNU GPL'd, by Julian Seward et al.
==16853== For more details, rerun with: -v
==16853== 
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DA8F: qpid::sys::DispatchHandle::startWatch(boost::shared_ptr<qpid::sys::Poller>) (Dispatcher.cpp:84)
==16853==    by 0x42C4E74: qpid::sys::AsynchAcceptor::start(boost::shared_ptr<qpid::sys::Poller>) (AsynchIO.cpp:79)
==16853==    by 0x414E97B: qpid::sys::AsynchIOProtocolFactory::accept(boost::shared_ptr<qpid::sys::Poller>, qpid::sys::ConnectionCodec::Factory*) (TCPIOPlugin.cpp:115)
==16853==    by 0x409D620: qpid::broker::Broker::accept() (Broker.cpp:375)
==16853==    by 0x409DC1E: qpid::broker::Broker::run() (Broker.cpp:273)
==16853==    by 0x804FF00: main (qpidd.cpp:251)
==16853==  Address 0xbe842dec is on thread 1's stack
==16853== 
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DA8F: qpid::sys::DispatchHandle::startWatch(boost::shared_ptr<qpid::sys::Poller>) (Dispatcher.cpp:84)
==16853==    by 0x42C4F51: qpid::sys::AsynchIO::start(boost::shared_ptr<qpid::sys::Poller>) (AsynchIO.cpp:198)
==16853==    by 0x414D87E: qpid::sys::AsynchIOProtocolFactory::established(boost::shared_ptr<qpid::sys::Poller>, qpid::sys::Socket const&, qpid::sys::ConnectionCodec::Factory*, bool) (TCPIOPlugin.cpp:99)
==16853==    by 0x414FE03: boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf4<void, qpid::sys::AsynchIOProtocolFactory, boost::shared_ptr<qpid::sys::Poller>, qpid::sys::Socket const&, qpid::sys::ConnectionCodec::Factory*, bool>, boost::_bi::list5<boost::_bi::value<qpid::sys::AsynchIOProtocolFactory*>, boost::_bi::value<boost::shared_ptr<qpid::sys::Poller> >, boost::arg<1> (*)(), boost::_bi::value<qpid::sys::ConnectionCodec::Factory*>, boost::_bi::value<bool> > >, void, qpid::sys::Socket const&>::invoke(boost::detail::function::function_buffer&, qpid::sys::Socket const&) (mem_fn_template.hpp:494)
==16853==    by 0x42CB1C1: boost::function1<void, qpid::sys::Socket const&, std::allocator<boost::function_base> >::operator()(qpid::sys::Socket const&) const (function_template.hpp:692)
==16853==    by 0x42C761E: qpid::sys::AsynchAcceptor::readable(qpid::sys::DispatchHandle&) (AsynchIO.cpp:94)
==16853==    by 0x42CA3DC: boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::AsynchAcceptor, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::AsynchAcceptor*>, boost::arg<1> (*)()> >, void, qpid::sys::DispatchHandle&>::invoke(boost::detail::function::function_buffer&, qpid::sys::DispatchHandle&) (mem_fn_template.hpp:162)
==16853==    by 0x430F1A6: boost::function1<void, qpid::sys::DispatchHandle&, std::allocator<boost::function_base> >::operator()(qpid::sys::DispatchHandle&) const (function_template.hpp:692)
==16853==    by 0x430DE7A: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (Dispatcher.cpp:383)
==16853==    by 0x430D59A: qpid::sys::Dispatcher::run() (Poller.h:105)
==16853==    by 0x409DDE5: qpid::broker::Broker::run() (Broker.cpp:284)
==16853==  Address 0xbe8429dc is on thread 1's stack
==16853== 
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DC81: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (Dispatcher.cpp:411)
==16853==    by 0x430D59A: qpid::sys::Dispatcher::run() (Poller.h:105)
==16853==    by 0x409DDE5: qpid::broker::Broker::run() (Broker.cpp:284)
==16853==    by 0x804FF00: main (qpidd.cpp:251)
==16853==  Address 0xbe842edc is on thread 1's stack
==16853== 
==16853== Thread 6:
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DDAF: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (Dispatcher.cpp:419)
==16853==    by 0x430D59A: qpid::sys::Dispatcher::run() (Poller.h:105)
==16853==    by 0x42CBC90: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==16853==    by 0xC4532E: start_thread (in /lib/libpthread-2.8.so)
==16853==    by 0xB8027D: clone (in /lib/libc-2.8.so)
==16853==  Address 0x7ae22bc is on thread 6's stack
==16853== 
==16853== Thread 1:
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DDAF: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (Dispatcher.cpp:419)
==16853==    by 0x430D59A: qpid::sys::Dispatcher::run() (Poller.h:105)
==16853==    by 0x409DDE5: qpid::broker::Broker::run() (Broker.cpp:284)
==16853==    by 0x804FF00: main (qpidd.cpp:251)
==16853==  Address 0xbe842edc is on thread 1's stack
==16853== 
==16853== Thread 5:
==16853== Syscall param epoll_ctl(event) points to uninitialised byte(s)
==16853==    at 0xB809BE: epoll_ctl (in /lib/libc-2.8.so)
==16853==    by 0x430DC81: qpid::sys::DispatchHandle::processEvent(qpid::sys::Poller::EventType) (Dispatcher.cpp:411)
==16853==    by 0x430D59A: qpid::sys::Dispatcher::run() (Poller.h:105)
==16853==    by 0x42CBC90: qpid::sys::(anonymous namespace)::runRunnable(void*) (Thread.cpp:35)
==16853==    by 0xC4532E: start_thread (in /lib/libpthread-2.8.so)
==16853==    by 0xB8027D: clone (in /lib/libc-2.8.so)
==16853==  Address 0x70e12bc is on thread 5's stack"
Bug,QPID-6524,12826270,[C++ broker]: Fix for QPID-5107 incomplete for queues,pmoravec,pmoravec,Closed,Fixed,2015-06-16 8:41,C++,C++ Broker,,,,,,,"QPID-5107 fixes all except the very basic scenario when the queue is deleted before broker shutdown. I.e. in use case:

{quote}
qpid-config add queue testQueue1
qpid-send --address testQueue1 -m 13 --content-size=1024
qpid-config del queue testQueue1 --force
{quote}

the statistics show:

{quote}
trace Mgmt destroying queue. id:testQueue1 Statistics: {acquires:0, bindingCount:0, bindingCountHigh:1, bindingCountLow:0, byteDepth:0, byteFtdDepth:0, byteFtdDequeues:0, byteFtdEnqueues:0, bytePersistDequeues:0, bytePersistEnqueues:0, byteTotalDequeues:14183, byteTotalEnqueues:14183, byteTxnDequeues:0, byteTxnEnqueues:0, consumerCount:0, consumerCountHigh:0, consumerCountLow:0, creator:anonymous, discardsLvq:0, discardsOverflow:0, discardsPurge:0, discardsRing:0, discardsSubscriber:0, discardsTtl:0, flowStopped:False, flowStoppedCount:0, messageLatencyAvg:0, messageLatencyCount:0, messageLatencyMax:0, messageLatencyMin:0, msgDepth:0, msgFtdDepth:0, msgFtdDequeues:0, msgFtdEnqueues:0, msgPersistDequeues:0, msgPersistEnqueues:0, msgTotalDequeues:13, msgTotalEnqueues:13, msgTxnDequeues:0, msgTxnEnqueues:0, redirectPeer:, redirectSource:False, releases:0, reroutes:0, unackedMessages:0, unackedMessagesHigh:0, unackedMessagesLow:0}
{quote}

See e.g. msgDepth:0 or msgTotalDequeues:13.

Those values are correct from the technical point of view (broker can delete only empty queue, after purging all its messages and deleting all bindings etc.), but they are not right from end-user perspective who sees the broker had some messages in the queue, but a log for deleting the queue does not mention them."
Bug,QPID-6045,12736798,[AMQP 1.0] xml exchange reports support for amqp legacy topic filter,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,,,,,,,"If you turn on asserts and specify a filter of type apache.org:legacy-amqp-topic-binding:string, the broker includes that filter in the attach, even though it does not support wildcard matching on that exchange."
Bug,QPID-6296,12765129,[linearstore] Restarting broker with empty journal created with qpid-config raises confusing warning,kpvdr,kpvdr,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,"If a queue is created using qpid-config, but is never used, then upon restarting the broker, a confusing warning is generated:

{{Journal <QueueName>: Journal file <FileName> is uninitialized or corrupted}}

The file is ignored, and becomes orphaned.

This is an improperly handled error. The file is indeed uninitialized, but the correct action is to include it in the queue journal list as the first uninitialized file and initialize/use it when the queue is first used."
Bug,QPID-6322,12768158,[AMQP 1.0] don't set qpid.auto_delete_timeout if the value is 0,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,,,,,,,It causes confusion and has no effect anyway
Bug,QPID-6232,12756118,[C++ broker] Linearstore segfaults when ulimit prevents creating new file in EFP,pmoravec,pmoravec,Closed,Fixed,2014-11-18 15:07,C++,C++ Broker,,,,,,,"When EFP fails to open a new file (i.e. due to ulimit to nofiles), linearstore segfaults with backtrace:

#0  0x00000034d429c1b9 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::rfind(char, unsigned long) const () from /usr/lib64/libstdc++.so.6
#1  0x00007fe466719b50 in qpid::linearstore::journal::EmptyFilePool::takeEmptyFile (this=0xddb540, destDirectory=""/var/lib/qpidd/qls/jrnl/Durable_4_8"")
    at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/EmptyFilePool.cpp:109
#2  0x00007fe4667327a0 in qpid::linearstore::journal::LinearFileController::pullEmptyFileFromEfp (this=0x3478288)
    at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/LinearFileController.cpp:239
#3  0x00007fe466748bfd in qpid::linearstore::journal::wmgr::flush_check (this=0x34784f8, res=@0x7fe462f55f90, cont=@0x7fe462f55f9f, done=@0x7fe462f55f9c)
    at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/wmgr.cpp:651
#4  0x00007fe46674c134 in qpid::linearstore::journal::wmgr::enqueue (this=0x34784f8, data_buff=<value optimized out>, tot_data_len=177, this_data_len=<value optimized out>, dtokp=
    0x7fe3e583ed60, xid_ptr=0x0, xid_len=0, tpc_flag=false, transient=false, external=false) at /usr/src/debug/qpid-0.22/cpp/src/qpid/linearstore/journal/wmgr.cpp:223

The problem is EmptyFilePool::overwriteFileContents does not react anyhow if ofs.good() is false."
Bug,QPID-6182,12750034,AMQP 1.0 consumer should be able to get messages from browse-only queue,pmoravec,pmoravec,Closed,Fixed,2014-10-23 14:09,C++,C++ Broker,,,,,,,"Description of problem:
Qpid broker allows 0-10 consumers on browse-only queues, but does not allow 1.0 consumers there. It should allow 1.0 consumers as well, marking them internally as browsers instead (like it does for 0-10 consumer).


Version-Release number of selected component (if applicable):
0.30


How reproducible:
100%


Steps to Reproduce:
1. service qpidd restart
2. qpid-config add queue q --argument=qpid.browse-only=true --limit-policy=ring --max-queue-count=100
3. qpid-send -a q -m1
4. qpid-receive -a q # works fine
5. qpid-receive -a q --connection-option ""{protocol:amqp1.0}""


Actual results:
Step 5 returns:
qpid-receive: Link detached by peer with amqp:internal-error: not-allowed: Queue q is browse only.  Refusing acquiring consumer. (/home/pmoravec/qpid-trunk/qpid/cpp/src/qpid/broker/Queue.cpp:552)


Expected results:
Both 4. and 5. to return one message (one empty line corresponding to empty message content).


Additional info:"
Bug,QPID-5805,12720082,Selector parser shouldn't allow either % or _ character as an ESCAPE character in a LIKE comparison,astitcher,astitcher,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,,,,,,,"a selector expression similar to:

qpid.subject LIKE '%%%' ESCAPE '%'

makes no sense. In general the excape character only needs to be chosen for aesthetic reasons since it only has to quote %,_, and itself. It nver needs to be % or _ and these choices make no sense since then you would not be able to have the unquoted version of them anywhere in the string."
Bug,QPID-5874,12725367,C++ broker has odd treatment of empty and whitespace only selectors,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,,,,,,,"The selector parser in the C++ broker treats empty selectors oddly:

If the selector is a completely empty string : """" then the selector is treated as if it was always true. However if the selector only contains white space : "" "" then this treated as a parse error.

These 2 cases are for all visible user purposes the same selector and so should have the same behaviour.

Probably the most logical behaviour is to make both these cases act as if the selector was always true so that they are equivalent to the selector being entirely absent."
Bug,QPID-6087,12739760, QMF Session name to contain user ID for AMQP 0-10,pmoravec,pmoravec,Closed,Fixed,2014-09-19 14:00,C++,C++ Broker,,,,,,,"Description of problem:
AMQP 0-10 allows sessions of the same name attached in parallel by different users. Broker allows that, but QMF can't cope with it properly as it stores session object by its name - that is unique per one user only.

Therefore, QMF does not track all sessions, subscriptions (maybe something else) in those cases.

It is required to have unique session ID for QMF. Either having user ID as part of the session ID, or use pointer to the session object like AMQP 1.0 implementation uses.


Version-Release number of selected component (if applicable):
any (0.18-30, 0.22-48)


How reproducible:
100%


Steps to Reproduce:
1) Have usera:usera and userb:userb credentials for qpid broker
2) Compile below program:

#include <cstdlib>
#include <iostream>

#include <sstream>

#include <qpid/messaging/Address.h>
#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Session.h>


using namespace qpid::messaging;
using namespace qpid::types;

using std::stringstream;
using std::string;

int main(int argc, char** argv) {
    const char* session_name = argc>1 ? argv[1] : ""session_name"";
    const char* connectionOptions = argc>2 ? argv[2] : ""{username:guest, password:guest}"";
    const char* address = argc>3 ? argv[3] : ""myQueue; {create:always}"";
    Connection connection(""localhost:5672"", connectionOptions);
    try {
        connection.open();
        Session session = connection.createSession(session_name);
	Receiver receiver = session.createReceiver(address);
	receiver.fetch();

        connection.close();
        return 0;
    } catch(const std::exception& error) {
        std::cout << error.what() << std::endl;
        connection.close();
    }
    return 1;
}


3) ./session_attach_given_name aaa ""{username:usera, password:usera}"" &
4) ./session_attach_given_name aaa ""{username:userb, password:userb}"" &
5) grep errors in qpidd logs
6) check subscriptions (qpid-stat -u) and sessions (qpid-tool -> list session) that QMF is aware of


Actual results:
5) qpid prints errors:
2014-09-02 16:07:04 [Management] error Detected two management objects with the same identifier: 0-51-1--17(org.apache.qpid.broker:subscription:org.apache.qpid.broker:session:aaa,org.apache.qpid.broker:queue:myQueue,myQueue)
2014-09-02 16:07:04 [Management] error Detected two management objects with the same identifier: 0-51-1--14(org.apache.qpid.broker:session:aaa)

6) there is just 1 subscription for ""myQueue"" queue (while both programs create one) and just 1 session named ""aaa"".


Expected results:
no error, 2 subscriptions, 2 sessions

Additional info:
AMQP 1.0 connections/session works well here, as AMQP 1.0 does not have named sessions and string of pointer is used rather.
"
Bug,QPID-5835,12722766,[C++ broker] Broker recovery forgets auto-delete flag on queues and exchanges,pmoravec,pmoravec,Closed,Fixed,2014-06-21 20:49,C++,C++ Broker,,,,,,,"Description of problem:
When a durable node with auto-delete: true exists, the property is reset to false after broker restarts.

Version-Release number of selected component (if applicable):
(any)


How reproducible:
100%


Steps to Reproduce:
1. create durable node (queue) with auto-delete property set
./spout ""autodelq;{'create':'always', 'node': {'x-declare': {'auto-delete': True}}}""

2. create durable node (exchange) with auto-delete property set
 ./spout ""autodelex;{'create':'always', 'node': {'type': topic, 'x-declare': {'auto-delete': True}, 'durable':True}}""

3. check auto-delete flag
qpid-stat -q #for queue, use e.g. qpid-tool for exchange

4. restart broker
5. check auto-delete flag


Actual results:
'autoDelete': False is on both nodes


Expected results:
autoDelete property should survive the restart"
Bug,QPID-5485,12689209, Deleting paged queue does not remove underlying file,astitcher,pmoravec,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,,,,,,,"Description of problem:
When deleting a paged queue, the broker does not delete the underlying file it created in /var/lib/qpidd directory.


Version-Release number of selected component (if applicable):
MRG-M 3.0 EA (qpid-cpp 0.22-29)


How reproducible:
100%


Steps to Reproduce:
0. service qpiddd restart
1. qpid-send -a ""PagedQueue; {create:always, delete:always, node: { x-declare: {arguments: {'qpid.paging':'True' }}}}""
2. file /var/lib/qpidd/PagedQueue 


Actual results:
/var/lib/qpidd/PagedQueue: data


Expected results:
/var/lib/qpidd/PagedQueue: cannot open `/var/lib/qpidd/PagedQueue' (No such file or directory)


Additional info:"
Bug,QPID-5418,12684092,qpidd loading both linear and legacy store succeeds without a warning/error,chug,eallen,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"Qpidd loading both the new linear and legacy store succeeds without a warning/error.

The proposed solution is to raise and exception and generate a log message when this happens.

The legacy store and the linear store are not intended to be used together and will not be packaged together. If qpidd is attempting to load both, then that is an error condition and should be handled by the user before the broker can start."
Bug,QPID-5767,12714463,[C++ broker][linearstore] broker segfaults when recovering journal file with damaged header,pmoravec,pmoravec,Closed,Fixed,2014-06-02 15:38,C++,C++ Broker,,,,,,,"Description of problem:
If journal file has corrupted header (example below), especially if EFP identity is invalid, broker segfaults.

The reason is:

EmptyFilePool* EmptyFilePoolManager::getEmptyFilePool(const efpPartitionNumber_t partitionNumber,
                                                      const efpDataSize_kib_t efpDataSize_kib) {
    EmptyFilePoolPartition* efppp = getEfpPartition(partitionNumber);
    if (efppp != 0)
        return efppp->getEmptyFilePool(efpDataSize_kib);
    return 0;
}

returns null pointer that is taken in:

void RecoveryManager::analyzeJournals(const std::vector<std::string>* preparedTransactionListPtr,
                                      EmptyFilePoolManager* emptyFilePoolManager,
                                      EmptyFilePool** emptyFilePoolPtrPtr) {
    // Analyze file headers of existing journal files
    efpIdentity_t efpIdentity;
    analyzeJournalFileHeaders(efpIdentity);
    *emptyFilePoolPtrPtr = emptyFilePoolManager->getEmptyFilePool(efpIdentity);
    efpFileSize_kib_ = (*emptyFilePoolPtrPtr)->fileSize_kib();


One real world example to get damaged journal (header): disk gets out of free space just when generating a new journal file, such that the file is created as truncated and contains just zeroes.


Version-Release number of selected component (if applicable):
qpid-cpp 0.22-38


How reproducible:
100%


Steps to Reproduce:
0. Start broker with empty provisioning

1. Create a durable queue:
qpid-config add queue q --durable

2. Create an empty ""damaged"" journal file and set its permissions:
dd if=/dev/zero of=/var/lib/qpidd/qls/jrnl/q/$(uuidgen).jrnl bs=1024 count=2052
chown qpidd:qpidd /var/lib/qpidd/qls/jrnl/q/*
(To have the reproducer really reliable, remove the journal file that linearstore created. Just to have there only the ""damaged"" file with 0s.)

3. Restart broker


Actual results:
Broker segfaults, logging:
2014-05-15 12:42:00.421721427 [Store] warning Linear Store: Journal ""q"": Journal file /var/lib/qpidd/qls/jrnl/q/d09e7bfb-5efa-4d96-9071-ad1053377d36.jrnl is uninitialized
2014-05-15 12:42:00.616301329 [System] debug Exception constructed: Cannot read from child process.
2014-05-15 12:42:00.616558206 [Broker] critical Unexpected error: Cannot read from child process.


Expected results:
Broker raises critical exception (stopping its kick-off) with a message like ""Journal file .. has unknown EFP identity (pn=0,ds=0), please fix it"".


Additional info:"
Bug,QPID-5278,12676613,Queue flow limit validation ignores size parameters,pmoravec,pmoravec,Closed,Fixed,2014-05-30 9:56,C++,C++ Broker,,,,,,,"Broker allows a queue creation with --max-queue-size=1 --flow-stop-size=100.

Further, creating a queue with max-queue-(count|size) and _bigger_ flow-resume-(count|size) (and no flow-stop set) is allowed as well:

I.e. from commands:
qpid-config add queue WrongQueue1 --max-queue-count=1 --flow-stop-count=100 --durable
qpid-config add queue WrongQueue2 --max-queue-count=1 --flow-resume-count=100 --durable
qpid-config add queue WrongQueue3 --max-queue-size=1 --flow-stop-size=100 --durable
qpid-config add queue WrongQueue4 --max-queue-size=1 --flow-resume-size=100 --durable

All queues except the first one are created.

(it is discutable if e.g. ""max-queue-count=1 flow-resume-count=100"" should be allowed or not, as the logic is ""flow control defaults are changed only if flow-stop-* parameter is used"")


"
Bug,QPID-5609,12699387,QPID fails to compile in C++11 with Boost 1.54 ,,andyrobo60,Closed,Fixed,2014-04-02 21:40,C++,C++ Broker,C++ Client,,,,,,"QPID fails to compile with GCC 4.8.2 and Boost 1.54 in C+\+11 using the compiler flag ""-std=c++11"". 

This problem is caused by a change to Boost's shared_ptr. When compiling in c+\+11 the shared_pointer interface is changed to match c++11's std::shared_pointer. This causes the boolean conversion operator to be made explicit, preventing the implicit conversion to a boolean when returning a shared_ptr from a function. 

To get QPID to compile with GCC 4.8.2 and C+\+11 extra compiler flags are needed. After running CMake modify the CMakeCache.txt file and set the variable ""CMAKE_CXX_FLAGS"" to ""-std=c+\+11 -Wno-unused-local-typedefs -Wno-ignored-qualifiers -Wno-deprecated-declarations"". Passing the variable to CMake on the command line can cause problems as CMake doesn't like the '=' in the flag ""-std=c+\+11""."
Bug,QPID-5608,12699376, [amqp1.0] delete-on-close policy do not work for producers to exchanges,pmoravec,pmoravec,Closed,Fixed,2014-03-07 22:40,C++,C++ Broker,,,,,,,"Description of problem:
The delete-on-close lifetime policy is not applied to producers when the exchange is in use.


Version-Release number of selected component (if applicable):
0.24 (incl. current upstream)


How reproducible:
100%


Steps to Reproduce:
qpid-send --connection-options ""{protocol:'amqp1.0'}"" -a ""exSend;{create:always, node:{type: topic, properties:{lifetime-policy:delete-on-close}}}"" -m 100000 --send-rate=1 &
exSendPID=$!
sleep 1
qpid-send --connection-options ""{protocol:'amqp1.0'}"" -a ""exSend;{create:always, node:{type: topic, properties:{lifetime-policy:delete-on-close}}}"" -m 100000 --send-rate=1 &
sleep 1
kill $exSendPID
qpid-config exchanges exSend

Actual results:
- not-killed qpid-send is still running
- ""qpid-config exchanges"" shows:
Type      Exchange Name  Attributes
=============================================
topic     exSend        


Expected results:
- not-killed qpid-send should terminate after attempting to send to unkwnown exchange
- there should not be such exchange
"
Bug,QPID-5594,12698407,[amqp1.0] missing first-acquirer property support in C++ broker,pmoravec,pmoravec,Closed,Fixed,2014-03-03 12:48,C++,C++ Broker,,,,,,,"Description of problem:

There is a defined standard amqp1.0 property: first-acquirer. The broker shall support setting this property accordingly.

If this value is true, then this message has not been acquired by any other link. If this value is false, then this message MAY have previously been acquired by another link or links.

Version-Release number of selected component (if applicable):
qpid-cpp-*-0.22-33

How reproducible:
100%

Steps to Reproduce:
compile and run program:

#include <qpid/messaging/Address.h>
#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Session.h>
#include <qpid/messaging/Message.h>
#include <iostream>

using namespace std;
using namespace qpid::messaging;

int main(int argc, char ** argv)
{
    string queue=""q; {create: always}"";
    string broker=""127.0.0.1:5672"";
    if (argc > 1)
        queue=argv[1];
    if (argc > 2)
        broker=argv[2];
    for (unsigned i=0; i<2; i++)
    {
        Connection connection = Connection(broker, ""{protocol : 'amqp1.0'}"");
        connection.open();
        Session session = connection.createSession();
        if (i==0)
            session.createSender(queue).send(Message());
        Receiver receiver = session.createReceiver(queue);
        Message msg = receiver.fetch();
        cout << ""Properties: "" << msg.getProperties() << endl;
        connection.close();
    }
    return 0;
}



Actual results:
first-acquirer property is not set by the broker

Expected results:
first-acquirer property is set to true by the broker in the first message, and unset (or set to false) in the second message

Additional info:"
Bug,QPID-5587,12697921,QMF to track queue owner (userId),pmoravec,pmoravec,Closed,Fixed,2014-02-28 14:49,C++,C++ Broker,,,,,,,"Due to QPID-4692, it is possible to set limits on queue created by an owner via ACL. But there is no way of checking the current limit.

The easiest way of doing so is to add to QMF queue object userId, that is the queue owner / creator.


How reproducible:
100%


Steps to Reproduce:
qpid-send -a ""testQueue; {create:always}"" --connection-options=""{sasl-mechanism:'PLAIN', username:guest, password:guest}""
(try to check anywhere that ""guest@QPID"" owns/created the queue)


Actual results:
No way to see it.


Expected results:
E.g. qpid-tool -> show <queue_ID> should provide that information


Additional info:"
Bug,QPID-5565,12695941,[C++ broker] ACL queue create rules to take zero as unlimited value,pmoravec,pmoravec,Closed,Fixed,2014-02-26 14:13,C++,C++ Broker,,,,,,,"When declaring queue with e.g. qpid.max_size=0, the zero is interpreted as ""no limit in queue depth"". While ACLs deal with zero as ""queue depth is zero"". Therefore:

1) ACL rule like:

acl allow all create queue queuemaxsizelowerlimit=10

is not matched

2) ACL rule like:

acl allow all create queue queuemaxsizeupperlimit=1000

is matched.

While both is wrong.

The same applies to any numerically-compared properties of ACL queue create rule, specifically to:

acl::PROP_MAXPAGES
acl::PROP_MAXPAGEFACTOR
acl::PROP_MAXQUEUECOUNT
acl::PROP_MAXQUEUESIZE
acl::PROP_MAXFILECOUNT
acl::PROP_MAXFILESIZE


There are two approaches how to fix it:

1) in Broker.cpp, before calling ACL to authorize queue creation, replace zero value by 9223372036854775807 (as hardcoded maximum for ACL numerical value; see src/tests/Variant.cpp and/or src/tests/acl.py for more)

2) Within ACL, deal zero value as unlimited

The first approach would allow future parameters having 0 as real zero value. But Broker class would mimic/workaround some ACL work.

The second approach would resolve the problem in better place, but it would enforce that zero is interpreted as infinity everytime (can't it break something? or on the other side, can't it unify handling connection-limit-per-ip or max-queues-per-user options?)
"
Bug,QPID-5290,12677406,Attempt to enqueue message larger than page size should not end connection,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Rather it should result in a session-exception on 0-10 and a link-detach on 1.0, in keeping with similar error conditions."
Bug,QPID-5304,12677898,Unit test program has bad failure mode if XML_LIB is not set,astitcher,astitcher,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"If you have built the xml exchange, then it is impossible to just run the unit test program manually without at least setting XML_LIB as the program will abort very early on.

This is particularly annoying if you just want to test something unrelated quickly."
Bug,QPID-5108,12666331,session statistics Tx* not updated any time,,pmoravec,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Description of problem:
Tx* counters of Session QMF object are everytime zero, regardless if transactions are/have been used or not.


Version-Release number of selected component (if applicable):
0.22


How reproducible:
100%


Steps to Reproduce:
echo ""log-to-file=/tmp/qpidd.log"" > /etc/qpid/qpidd.conf
echo ""auth=no"" >> /etc/qpid/qpidd.conf
echo ""trace=yes"" >> /etc/qpid/qpidd.conf
rm -rf /tmp/qpidd.log 
service qpidd restart
qpid-send -m 20 -a ""myQueue; {create:always}"" --tx 2 --rollback-frequency 2
sleep 10
grep Tx /tmp/qpidd.log | grep session

(optionally, check the the session statistics in qpid-tool)


Actual results:
2013-08-30 10:22:38 [Model] trace Mgmt delete session. id:18f9a28a-f5b0-4e9d-9fe7-dc49a1463e6a Statistics: {TxnCommits:0, TxnCount:0, TxnRejects:0, TxnStarts:0, clientCredit:0, unackedMessages:0}
2013-08-30 10:22:38 [Management] trace Deleting V2 map={_create_ts:1377850955102035092, _delete_ts:1377850955109735713, _object_id:{_agent_epoch:1, _object_name:org.apache.qpid.broker:session:18f9a28a-f5b0-4e9d-9fe7-dc49a1463e6a}, _schema_id:{_class_name:session, _hash:1aaa08d0-c118-ff78-0956-47b9ac9c6849, _package_name:org.apache.qpid.broker, _type:_data}, _update_ts:1377850955102035092, _values:{TxnCommits:0, TxnCount:0, TxnRejects:0, TxnStarts:0, attached:False, channelId:1, clientCredit:0, connectionRef:{_agent_epoch:1, _object_name:org.apache.qpid.broker:connection:127.0.0.1:5672-127.0.0.1:52255}, detachedLifespan:0, name:18f9a28a-f5b0-4e9d-9fe7-dc49a1463e6a, unackedMessages:0, vhostRef:{_object_name:org.apache.qpid.broker:vhost:org.apache.qpid.broker:broker:amqp-broker,/}}}

See ""TxnCommits:0, TxnCount:0, TxnRejects:0, TxnStarts:0"" in both trace logs / qpid-tool

Expected results:
TxnCommits:6, TxnCount:11, TxnRejects:5, TxnStarts:1
(10 transactions, every 2nd rejected, plus one extra at the end)
"
Bug,QPID-5531,12692523,[C++ broker] Set timeout for every DTX transaction,pmoravec,pmoravec,Closed,Fixed,2014-02-10 11:02,C++,C++ Broker,,,,,,,"Description of problem:
If an external Transaction Manager (TM) prepares a DTX transaction but forgets, due to any reason, to commit or abort it, tpl journal has an orphaned enqueue record forever (that in legacystore causes enqueue capacity threshold exception after a while, preventing _any_ transaction to commit/abort).

To prevent such orphaned XID entries in tpl, every incoming DTX transaction should have a default timeout set (while dtx.set-timeout AMQP 0-10 primitive changes it).

The timeout should be broker-wide parameter configurable via --dtx-default-timeout option.


Version-Release number of selected component (if applicable):
any (incl upstream 0.26)


How reproducible:
100%


Steps to Reproduce:
1. Mimic an external TM that prepares a DTX but never commits or aborts it - use e.g. _modified_ qpid-txtest (patch attached):
qpid-txtest --queues=1 --total-messages=1 --dtx=1 --dtx-commit=no

2. /usr/libexec/qpid/store_chk /var/lib/qpidd/rhm/tpl -b tpl


Actual results:
tpl journal keeps the unfinished transaction forever


Expected results:
sleeping for dtx-default-timeout, the transaction should be gone"
Bug,QPID-5534,12692703,[C++ broker] Headers exchange can route a message to one queue multiple times,pmoravec,pmoravec,Closed,Fixed,2014-02-03 12:49,C++,C++ Broker,,,,,,,"If a message sent to a headers exchange matches two bindings to one queue, it is enqueued to that queue twice.

Further, if the queue and the message are durable, journal raises error:

JERR_MAP_DUPLICATE: Attempted to insert record into map using duplicate key.


Reproducer:

qpid-config add queue MyQueue --durable
qpid-config bind amq.match MyQueue SomeKey any property1=value1
qpid-config bind amq.match MyQueue OtherKey all property2=value2
qpid-send -a ""amq.match"" -m 1 -P property1=value1 -P property2=value2 --durable=true
"
Bug,QPID-5281,12676850,Creating a queue with invalid settings results in no queue but only its management object exists,pmoravec,pmoravec,Closed,Fixed,2013-11-19 15:56,C++,C++ Broker,,,,,,,"Description of problem:
An attempt to create a queue with invalid settings (like max-queue-count < flow-stop-count) returns a QMF error and the queue is not created (can't send messages there or subscribe a consumer to it). But relevant QMF object is still present (listing all queues finds it).


Version-Release number of selected component (if applicable):
any (incl. 0.24 and upstream)


How reproducible:
100%


Steps to Reproduce:
0. rm -rf /var/lib/qpidd/* /var/lib/qpidd/.*; service qpidd restart
1. qpid-config add queue WrongQueue1 --max-queue-count=1 --flow-stop-count=100 --durable
2. qpid-send -a WrongQueue1 -m1
3. qpid-config queues WrongQueue1


Actual results:
1. returns:
Failed: Exception: Exception from Agent: {u'error_code': 7, u'error_text': 'invalid-argument: Queue ""WrongQueue1"": qpid.flow_stop_count=100 must be less than qpid.max_count=1 (/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/broker/QueueFlowLimit.cpp:58)'}

2. returns:
2013-10-30 07:57:18 [Client] warning Exception received from broker: not-found: not-found: Queue not found: WrongQueue1 (/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/broker/QueueRegistry.cpp:127) [caused by 2 \x08:\x01]
qpid-send: Queue WrongQueue1 does not exist

3. returns:
Queue Name   Attributes
===================================
WrongQueue1  --durable --max-queue-count=1 --flow-stop-count=100 


Expected results:
1. and 2. as actual results, but 3. should return no such queue


Additional info:
Continuing in the reproducer, restarting the broker and running ""qpid-config queues WrongQueue1"" again shows no such queue exists - despite the queue was attempted to be created as durable. That just supports the theory that Queue object has not been created but its Management version was."
Bug,QPID-4767,12644012, [legacystore] QMF commands to create a persistent queue with an illegal number of journal files or journal file size should be rejected,kpvdr,kpvdr,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"QMF queries that request a queue to be created with more than 64 journal files (max journal files per queue are 64) should be rejected instead of translated to the maximum value (64). Current behaviour doesn't inform the user that less files are used (only a warning on server side) and is creating something that is not what the user asked for.

This behavior applies also to the journal size parameter where the size is larger or smaller than the minimum or maximum allowable value."
Bug,QPID-4794,12645588,Resizing qpid legacystore journal does not update queue arguments provided by QMF,kpvdr,kpvdr,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"Durable queues that are created through QMF and which override the default legacystore options for journal file size and number carry these settings as part of the queue, and are reported by QMF as queue arguments. For example,{u'qpid.file_size': 20, u'qpid.file_count': 20}.

However, it is possible to change the journal geometry offline (ie with the Qpid broker stopped) using a resize utility to expand the size of the queue's journal. When this happens, the queue is successfully recovered, but QMF continues to report the original size information. The recovery process fails to update the queue settings and QMF."
Bug,QPID-4765,12643981,Incorrect parameter validation for legacystore wcache-page-size and jfile-size-pgs,kpvdr,kpvdr,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"The store module incorrectly changes the size of the page cache to 64kB when the file size parameter is equal to 1 (--jfile-size-pgs=1) for any valid page cache size. This should only happen when the page cache size is set to 128kB.

The legacystore file size is specified in terms of the read cache size (which is fixed to 64kB). Hence a jfile-size-pgs set to 1 creates 64kB files, the smallest allowed. However, the write page cache, set by the wcache-page-size parameter, cannot be larger than the physical file size, as libaio uses DMA to write each page, and this cannot be split between files. This can occur for only one legal setting of wcache-page-size, ie 128kB. In this case only, a check must be made to see if the file size parameter jfile-size-pgs==1. If so, then the write cache size exceeds the physical file size, and must be reduced to be the same as the physical file size, ie 64kB.

The logic incorrectly makes this change for all legal write page cache size values, not just the maximum of 128kB where this change is required."
Bug,QPID-4736,12641930,"Legacy store ""Recovery found"" log entries at wrong severity",chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"These logs should have lower severity (recommending info), as they occur when number of files or file size differs from default. And it is normal to provision a journal with non-default parameters, thus info level is more appropriate than warning.
"
Bug,QPID-3189,12503486,Queue policy error can occur due to previous errors with persistent store,gsim,szhemzhitsky,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,http://mail-archives.apache.org/mod_mbox/qpid-users/201104.mbox/%3COFDD331305.06654D6C-ONC3257865.002003A9-C3257865.00208F3C@troika.ru%3E
Bug,QPID-5060,12662641,[C++ broker] Topic created as durable contains the durable=true in properties without having any effect on the subscription queues,gsim,scholzj,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,"A durable topic can be created with the qpidt utility by specifinfg the ""durable=true"" option, e.g.:

{{qpidt create topic x *durable=true* exchange=response qpid.max_count=1000 qpid.max_size=1000000 qpid.policy_type=ring}}

That creates a topic which is indeed durable, but also contains the durable flag in the properties: 

{{Object of type: org.apache.qpid.broker:topic:_data(6182b36f-9f09-4118-2881-fb69e5355628)
    Attribute    165
    ======================================================================================================================================================
    name         x
    exchangeRef  145
    durable      True
    properties   {u'qpid.max_size': u'1000000', *u'durable': u'true'*, u'qpid.policy_type': u'ring', u'qpid.max_count': u'1000', u'exchange': u'response'}
}}

This might be confusing because the durable property is not propagated to the subscription queues created from this topic. To avoid the confusion, the durable option should not be added to the properties."
Bug,QPID-4687,12640131,Add uninstall make target to cmake build,aconway,aconway,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,,,,,,,Add an uninstall target to remove files installed by the install target.
Bug,QPID-3117,12500460,qpidd --help output on --sasl-config is misleading,mgoulish2,mgoulish2,Closed,Fixed,2013-08-20 20:42,C++,C++ Broker,,,,,,,"The --help output suggest that --sasl-config points to a file.  But it points to a directory.

"
Bug,QPID-3138,12501079,Perf improvement for topic exchange,cctrieloff,cctrieloff,Closed,Fixed,2013-08-20 20:42,C++,C++ Broker,,,,,,,"
The follow patch introduces a cache for route matches allow the producer to return to IO faster allowing for >50% perf gain for the topic exchange.

The cache is cleared on the addition or removal of a binding forcing cache re-population."
Bug,QPID-3403,12518362,Empty bindings are not internally pruned from the direct exchange,gsim,dillaman,Closed,Fixed,2013-08-20 20:37,C++,C++ Broker,,,,,,,"Each queue that is created is automatically bound to the default (direct)
exchange with a routing key that matches the queue name.  When the queue is
deleted, the queue is correctly removed from the binding map, but the mapping
from routing key to queues is not removed even when there are no queues bound
to the routing key.  

In a case where thousands of uniquely named queues are created and deleted as
transient storage, the memory usage of the broker will continue to grow as the
default exchange's routing key map continues to grow. "
Bug,QPID-3942,12550353,XID printed as binary form in trace logs,gsim,wprice,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Currently the C++ Broker prints the XID for a transaction in binary form:

Example:

2012-03-16 09:14:13 error Execution exception: illegal-state: Branch
with xid \x06\x04\x07

It would be nice to have this printed as something more human readable in order to aid debugging/tracing."
Bug,QPID-969,12394789,Qpid/C++ M2 build failure in man file generation,,danushka,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"This is the console output ...

Updating man page qpidd.1
/bin/bash /home/danushka/development/qpid/m2/qpidc-0.1/build-aux/missing --run help2man --no-info --include=./qpidd.x --output=qpidd.1-t ../../src/qpidd
help2man: can't get `--help' info from ../../src/qpidd
"
Bug,QPID-3243,12506096,C++ broker ignores --max-queue-count queue size parameter when setting default queue flow limits.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"

If a user configures a maximum queue size based on message count via
qpid-config, the default producer flow control limits are not correctly
computed.




Steps to Reproduce:
1.  qpid-config add queue fleabag --max-queue-count=1000


Actual results:
Queue is created without msg-count based flow control limits:
2011-05-03 16:15:57 info Queue ""fleabag"": Policy created: type=reject;
maxCount=1000; maxSize=104857600
2011-05-03 16:15:57 info Queue ""fleabag"": Flow limit created: flowStopCount=0,
flowResumeCount=0, flowStopSize=83886080, flowResumeSize=73400320


Expected results:
Queue should be created with flowStopCount=800 & flowResumeCount=700 (using
broker-wide default ratios).
"
Bug,QPID-2949,12480132,broker prompts console interactively for password when --auth=no,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"As a result of checkin svn r1024541, which promoted some client-side Sasl code to the common library for use in broker, the broker now prompts for a password when when it is run with --auth=no  !    

The attached patch removes this behavior by propagating knowledge of ""--auth=no"" down to SaslFactory.  If authorization has been turned off, the Saslfactory will create a null sasl object, just like it does if the code is compiled with no Sasl support.


TODO -- also must fix the pathway where auth==yes.

NOTE: this is apparently an irritant rather than a disaster, since it did not affect make check after the original checkin ( r102451 )."
Bug,QPID-2461,12459637,Bashisms in test scripts,gsim,neilw,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"There are bashisms in the test scripts.  They should request bash on the first line (#!/bin/bash)

Affects all shell scripts in src/tests/


"
Bug,QPID-3666,12534195,QMF v1 method requests may fail if new object's id overlaps an old deleted object.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"If a broker object, such as a queue, is created, deleted, and re-created, the new(est) QMF management object is still indexed by the old key value.  This is OK for QMF v2 keys, but v1 keys contain a sequence number which is not correctly updated.  This may result in v1 queries for the new object to fail."
Bug,QPID-1071,12396312,Publish interval for management can be set to zero,tross,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,The --mgmt-pub-interval option can be set to zero causing very high CPU usage on the broker.
Bug,QPID-3804,12540976,Rollback or release of an acquired group message may result in message reorder.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Given a message group queue with the following message distribution:

oldest->A, B, A, ...

If a consumer acquires A0, then rollsback the acquisition, the next fetch returns B0, followed by A0 (redelivered)

The correct order should be: A0 (redelivered), B0, A1, ..."
Bug,QPID-1154,12399120,Compile warning re casts in qpid/broker/SaslAuthenticator.cpp,gsim,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Compiling C++ broker yields the following warning which the build settings promote to an error:

qpid/broker/SaslAuthenticator.cpp: In member function `void qpid::broker::CyrusAuthenticator::processAuthenticationStep(int, const char*, unsigned int)':
qpid/broker/SaslAuthenticator.cpp:237: warning: cast from `const void*' to `char*' discards qualifiers from pointer target type
qpid/broker/SaslAuthenticator.cpp:239: warning: cast from `const void*' to `char*' discards qualifiers from pointer target type

The attached patch resolves this by using multiple casts: cast const void* to const char *, then const_cast to discard const."
Bug,QPID-3150,12501725,sasl_fed test fails to specify client's sasl mechanism,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"this is a problem with the test in cpp/src/tests/sasl_fed -- not with the broker.

the client should use DIGEST-MD5 when connecting to the broker -- but this is not specified on the command line.  It was succeeding accidentally on some systems but, recently, not on others.
"
Bug,QPID-3144,12501395,qpidd --check does not work with info logging and --log-to-stdout=yes,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"qpidd --check is supposed to print the PID of a running qpidd --daemon, for use in scripts and the like. However with info logging and log-to-stdout enabled this does not work because log messages of the form:
   2011-03-14 16:21:05 info Loaded Module: /usr/lib64/qpid/daemon/cluster.so
precede the port number."
Bug,QPID-1728,12416754,not-attached error messages logged for clustered federation links,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"E.g. 
error Channel exception: not-attached: receiving Frame[BEbe; channel=0;
{ConnectionStartBody:
server-properties={qpid.federation_tag:V2:36:str16(e934afe1-6cc0-416a-b16d-a1ca6e6a6d75)};
mechanisms=str16{V2:9:str16(ANONYMOUS), V2:5:str16(PLAIN)};
locales=str16{V2:5:str16(en_US)}; }]: channel 0 is not attached
(qpid/amqp_0_10/SessionHandler.cpp:79)  

Everything still works so this is not critical, but its untidy and alarming for users to see errors."
Bug,QPID-1745,12417105,C++ Windows; IntegerTypes.h need not define size_t,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The qpid/cpp/src/qpid/sys/windows/IntegerTypes.h file typedefs size_t. This is not necessary for VC9, and the definition conflicts with the proper def for 64-bit builds. Removing the typedef for size_t works for both 32- and 64-bit builds."
Bug,QPID-3481,12522811,Acquired messages are not sent to alternate exchange when queue is deleted and receiver's session closed,tross,ncdc,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Currently, the broker will lose messages in the following scenario:

1. Client creates receiver to a queue (queue has an alternate exchange configured)
2. Client acquires message from queue
3. Client closes receiver (with delete:always or delete:receiver)
4. Client closes session

We expect that the messages should be sent to the now-deleted queue's alternate exchange if/when they are released.

Messages are not sent to the alternate exchange immediately upon closure of the receiver because the client still has acquired messages; this is fine, but when the client either releases the messages or closes the session, these messages should be sent to the alternate exchange."
Bug,QPID-1678,12415485,better cluster names in cluster_failover soak ,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"cluster_failover_soak  in   cpp/src/tests currently uses a random number between 0 and 1000 as the uniqing factor in its cluster names.   There may have been a collision recently when two tests were running simultaneously on one clustered setup during a Ptolemy test.

This change make it use UUIDs.   If one of these collides please tell me, so I can buy a lotto ticket with that number on it.

"
Bug,QPID-1555,12411629,"When run with -d option, C++ broker dies with ""No Such Transport (tcp)"" error",,joshuak,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"When using 'head' as checked out of SVN at approx. 1 AM EST on Saturday, 03-Jan-09, the following occurs.

If I run the broker using these options:
sbin/qpidd -t --config /opt/qpid-m4/etc/qpidd.conf

The broker runs, and I can connect to the broker.  If I add the -d option to run as a daemon, the broker dies right away.  In the logfile is an error:

2009-jan-04 01:43:45 debug Exception constructed: No such transport: 'tcp' (qpid/broker/Broker.cpp:389)
2009-jan-04 01:43:45 critical Daemon startup failed: No such transport: 'tcp' (qpid/broker/Broker.cpp:389)
2009-jan-04 01:43:45 notice Shut down

Note that I have created the NSS / SSL certificates exactly as described in the 'SSL' file in the 'cpp' directory.

/opt/qpid-m4/etc/qpidd.conf is as follows:

data-dir=/opt/qpid-m4/var/lib/qpidd/data
pid-dir=/opt/qpid-m4/var/lib/qpid
auth=yes
realm=devbox
require-encryption=yes 
log-to-file=/opt/qpid-m4/var/log/qpidd.log
ssl-cert-db=/opt/qpid-m4/etc/qpid_cert_db
ssl-cert-password-file=/opt/qpid-m4/etc/cert.password
ssl-cert-name=home-av-server.home-av
ssl-port=5671
load-module=/opt/qpid-m4/lib/qpid/daemon/ssl.so

/etc/sasl2/qpidd.conf is as follows:

mech_list: plain anonymous
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /opt/qpid-m4/var/lib/qpidd/qpidd.sasldb
"
Bug,QPID-1892,12427253,qpid-config and qpid-tool show deleted queue (durable only),tross,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"(Reported by Gordon Sim)

Description of problem:

The command line management tools keep showing a durable queue that was
recovered on last restart but subsequently deleted.

Steps to Reproduce:
1. create durable queue using qpid-config (E.g. qpid-config --durable add
my-queue)
2. restart qpidd (E.g /sbin/service qpidd restart)
3. delete the queue (E.g. qpid-config del queue my-queue)
4. list queues (I.e. qpid-config queues)

Actual results:

The deleted queue is still shown by both qpid-config and qpid-tool. If you
restart qpidd again then it disappears.

Expected results:

The queue has been deleted so should not appear in the list produced by
'qpid-config queues'. In qpid-tool it should be marked as deleted.
"
Bug,QPID-3970,12552195,"If reroute specifies that alt exchange should be used, and no such exchange was defined, then messages are silently dropped",gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"In itself a minor issue (though probably nicer to flag toe problem), but it is made worse in combination with https://issues.apache.org/jira/browse/QPID-3969."
Bug,QPID-2216,12441625,Error for missing ssl-cert-db option reports wrong option name,,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"On Linux, trying to run the broker with the ssl module, but forgetting the ssl-cert-db option, yields:

2009-11-24 18:48:18 info SSL plugin not enabled, you must set --qpid-ssl-cert-db to enable it.

Two problems:
1. It's an 'info' message, so is not visible with default logging level set; I added -t to see this.
2. the option that must be set is --ssl-cert-db, not --qpid-ssl-cert-db (--help reports it correctly)
"
Bug,QPID-1732,12416837,"When an exchange is deleted, the binding-count for bound queues is not adjusted for deleted bindings.",tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If an exchange is declared, bound to a queue, then deleted.  The binding-count on the queue will not decrement to reflect the automatic deletion of the binding.
"
Bug,QPID-4264,12605309,Priority queue does not keep an accurate count of available messages,aconway,dillaman,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"While investigating QPID-4262, discovered via code review that the PriorityQueue does not properly update its backing ""fifo"" MessageDeque's available count when PriorityQueue::removeIf is invoked. 

This might prevent the deletion of a queue and might result in queue listeners being woken up unnecessarily."
Bug,QPID-3282,12508470,Potential bug when checking socket connections for identical local and remote endpoint,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Currently there is a check in Socket::connect that tries to make sure we don't try to connect to the same endpoint that the local end is bound to, this can happen in rare circumstances when connecting to localhost when the OS decides to bind the local end to a port that has just been given up by an exiting application that we are just about to retry connecting to.

However the existing test doesn't canonicalise the endpoint names so it might try to do a string compare of ""localhost:1234"" with ""127.0.0.1:1234"" and fail even though it should succeed."
Bug,QPID-3035,12497573,Removing a sequence number from a SequenceSet can corrupt the sequence.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Given a SequenceSet with disjoint sub-sequences, deleting from the end of one sequence will corrupt a following sequence (if present).  

Example - given the following sequence:

{[1,6] [10,20]}

deleting the sequence ""6"" will result in the following:

{[1,5] [7,20]}

the trailing subsequence now incorrectly includes 7-9."
Bug,QPID-2030,12432301,C++ broker on Windows fails startup if the piddir does not exist,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the C++ broker on Windows is started but the directory specified (or defaulted) by --pid-dir does not exist, the broker will quickly shut down with output similar to:

2009-08-04 14:00:09 notice Shut down
2009-08-04 14:00:09 critical Broker start-up failed: The system cannot find the path specified.  (..\..\src\qpid\sys\windows\LockFile.cpp:46)

Two issues...
1. The broker should try to create the directory if it does not exist; the posix broker does this.
2. On a failure, it would be helpful to be more explanatory.

Thanks to Cliff Jansen for describing this failure case."
Bug,QPID-3465,12521312,byteDepth is only uint32,tross,scholzj,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Hi,

It seems that the queue schema handles the byteDepth parameter only as uint32 (eventually count32 in management-schema.xml). Given the possibilities for queue sizes, the uint32 seems to be insufficient. I already run into situations, when the uint32 is not enough:

    msgDepth               30000155
    byteDepth              3421958148
    byteTotalEnqueues      24896794628
    byteTotalDequeues      0

It makes the byteDepth value unreliable and thus useless. Of course, the actual depth can be always calculated from the byteTotalEnqueues and byteTotalDequeues values, but it would be probably easier if already the byteDepth value would be uint64.

Thanks & Regards
Jakub"
Bug,QPID-2385,12455174,Qpid C++ broker: delivery property ,gsim,xeop-nollarm,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Consider the following scenario:

- start two clustered brokers (B1 and B2) with durable queue Q and durable topic exchange E (the configuration of queues, exchanges and bindings must be persistent)
- create binding between Q and E for all messages
- start a consumer application C, connect it to B2, waiting for messages in queue Q
- start a publisher application P, connect it to B1, start continuous message transfer to exchange E
- stop broker B2
- P is still connected to B1 and is publishing messages
- start broker B2
- reconnect C to B2

The first N messages received by C after the reconnect are missing the delivery property ""exchange"".

This problem has also been reported as Red Hat service request #1991690.
"
Bug,QPID-2600,12464311,ACL policy doesn't permit certain characters in usernames added to groups,rajith,rajith,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem:
Unable to add a host principle to a group, the acl policy file fails to load and prevents qpidd from running.
I guess this is partly due to us not figuring out what is exactly allowed for group and usernames.

How reproducible:
Fails every time.

Steps to Reproduce:
1. Add a host or service principle to a group in the acl file. Something like
this will suffice:
  group somegroup host/somemachine.example.com@EXAMPLE.COM

Actual results:
Failure to start. Error message is:
Daemon startup failed: Could not read ACL file ACL format error:
/etc/qpid/policy.acl:25: Name ""host/somemachine.example.com@EXAMPLE.COM""
contains illegal characters.

Expected results:
Should load and parse the group cleanly.    "
Bug,QPID-4543,12628421,"QMF queueMoveMessages method returns ""InvalidParameter"" exception when there are simply no messages available to move from the source queue - this is confusing.",tross,fadams,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"QMF queueMoveMessages method returns ""InvalidParameter"" exception when there are simply no messages available to move from the source queue - this is confusing.

Other queue management commands (such as purge and reroute on the queue object) don't object when there are no messages to move but queueMoveMessages barfs with InvalidParameter.


This is inconsistent and it's pretty unhelpful, I spent about an hour checking over my code and looking through the broker code thinking I'd messed up the arguments. When I finally got round to actually adding some messages ""just to see"" it actually worked. Perhaps I should have tried that sooner, but as I say purge and reroute don't behave this way so it was fairly reasonable to assume I'd done something wrong...

I personally think that queueMoveMessages should behave the same as purge and reroute and attempt to move whatever. It should only send back InvalidParameter if one of the parameters is actually invalid. It could be argued that trying to move zero messages is invalid, but a qty value of 0 means ""all messages"" and all of zero is zero.




"
Bug,QPID-4518,12624885,Unknown qpidd config-file options should prevent startup.,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Mis-spelled config file options are ignored silently.
They should cause a warning, and halt startup.
"
Bug,QPID-1183,12400530,perftest doesn't work correctly when sizeof(size_t) != sizeof(uint32_t),,mteira,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"perftests makes some tests injecting some sequence number in the message data, expecting to find the same data inserting and fetching later the message from the queue. The way sequence number is inserted in implicitly assuming that size_t is the same size than uint32_t. If this is not true, the inserted data is not the expected, and the test fails.

I'm attaching a patch to fix the issue.
"
Bug,QPID-2181,12439545,Alternate exchange on queue is not visible in management tools,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If an alternate exchange is set on a queue, that fact is not visible with either qpic-config or qpid-tool (i.e. altExchange is not even in the qmf model for broker queues).
"
Bug,QPID-1523,12410336,--acl-file doesn't accept an absolute path,gsim,rajith,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Currently the acl file name is specified via --acl-file, is loaded relative to the data dir.
If an absolute path is specified then it should use that path instead of trying to look for it relative to the data dir."
Bug,QPID-3154,12501804,Fix qpidd late/overran warnings.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Warnings for late-and-overrun tasks were not being correctly reported. They were reported with 0 values.

Lateness for overrun tasks below the late threshold was not being reported. This leads to reports of e.g. overran by 3ms, with no indication of lateness when in fact the event was overrun _and_ late by 3ms."
Bug,QPID-1068,12396261,C++ configure fails if help2man not present,astitcher,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Recent email suggested that help2man is not really a requirement for configuring/building the C++ code, and if it's not present, the man pages should not be generated. However, if help2man is  not present, the configure fails. This patch fixes that - if help2man is not present, the docs/man directory is not built."
Bug,QPID-557,12376706,Clean  up all avoidable valgrind issues ,,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid/cpp/src/tests/.valgrind.supp-default suppresses a bunch of leaks and other errors. They appear to be harmless but most can probably be avoided by minor rework of the code. Clean up all the avoidable issues and trim the suppressions file down to the bare minimum of unavodiable errors harmless error reports, annotate each error remaining with comments explaining why it is harmless.
"
Bug,QPID-4041,12559392,Check for valid protocol occurs before actual protocol value is available.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Issue found by Andy Goldstein.
Bug,QPID-2499,12461824,Stale federation routes remain after route deletion.,jonathan.robie,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When the same routing key is used for multiple bindings, deleting one of the bindings may not remove routes that are dependent on that binding.  This will result in unnecessarily forwarding some messages.

I will attach a script that exhibits this bug shortly.

"
Bug,QPID-4686,12640118,Mention ldconfig in cpp/INSTALL instructions,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Now that the install are using cmake, we need to note the need to run ldconfig after installing libraries."
Bug,QPID-1993,12430897,"Solved the ""ignoring return value"" error",gsim,chenta,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Every time I get the latest source code from the repository. The compiler always complain about ignoring return value. 
The original trick to suppress this warning seems ok. But maybe the recent version of gcc doesn't accept this trick anymore. So I decide to use a temporary variable to handle this problem."
Bug,QPID-3488,12523132,Setting receiver capacity to zero does not always stop the message flow,gsim,dillaman,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Calling ""setCapacity(0)"" on a receiver sends out a MessageStopBody to the broker, which in turns causes the broker to reset the credits to zero.  However, there is a potential race condition if any MessageTransferBody completions for the same receiver are later sent to the broker.  When the broker receives the completions, it will increase the credit, resulting in additional messages being transferred to the receiver.

Steps to reproduce:
1) Create a receiver and set a non-zero capacity
2) Receive one or more messages from the receiver
3) Set the receiver capacity to zero
4) Release the accepted messages back to the broker
5) Ensure that the session sends a completion (e.g. have another receiver on the session w/ capacity 1 and get a single message)

Actual Results:
The receiver will receive additional messages since its credit was increased on the broker

Expected Results:
The receiver will not receive additional messages"
Bug,QPID-3787,12540182,Segfault in SslPlugin during shutdown,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the SslPlugin (ssl.so) module is loaded but the ""--ssl-cert-db"" option is not set, the broker will core dump on shutdown.  This is because shutdownNSS is called in the SslPlugin destructor when initNSS was never called.
"
Bug,QPID-3638,12532354,incompatibility with new boost version 1.48,tross,nsantos,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid/log/Logger.cpp:26:43: fatal error: boost/pool/detail/singleton.hpp: No such file or directory

Looks like the code under boost/pool has been re-organized in version 1.48, and that file no longer exists."
Bug,QPID-3982,12554057,C++ broker on Windows hangs on shutdown intermittently,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If the broker is shut down while it is processing client requests, it may hang. The hang is intermittent but more likely to happen when under higher load."
Bug,QPID-2335,12444960,Arguments for a binding to an XML exchange are not visible through management,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If you create a binding to the XML exchange (using python/examples/xml-exchange/declare_queues.py for example), then look at the binding using qpid-tool, the arguments field is {} (an empty map).

Arguments for headers exchanges can be viewed correctly, this only affects the xml exchange.
"
Bug,QPID-1121,12397488,Broker Federation - Link to unresolvable destination cannot be deleted,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If an inter-broker federation link to a destination who's name cannot be resolved to an IP address is created, that link will hang in ""connecting"" state and cannot be deleted.
"
Bug,QPID-4531,12626962,Variant.cpp cast of -0 failing with older GCC,mgoulish,mgoulish,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Cast of negative zero to a signed type is throwing with GCC 4.1.2, but not with GCC 4.4.6 .

This causes a failure in unit tests."
Bug,QPID-3577,12529878,An empty (null string) message group identifier is not assigned to the default group.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"A message who's group id is not specified or a null string should be assigned to the default group (per feature requirements).  While this is done if no group header is present, a null group id is not correctly handled."
Bug,QPID-3410,12518445,Queue configuration error - priority queue created by default.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"A bug in the queue configuration logic causes a priority queue to be created by default.  The default queue type should be a simple FIFO queue, not a priority queue."
Bug,QPID-2957,12480684,Management methods on the broker don't work on newly created objects,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If you create a queue from the API and immediately try to invoke a method on the queue using a QMF map message, the queue will not be found.  Only after the next publish interval occurs can the queue be addressed for method calls.
"
Bug,QPID-1457,12408361,Impossible to suspend a foreground qpidd,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"If you run qpidd from the command line and then hit ^Z to suspend it, nothing happens. The program is not suspended.

It appears that this is deliberate behaviour is there is code to ignore SIGTSTP etc:

    signal(SIGTSTP,SIG_IGN); 
    signal(SIGTTOU,SIG_IGN);
    signal(SIGTTIN,SIG_IGN);

I think this code is in error"
Bug,QPID-2235,12442454,clustered broker does  not retry CPG calls that return TRY_AGAIN,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Causes occasional failures on joining a cluster like this:

soak-22: 2009-12-03 15:49:44 notice Initializing CPG
soak-22: 2009-12-03 15:49:44 critical Unexpected error: Cannot join CPG group soakTestCluster_9edd905b-92b3-4cfb-803f-120d7a088f1f: try again (6)

"
Bug,QPID-4684,12640113,Remove obsolete options from example qpidd.conf file.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Remove this obsolete option from the sample qpidd.conf, qpidd was failing to start with an ""unknown option"" message:

  cluster-mechanism=DIGEST-MD5 ANONYMOUS
"
Bug,QPID-3168,12502313,"C++ Broker: fix the ""--help"" text description of flow control thresholds.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The following text is incorrect:

  --default-flow-stop-threshold %MESSAGES (80) 
                                        Queue capacity level at which flow 
                                        control is activated.
  --default-flow-resume-threshold %MESSAGES (70) 
                                        Queue capacity level at which flow 
                                        control is de-activated.

Correction:

  --default-flow-stop-threshold PERCENT (80) 
                                        Percent of queue's maximum capacity at which flow 
                                        control is activated.
  --default-flow-resume-threshold PERCENT (70) 
                                        Percent of queue's maximum capacity at which flow 
                                        control is de-activated.
"
Bug,QPID-3755,12538318,Concurrent queue bind on the same queue results in crash,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem:
While concurrently creating bindings to the same queue from multiple broker
connections, the broker will periodically crash.  

How reproducible:
Frequently

Steps to Reproduce:
1. Concurrently create bindings to the same queue

Actual results:
Qpid broker will crash

Expected results:
Qpid broker does not crash and bindings are created"
Bug,QPID-3669,12534394,Path to qpidd_watchdog executable is hard coded in qpidd,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,See https://bugzilla.redhat.com/show_bug.cgi?id=759114
Bug,QPID-4669,12639142,require proton 0.3 or greater,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,0.2 is too out of date and qpidc won't compile against it.
Bug,QPID-2188,12439939,#NAME?,cctrieloff,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,,,,,,,"The --max-connections option currently has no effect.It should work as follows:

--max-connections: set the maximum number of client connections. If there are
max-connections clients connected, the broker will reject any new connection
attempts and log a warning. The existing connections are not affected.

"
Bug,QPID-934,12394214,Federation tests fail intermittently,,tross,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,,,,,,,"The federation tests in the C++ broker fail intermittently (once every 5-10 attempts).  The failures occur when a management ""get"" for broker objects yields zero brokers.
"
Bug,QPID-117,12356194,C++ code won't build on Ubuntu due to assumptions about where apr headers live,aconway,astitcher,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"The C++ code includes apr headers using ""apr-1/apr_..."" this doesn't generally work as the spr headers need not be in a subdirectory called this. Indeed under Ubuntu they are in a directory called apr-1.0.

The solution is to follow the normal include usage for apr and just include ""apr_,,,""."
Bug,QPID-296,12360537,C++ Header guards may not be compliant with C++ standard,kpvdr,astitcher,Closed,Fixed,2013-07-29 13:58,C++,C++ Broker,C++ Client,,,,,,"According to the C++ standard symbols that have a single ""_"" followed by an uppercase
letter and symbols starting with ""__"" (double underscore are reserved for the implementer (That is usually the
compiler/library writer). 

There are numerous header files with guards that violate this standard in the C++ source base."
Bug,QPID-1710,12416062,Portability problem,astitcher,astitcher,Closed,Fixed,2009-03-04 4:31,C++,C++ Broker,,,,,,,"The Socket class API uses the type socklen_t which is not widely portable.

Even more so though it's used in a call where it's only ever supplied as 0 so the whole issue could be avoided by taking it out of the API"
Bug,QPID-1065,12396163,Management messages may lost if client attach hits a small time window,,tross,Closed,Fixed,2008-05-16 1:56,C++,C++ Broker,,,,,,,"There is a window of time where a management console attaching to the broker can miss configuration messages.
"
Bug,QPID-977,12394914,Federation tests raise exceptions after successful completion,gsim,tross,Closed,Fixed,2008-04-29 21:05,C++,C++ Broker,,,,,,,Federation tests intermittently raise exceptions after completing successfully.
Bug,QPID-6148,12747719, purging TTL expired messages via purge task should not increase acquires counters ,pmoravec,pmoravec,Closed,Fixed,2014-10-24 12:21,C++,C++ Broker,,,,,,,"Description of problem:
When purging messages via purge task (that runs every 10 minutes), for every purged message this way, ""acquires"" counter per queue and per broker is increased.

That does not make much sense, as technically the message is not acquired. Moreover purging the same message in the second way (removing it when finding what message to send/acquire to some consumer) does not increase the counter.


How reproducible:
100%


Steps to Reproduce:
# echo ""queue-purge-interval=10"" >> /etc/qpid/qpidd.conf
# service qpidd restart
# qpid-send -a ""q; {create:always}"" -m1000 --ttl=1000
# sleep 10
# qpid-stat -q q | egrep '(acquires|ttl-expired)'; qpid-stat -g | egrep '(acquires|ttl-expired)'


Actual results:
  acquires                    1000        
  discards-ttl-expired        1000        
  acquires                    1008        
  discards-ttl-expired        1000        

(the 2nd acquires - brokerwide - should be >1000 due to the qpid-tool acquiring some messages)

Expected results:
  acquires                    0        
  discards-ttl-expired        1000        
  acquires                    8        
  discards-ttl-expired        1000        

(the 2nd acquires - brokerwide - shoudl be >0 due to qpid-tool acquiring some messages, but surely <1000)
"
Bug,QPID-6147,12747708," [C++ broker linearstore] missing journal id in ""trace Mgmt create journal."" log",pmoravec,pmoravec,Closed,Fixed,2014-10-13 12:25,C++,C++ Broker,,,,,,,"Description of problem:
When creating a journal in linearstore, broker logs:

2014-10-13 10:35:32 [Model] trace Mgmt create journal. id:

without the queue name as expected id.

The journal name / id in the relevant QMF object is set properly later on (see qpid-tool -> list journal), it is just missing in the trace log.


How reproducible:
100%


Steps to Reproduce:
1. qpidd --log-enable=trace+:qmf::org::apache::qpid::linearstore::Journal::Journal

2. (in 2nd terminal) qpid-config add queue Durable --durable

3. (in 1st terminal): check output; restart broker & check output


Actual results:
2014-10-13 12:55:28 [Model] trace Mgmt create journal. id:

(without ""Durable"" as the id)
(both when created via qpid-config and after restart)


Expected results:
2014-10-13 12:55:28 [Model] trace Mgmt create journal. id:Durable

(both when created via qpid-config and after restart)


Additional info:"
Bug,QPID-6112,12743216,"[C++ broker] Incoming QMF objects dont update ""transfers"" counter",pmoravec,pmoravec,Closed,Fixed,2014-09-22 15:31,C++,C++ Broker,,,,,,,"QMF Incoming objects (for AMQP 1.0 incoming links) don't update ""transfers"" counter any time, regardless of number of messages delivered or settled via the relevant link.


Version-Release number of selected component (if applicable):
any (checked today's upstream)


How reproducible:
100%


Steps to Reproduce:
1. run qpidd with traces on
2. qpid-send -a ""myQueue; {create:always}"" -m 1000 --connection-option ""{protocol:amqp1.0}"" --capacity=10
3. grep incoming: <logfile> | grep transfers:


Actual results:
transfers:0


Expected results:
transfers:1000
"
Bug,QPID-5839,12723331,[C++ broker] Broker does not set lifetime-policy in AMQP1.0 attach performative,pmoravec,pmoravec,Closed,Fixed,2014-06-24 10:42,C++,C++ Broker,,,,,,,"When an AMQP 1.0 client wants to create a node with a lifetime-policy, it sends it in attach performative, within dynamic-node-properties. But the broker does not set the policy in its attach it sends back (while the node is created with proper performative).

This confuses the client and e.g. an assert might fail:

drain --connection-options ""{protocol:'amqp1.0'}"" ""q; {create:always, assert:always, node:{ properties:{'lifetime-policy':'delete-on-close'}}}""
Error: Requested node properties not met: {lifetime-policy:delete-on-close}
"
Bug,QPID-5486,12689245,Creating paged queue can overwrite existing qpidd files,pmoravec,pmoravec,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,,,,,,,"Description of problem:
When creating paged queue, there is no check whether the file /var/lib/qpidd/<queue_name> exists or not. Hence it is possible to rewrite files like ""lock"" or ""systemId"" there.

(Severity of the bug depends on importance of these files for the broker, that apparently is fine to be started with the files overwritten)

Note that creating a file named e.g. ""rhm"" (that is directory in /var/lib/qpidd) is disallowed even now.


Version-Release number of selected component (if applicable):
0.27 (current upstream)


How reproducible:
100%


Steps to Reproduce:
qpid-send -a ""lock; {create:always, delete:always, node: { x-declare: {arguments: {'qpid.paging':'True' }}}}""
echo $?
qpid-send -a ""systemId; {create:always, delete:always, node: { x-declare: {arguments: {'qpid.paging':'True' }}}}""
echo $?

Actual results:
0
0


Expected results:
Both should return an error like:
qpid-send: framing-error: Attempting to re-write file /home/pmoravec/.qpidd/systemId for paged queue ""systemId"" (/home/pmoravec/qpid-trunk/qpid/cpp/src/qpid/sys/posix/MemoryMappedFile.cpp:68)"
Bug,QPID-5015,12659607,QueueFlowLimit tests occassionally fail,kgiusti,kgiusti,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,,,,,,,"Occasionally I get failures when running the QueueFlowLimit tests on my 32 bit RHEL5 VM.

These tests use a very short timeout - 10 seconds - and on my VM I notice that I'm usually within a second or two of timing out when the test passes.

I'm going to increase the timeouts (will not increase the testing time on success, only failure).


> queue_flow_limit_tests.QueueFlowLimitTests.test_default_flow_count ......
> pass
> queue_flow_limit_tests.QueueFlowLimitTests.test_default_flow_size .......
> fail
> Error during test:  Traceback (most recent call last):
>     File
>     ""<http://mrg23.lab.bos.redhat.com:8080/job/qpid-cpp-trunk-autotools/label=rhel5-32-virt/ws/qpid/cpp/cpp-vpath/src/tests/python/commands/qpid-python-test"",>
>     line 340, in run
>       phase()
>     File
>     ""<http://mrg23.lab.bos.redhat.com:8080/job/qpid-cpp-trunk-autotools/label=rhel5-32-virt/ws/qpid/cpp/src/tests/queue_flow_limit_tests.py"",>
>     line 328, in test_default_flow_size
>       self.verify_limit(TestQ(oid))
>     File
>     ""<http://mrg23.lab.bos.redhat.com:8080/job/qpid-cpp-trunk-autotools/label=rhel5-32-virt/ws/qpid/cpp/src/tests/queue_flow_limit_tests.py"",>
>     line 262, in verify_limit
>       self.failUnless(testq.verifyStopped())
>     File ""/usr/lib/python2.4/unittest.py"", line 309, in failUnless
>       if not expr: raise self.failureException, msg
>   AssertionError
> queue_flow_limit_tests.QueueFlowLimitTests.test_flow_count ..............
> pass"
Bug,QPID-5532,12692656,[C++ broker] Add debug log when timeouting DTX transaction,pmoravec,pmoravec,Closed,Fixed,2014-02-01 12:03,C++,C++ Broker,,,,,,,"Any timeout-ed DTX transaction shall be logged. Especially once QPID-5531 is implemented, as then every DTX will have some default timeout."
Bug,QPID-5530,12692499,"[legacystore] store_chk raises ""Operation on non-existent record: operation=unlock; rid=.."" on aborted DTX transaction in TplStore ",pmoravec,pmoravec,Closed,Fixed,2014-02-01 10:20,C++,C++ Broker,,,,,,,"Description of problem:
Having an aborted DTX transaction in TplStore, store_chk raises ""Operation on non-existent record: operation=unlock; rid=.."" error.


Version-Release number of selected component (if applicable):
any (incl. qpid 0.26)


How reproducible:
100%


Steps to Reproduce:
1. Prepare and abort a DTX transaction (e.g. by replacing ""dtxCommit"" by ""dtxRollback"" in qpid-txtest.cpp, recompiling it and running it with --dtx=1 argument)
2. /usr/libexec/qpid/store_chk /var/lib/qpidd/rhm/tpl -b tpl


Actual results:
Recovering journals .
Operation on non-existent record: operation=unlock; rid=0x2311c


Expected results:
Journals recovered properly.


Additional info:"
Bug,QPID-2179,12439527,example qmf-agent occasionally crashes on shutdown,tross,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"The example qmf agent (cpp/examples/qmf-agent) incorrectly does all of its cleanup processing during a signal handler.  This is not thread safe.   Will result in occasional crash on shutdown.

Will post patch shortly.

-K
"
Bug,QPID-3648,12533004,"On shutdown, broker can crash if v1 QMF agents are currently attached.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,"Incorrect cleanup of remote agent objects may lead to a crash when the broker is shut down.

#0  0x006b0b6c in memcpy () from /lib/libc.so.6
#1  0x00423d04 in std::basic_string<char, std::char_traits<char>,
std::allocator<char> >::_Rep::_M_clone(std::allocator<char> const&, unsigned
int) () from /usr/lib/libstdc++.so.6
#2  0x00424667 in std::basic_string<char, std::char_traits<char>,
std::allocator<char> >::basic_string(std::basic_string<char,
std::char_traits<char>, std::allocator<char> > const&) ()
   from /usr/lib/libstdc++.so.6
#3  0x0565ce5f in ObjectId (this=0x9807498, __in_chrg=<value optimized out>)
    at ../include/qpid/management/ManagementObject.h:51
#4  getObjectId (this=0x9807498, __in_chrg=<value optimized out>)
    at ../include/qpid/management/ManagementObject.h:199
#5  qpid::management::ManagementAgent::RemoteAgent::~RemoteAgent
(this=0x9807498, 
    __in_chrg=<value optimized out>) at qpid/management/ManagementAgent.cpp:113
#6  0x056644e8 in
checked_delete<qpid::management::ManagementAgent::RemoteAgent> (
    this=0x9806320) at /usr/include/boost/checked_delete.hpp:34
#7 
boost::detail::sp_counted_impl_p<qpid::management::ManagementAgent::RemoteAgent>::dispose
(
    this=0x9806320) at /usr/include/boost/detail/sp_counted_impl.hpp:76
#8  0x05664a18 in ~shared_count (this=0x98075c8, __in_chrg=<value optimized
out>)
    at /usr/include/boost/detail/sp_counted_base_gcc_x86.hpp:145
#9  ~shared_ptr (this=0x98075c8, __in_chrg=<value optimized out>)
    at /usr/include/boost/shared_ptr.hpp:106
#10 std::pair<qpid::management::ObjectId const,
boost::shared_ptr<qpid::management::ManagementAgent::RemoteAgent> >::~pair
(this=0x98075c8, __in_chrg=<value optimized out>)
    at /usr/include/c++/4.1.2/bits/stl_pair.h:69
#11 0x05656ed4 in _M_erase (this=0xb7542008, __in_chrg=<value optimized out>)
    at /usr/include/c++/4.1.2/ext/new_allocator.h:107
#12 ~_Rb_tree (this=0xb7542008, __in_chrg=<value optimized out>)
    at /usr/include/c++/4.1.2/bits/stl_tree.h:578
#13 ~map (this=0xb7542008, __in_chrg=<value optimized out>)
    at /usr/include/c++/4.1.2/bits/stl_map.h:93
---Type <return> to continue, or q <return> to quit---
#14 qpid::management::ManagementAgent::~ManagementAgent (this=0xb7542008, 
    __in_chrg=<value optimized out>) at qpid/management/ManagementAgent.cpp:158
#15 0x05512552 in ~auto_ptr (this=0x970b708, __in_chrg=<value optimized out>)
    at /usr/include/c++/4.1.2/memory:259
#16 qpid::broker::Broker::~Broker (this=0x970b708, __in_chrg=<value optimized
out>)
    at qpid/broker/Broker.cpp:405
#17 0x0550b505 in qpid::RefCounted::released (this=0xa3b7e008) at
qpid/RefCounted.h:48
#18 0x05540630 in qpid::broker::Daemon::fork (this=0xbf8a5498) at
qpid/broker/Daemon.cpp:91
#19 0x0804e12d in QpiddBroker::execute (this=0xbf8a5725, options=0x9704520)
    at posix/QpiddBroker.cpp:179
#20 0x0804c811 in main (argc=4, argv=0xbf8a57d4) at qpidd.cpp:80
(gdb"
Bug,QPID-3711,12536360,run_federation_test test script does not actually run any of the federation.py tests,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,,,,,,,incorrect variable expansion causes the python-test pattern matcher to skip all the tests.
Bug,QPID-1069,12396267,Patch to build trunk with Boost 1.35,astitcher,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"Trunk C++ code fails to build with Boost 1.35 - there's a missing Boost feature prior to 1.35 that is now available. This patch allows C++ trunk code to build with Boost 1.35.
Index: Blob.h
===================================================================
--- Blob.h      (revision 657445)
+++ Blob.h      (working copy)
@@ -27,6 +27,7 @@
 #include <boost/utility/typed_in_place_factory.hpp>
 #include <boost/type_traits/is_base_and_derived.hpp>
 #include <boost/utility/enable_if.hpp>
+#include <boost/version.hpp>

 #include <new>

@@ -39,7 +40,8 @@
 using boost::in_place;
 using boost::typed_in_place_factory_base;

-/** 0-arg typed_in_place_factory, missing in boost. */
+/** 0-arg typed_in_place_factory, missing in pre-1.35 boost. */
+#if (BOOST_VERSION < 103500)
 template <class T>
 struct typed_in_place_factory0 : public typed_in_place_factory_base {
     typedef T value_type ;
@@ -49,6 +51,7 @@
 /** 0-arg in_place<T>() function, missing from boost. */
 template<class T>
 typed_in_place_factory0<T> in_place() { return typed_in_place_factory0<T>(); }
+#endif

 template <class T, class R=void>
 struct EnableInPlace
"
Bug,QPID-3630,12531812,"Remove the ""max-session-rate"" feature in the C++ Broker.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,Feature has be deprecated as of 0.14 release.  Remove for 0.16.
Bug,QPID-3482,12522887,Unable to switch off logging to syslog when qpidd runs as daemon ,aconway,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"When qpidd runs as daemon, it is impossible to switch off its logging to syslog:

qpidd --log-to-syslog no --log-to-file /tmp/qpidd.txt -d

causes logs go to syslog, while:

qpidd --log-to-syslog no --log-to-file /tmp/qpidd.txt

doesn't log to syslog.


I think the issue is caused by -d flag overriding log-to-syslog option:

Daemon options:
  -d [ --daemon ]               Run as a daemon. Logs to syslog by default in 
                                this mode.
"
Bug,QPID-1147,12398975,Avoid usage of 'source' builtin in pure sh scripts,gsim,mteira,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The builtin source is not valid in an pure bourne shell script. It can be considered a bashism.
I'm adding a trivial patch to replace it with a dot script inclusion."
Bug,QPID-1740,12417030,ECHO variable is undocumented,,jasan,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"In newer version of Libtool, ECHO variable is not set in
generated Makefiles, merely the lt_ECHO is. The ECHO
variable has never been documented nor meant to be used that
way without having independent M4 echo test in-code.

Available solutions:

  1. Start generating snapshots that will
     contain ""./configure"" & friends pre-generated
     by your preferred version of GNU Autotools
     which includes the undocumented ECHO variable
     in generated Makefiles.

  2. Start using CMake after 0.5 release.

  3. Apply the patch in attachment to make the
     code ready for latest versions of Autotools.


AFAIK code rebase to CMake is on its way, but IMHO the
change of build system does not prevent us from making
errors so please read the docs.
"
Bug,QPID-1741,12417032,Boost Test API Change,,jasan,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Since the BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES is documented
(that is in version 1.36), it should be called a bit differently than before.

See http://www.boost.org/doc/libs/1_36_0/libs/test/doc/html/utf/user-guide/test-organization/expected-failures.html
for more info."
Bug,QPID-3615,12531360,"Deprecate the ""max-session-rate"" feature in the C++ Broker.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"The max-session-rate feature was introduced to provide a means for back pressuring message producers on a per-session basis.  As of 0.12, queue-capacity based producer flow control has been made available.  The old max-session-rate feature should be removed, and the newer method for flow control should be used.

As this is a user-visible configuration feature, it would be nice to log a warning indicating this feature will be removed in an upcoming release."
Bug,QPID-3528,12526033,qpid --help has wrong description of sasl-config parameter,mgoulish2,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem:
qpidd --help shows sasl-config option to specify filename of SASL config file.
That is wrong as it specifies _directory_ (like /etc/sasl2) where qpidd.conf
for SASL lies.
man pages of qpid are correct:
       --sasl-config DIR
              gets sasl config info from nonstandard location

Just qpidd --help is wrong.


Version-Release number of selected component (if applicable):
any (MRG 2.0 checked)


How reproducible:
100%


Steps to Reproduce:
1. qpidd --help | grep -A1 sasl


Actual results:
# qpidd --help | grep -A1 sasl
  --sasl-config FILE                                  gets sasl config from 
                                                      nonstandard location
#


Expected results:
# qpidd --help | grep -A1 sasl
  --sasl-config DIR (/etc/sasl2)                     gets sasl config from 
                                                     nonstandard directory
#


Additional info:
Patch attached."
Bug,QPID-3500,12524273,qpidd --help should ignore other parameters (incl. config file),chug,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Steps to Reproduce:
1. Add ""log-to-file=/tmp/qpidd.log"" to /etc/qpidd.conf
2. Login as root user, touch /tmp/qpidd.log && chmod 600 /tmp/qpidd.log
3. su to a non-root user, run ""/usr/sbin/qpidd --help""

Further similar reproductions:
qpidd --help --config not_readable_file
qpidd --help --log-file not_readable_file   (where /etc/qpidd.conf does not
contain log-file option)
qpidd --help  (when config file is not readable)
qpidd --help  (when config file contains log-file to non-readable file)

Plus all the above for --version option (instead of --help).


Patch for all the above (except one questionable case) will be uploaded."
Bug,QPID-3974,12552535,replication exchange msgDrop and byteDrop to increase when duplicate messages detected,gsim,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,,,,,,,"Description of problem:
When replication exchange detects duplicated messages, it 1) discards them, and
2) as for any other message, it increases msgIn and byteIn counters. But
msgDrop and byteDrop counters are not updated, though the messages were
discarded.


Version-Release number of selected component (if applicable):
any (incl. 0.14)


How reproducible:
100%


Steps to Reproduce:
1. Setup queue state replication, like
https://cwiki.apache.org/qpid/queue-state-replication.html. 
2. Produce 5 messages to the queue-a on the source broker.
3. Restart source broker.
4. Produce another 3 messages to the queue-a on the source broker.


Actual results:
Destination broker (replication exchange in particular) drops the messages
(though these are not duplicates of previously sent - new BZ to be open for
that). Replication exchange increases msgIn and byteIn counters but does not
increase msgDrop and byteDrop counters.


Expected results:
msgDrop and byteDrop counters are also increased.


Additional info:
Patch to be proposed."
Bug,QPID-8495,13349043,Cannot build Qpid C++ 1.39,,fayce66,Resolved,Fixed,2021-01-11 15:50,C++,C++ Build,,,,,,,"I am trying to build qpid 1.39.0 on Linux Mint 20 with gcc 9.3.0 and boost 1.75. The build fails with the following error:

faycal@fek-alienware:~/Projects/qpid-cpp-1.39.0/build$ make
/usr/lib/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: 'install_requires'
 warnings.warn(msg)
running build
running build_py
running build_scripts
[ 0%] Built target management_python_build
[ 0%] Building CXX object src/CMakeFiles/qpidtypes.dir/qpid/types/Exception.cpp.o
[ 0%] Building CXX object src/CMakeFiles/qpidtypes.dir/qpid/types/Uuid.cpp.o
[ 0%] Building CXX object src/CMakeFiles/qpidtypes.dir/qpid/types/Variant.cpp.o
[ 0%] Linking CXX shared library libqpidtypes.so
[ 0%] Built target qpidtypes
[ 1%] Building CXX object src/CMakeFiles/qpidcommon.dir/qpid/framing/MethodBodyDefaultVisitor.cpp.o
In file included from /home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/AMQMethodBody.h:26,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/ConnectionStartBody.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/all_method_bodies.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/MethodBodyDefaultVisitor.cpp:29:
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/ProtocolVersion.h: In member function ?쁞ool qpid::framing::ProtocolVersion::operator!=(qpid::framing::ProtocolVersion) const??
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/ProtocolVersion.h:56:93: *{color:#FF0000}error{color}*: *implicitly-declared ?쁟onstexpr qpid::framing::ProtocolVersion::ProtocolVersion(const qpid::framing::ProtocolVersion&)??is deprecated [-Werror=deprecated-copy]*
 *56 | QPID_COMMON_INLINE_EXTERN bool operator!=(ProtocolVersion p) const \{ return ! (*this == p); }*
 *| ^*
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/ProtocolVersion.h:53:41: note: because ?쁰pid::framing::ProtocolVersion??has user-provided ?쁰pid::framing::ProtocolVersion& qpid::framing::ProtocolVersion::operator=(qpid::framing::ProtocolVersion)??
 53 | QPID_COMMON_EXTERN ProtocolVersion& operator=(ProtocolVersion p);
 | ^~~~~~~~
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/ProtocolVersion.h:55:56: note: initializing argument 1 of ?쁞ool qpid::framing::ProtocolVersion::operator==(qpid::framing::ProtocolVersion) const??
 55 | QPID_COMMON_EXTERN bool operator==(ProtocolVersion p) const;
 | ~~~~~~~~~~~~~~~~^
In file included from /usr/local/include/boost/smart_ptr/detail/sp_thread_sleep.hpp:22,
 from /usr/local/include/boost/smart_ptr/detail/yield_k.hpp:23,
 from /usr/local/include/boost/smart_ptr/detail/spinlock_gcc_atomic.hpp:14,
 from /usr/local/include/boost/smart_ptr/detail/spinlock.hpp:42,
 from /usr/local/include/boost/smart_ptr/detail/spinlock_pool.hpp:25,
 from /usr/local/include/boost/smart_ptr/shared_ptr.hpp:29,
 from /usr/local/include/boost/shared_ptr.hpp:17,
 from /home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/AMQMethodBody.h:29,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/ConnectionStartBody.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/all_method_bodies.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/MethodBodyDefaultVisitor.cpp:29:
/usr/local/include/boost/bind.hpp: At global scope:
/usr/local/include/boost/bind.hpp:36:1: note: #pragma message: The practice of declaring the Bind placeholders (_1, _2, ...) in the global namespace is deprecated. Please use <boost/bind/bind.hpp> + using namespace boost::placeholders, or define BOOST_BIND_GLOBAL_PLACEHOLDERS to retain the current behavior.
 36 | BOOST_PRAGMA_MESSAGE(
 | ^~~~~~~~~~~~~~~~~~~~
In file included from /home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/RangeSet.h:25,
 from /home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/SequenceSet.h:25,
 from /home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/framing/amqp_types_full.h:35,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/../include/qpid/framing/Header.h:32,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/../include/qpid/framing/amqp_structs.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/AMQP_ServerOperations.h:32,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/ConnectionStartBody.h:31,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/all_method_bodies.h:30,
 from /home/faycal/Projects/qpid-cpp-1.39.0/build/src/qpid/framing/MethodBodyDefaultVisitor.cpp:29:
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/InlineVector.h: In instantiation of ?쁰pid::InlineVector<T, Max, Alloc>::InlineVector(const qpid::InlineVector<T, Max, Alloc>&) [with T = qpid::Range<qpid::framing::SequenceNumber>; long unsigned int Max = 3; Alloc = std::allocator<qpid::Range<qpid::framing::SequenceNumber> >]??
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/RangeSet.h:98:7: required from here
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/InlineVector.h:62:15: {color:#FF0000}*error*{color}: *implicitly-declared ?쁰pid::InlineVector<qpid::Range<qpid::framing::SequenceNumber>, 3, std::allocator<qpid::Range<qpid::framing::SequenceNumber> > >& qpid::InlineVector<qpid::Range<qpid::framing::SequenceNumber>, 3, std::allocator<qpid::Range<qpid::framing::SequenceNumber> > >::operator=(const qpid::InlineVector<qpid::Range<qpid::framing::SequenceNumber>, 3, std::allocator<qpid::Range<qpid::framing::SequenceNumber> > >&)??is deprecated [-Werror=deprecated-copy]*
 *62 | *this = x;*
 | ~~~~~~^~~
/home/faycal/Projects/qpid-cpp-1.39.0/src/qpid/InlineVector.h:60:5: note: because ?쁰pid::InlineVector<qpid::Range<qpid::framing::SequenceNumber>, 3, std::allocator<qpid::Range<qpid::framing::SequenceNumber> > >??has user-provided ?쁰pid::InlineVector<T, Max, Alloc>::InlineVector(const qpid::InlineVector<T, Max, Alloc>&) [with T = qpid::Range<qpid::framing::SequenceNumber>; long unsigned int Max = 3; Alloc = std::allocator<qpid::Range<qpid::framing::SequenceNumber> >]??
 60 | InlineVector(const InlineVector& x) : Base() {
 | ^~~~~~~~~~~~
cc1plus: all warnings being treated as errors
make[2]: *** [src/CMakeFiles/qpidcommon.dir/build.make:63: src/CMakeFiles/qpidcommon.dir/qpid/framing/MethodBodyDefaultVisitor.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:1458: src/CMakeFiles/qpidcommon.dir/all] Error 2
make: *** [Makefile:163: all] Error 2
혻"
Bug,QPID-8347,13246640,Receive() blocks forever once timeout has been exceeded with a RabbitMQ Broker,,szegel,Closed,Fixed,2019-11-06 22:52,C++,C++ Client,,,,,,,"Hello All,

I am trying to use QPID C++ messaging API with a RabbitMQ Broker communicating over AMQP 1.0 protocol.혻When the혻receive()혻call times out, the RabbitMQ Broker throws an error and closes the session. The QPID C++ client then hangs indefinitely in the receive call. I혻believe that this is a bug in the QPID C++ API because it should always respect the client provided timeout, no mater what the Broker does.혻I also wrote a bug for RabbitMQ AMQP 1.0 plugin: [https://github.com/rabbitmq/rabbitmq-amqp1.0/issues/90]

혻

Update: After further testing, it seems like Qpid Proton handles the timeout case correctly with RabbitMQ Broker, isolating this issue to the C++ API.

helloworld_blocking.py:

from __future__ import print_function

from proton import Message

from proton.utils import BlockingConnection

from proton.handlers import IncomingMessageHandler

혻

conn = BlockingConnection(""localhost:5672"")

receiver = conn.create_receiver(""examples"")

sender = conn.create_sender(""examples"")

#sender.send(Message(body=""Hello World!""));

msg = receiver.receive(timeout=0)

print(msg.body)

receiver.accept()

conn.close()

혻

Result:

혻python helloworld_blocking.py혻

Traceback (most recent call last):

혻 File ""helloworld_blocking.py"", line 30, in <module>

혻 혻 msg = receiver.receive(timeout=0)

혻 File ""/home/user/qpid-proton-0.28.0/build/python/dist/proton/_utils.py"", line 171, in receive

혻 혻 timeout=timeout)

혻 File ""/home/user/qpid-proton-0.28.0/build/python/dist/proton/_utils.py"", line 314, in wait

혻 혻 raise Timeout(txt)

proton._exceptions.Timeout: Connection amqp://localhost:5672 timed out: Receiving on receiver 5aa78b24-27c6-4b76-a92a-d5410aa0a6ef-examples

혻

QPID C++ Example Code (Modified HelloWorld example):

#include <qpid/messaging/Connection.h>

#include <qpid/messaging/Message.h>

#include <qpid/messaging/Receiver.h>

#include <qpid/messaging/Sender.h>

#include <qpid/messaging/Session.h>

#include <iostream>

혻

using namespace qpid::messaging;

혻

int main(int argc, char** argv) {

혻 혻 std::string broker = argc > 1 ? argv[1] : ""localhost:5672"";

혻 혻 std::cout << ""broker: "" << broker << std::endl;

혻 혻 std::string address = argc > 2 ? argv[2] : ""topic.hello.world"";

혻 혻 std::cout << ""address: "" << address << std::endl;

혻 혻 std::string connectionOptions = argc > 3 ? argv[3] : """";

혻 혻 std::cout << ""connectionOptions: "" << connectionOptions << std::endl;

혻

혻 혻 try

{ 혻 혻 혻 혻 혻 혻 혻 혻 Connection connection(broker, connectionOptions); 혻 혻 혻 혻 connection.open(); 혻 혻 혻 혻 Session session = connection.createSession(); 혻 혻 혻 혻 혻Receiver receiver = session.createReceiver(address); 혻 혻 혻 혻 Message message; 혻 혻 혻 혻 std::cout << ""Pre Receive"" << std::endl; 혻 혻 혻 혻 message = receiver.fetch(Duration::SECOND * 10); 혻 혻 혻 혻 std::cout << ""Post Receive"" << std::endl; 혻 혻 혻 혻 session.acknowledge(); 혻 혻 혻 혻 혻 connection.close(); 혻 혻 혻 혻 return 0; 혻 혻 }

catch(const std::exception& error)

{ 혻 혻 혻 혻 std::cerr << error.what() << std::endl; 혻 혻 혻 혻 return 1; 혻 혻 }

}

}

혻

Server Error (Occurs after 10 second timeout):

=INFO REPORT==== 23-Jul-2019::17:49:54 ===

accepting AMQP connection <0.657.0> ([::1]:40358 -> [::1]:5672)

혻

=ERROR REPORT==== 23-Jul-2019::17:49:54 ===

closing AMQP connection <0.657.0> ([::1]:40358 -> [::1]:5672):

{bad_version,\{1,1,0,10}}

혻

=INFO REPORT==== 23-Jul-2019::17:49:54 ===

accepting AMQP connection <0.660.0> ([::1]:40360 -> [::1]:5672)

혻

=ERROR REPORT==== 23-Jul-2019::17:50:04 ===
 * 
 ** Generic server <0.675.0> terminating혻

 * 
 ** Last message in was {send_command,

혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {'basic.credit_drained',

혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <<99,116,97,103,45,0,0,0,0>>,

혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 1}}
 * 
 ** When Server state == {state,1,<0.669.0>,<0.674.0>,direct,

혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻

{[],[]},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 false,<0.678.0>,none,none,0,true,none,
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{0,nil},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{0,nil},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 true,false}
 
 ** Reason for termination ==혻
 
 ** \{{badmatch,{empty,{[],[]}

}},

혻 혻 [

{amqp_channel,rpc_bottom_half,2, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 [

{file,""src/amqp_channel.erl""},\{line,623}]},
 
 혻혻 혻 \{amqp_channel,handle_method_from_server1,3, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file,""src/amqp_channel.erl""}

,

{line,800}

]},

혻혻 혻 {gen_server,try_dispatch,4,

{line,616}

]},

혻혻 혻 {gen_server,handle_msg,6,[

{file,""gen_server.erl""},//\{line,686}"" class=""external-link"" rel=""nofollow"">\\\\\\\{file,""gen_server.erl""}

,\{line,616}]},

혻혻 혻

{gen_server,handle_msg,6,[ \\{file,""gen_server.erl""}
 
 ,\\\\\\\{line,686}},
 
 혻혻 혻 {proc_lib,init_p_do_apply,3,[\\\\
 \{file,""proc_lib.erl""},\\\\\\\{line,247}|file://\{file,/]}]}
 
 혻
 
 =WARNING REPORT==== 23-Jul-2019::17:50:04 ===
 
 Connection (<0.669.0>) closing: internal error in channel (<0.675.0>): {{badmatch,
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{empty, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[], 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 []}}},
 
 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [\{amqp_channel, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 rpc_bottom_half, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 2, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 ""src/amqp_channel.erl""},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{line, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 623}]},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{amqp_channel, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 handle_method_from_server1, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 3, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 ""src/amqp_channel.erl""},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{line, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 800}]},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{gen_server, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 try_dispatch, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 4, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 ""gen_server.erl""},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{line, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 616}]},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{gen_server, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 handle_msg, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 6, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 ""gen_server.erl""},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{line, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 686}]},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{proc_lib, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 init_p_do_apply, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 3, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 ""proc_lib.erl""},
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{line, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 247}]}]}
 
 혻
 
 =ERROR REPORT==== 23-Jul-2019::17:50:04 ===
 
 ** Generic server <0.678.0> terminating
 
 ** Last message in was {'EXIT',<0.675.0>,
 
 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{{badmatch,{empty,{[],[]}}},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{amqp_channel,rpc_bottom_half,2, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [ {file,""src/amqp_channel.erl""},\\\\\\\\{line,623}]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {amqp_channel,handle_method_from_server1,3, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{file,""src/amqp_channel.erl""},\{line,800}
 
 ]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {gen_server,try_dispatch,4, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [ \{file,""gen_server.erl""}
 
 , \{line,616}]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {gen_server,handle_msg,6, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [ \{file,""gen_server.erl""}
 
 ,
 \{line,686}
 
 ]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {proc_lib,init_p_do_apply,3, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [ \{file,""proc_lib.erl""}
 
 ,
 \{line,247}
 
 ]}]}}}}
 
 {{ ** When Server state ==
 
 \{ch,running,rabbit_framing_amqp_0_9_1,1,<0.675.0>, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <0.675.0>,<0.669.0>,<<""[::1]:40360 -> [::1]:5672"">>, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 \{lstate,<0.677.0>,false}
 
 ,}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 none,1,}}
 
 {{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻
 \{[],[]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {user,<<""guest"">>, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [administrator], 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [\\\{rabbit_auth_backend_internal,none}|file://\{rabbit_auth_backend_internal,none}/]},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <<""/"">>,<<>>,}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {dict,1,16,16,8,80,48, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{[],[],[],[],[],[],[],[],[],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [[<0.583.0>|}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {resource,<<""/"">>,queue, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <<""topic.hello.world"">>}]],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],[],[],[],[],[]}}},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {state,}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {dict,1,16,16,8,80,48, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},}}
 
 {{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{[],[],[],[],[],[],[],[],[],}}
 
 {{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [[<0.583.0>|#Ref<0.4039704202.3895984130.68325>]],}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],[],[],[],[],[]}}},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 erlang},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {dict,1,16,16,8,80,48, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{[],[],[],[],[],[],[],[],[],[],[],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [[<<99,116,97,103,45,0,0,0,0>>|}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{amqqueue,}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {resource,<<""/"">>,queue, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <<""topic.hello.world"">>},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 false,false,none,[],<0.583.0>,[],[],[],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 undefined,[],[],live,0},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {false,65535,false, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{<<""x-credit"">>,table, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{<<""credit"">>,long,0},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""drain"">>,boolean,false}]}]}}]],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],[],[],[]}}},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {dict,1,16,16,8,80,48, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{[],[],[],[],[],[],[],[],[],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [[<0.583.0>|}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {1,{<<99,116,97,103,45,0,0,0,0>>,nil,nil}}]],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],[],[],[],[],[]}}},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {set,1,16,16,8,80,48, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{[],[],[],[],[],[],[],[],[],}}
 
 {{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [<0.583.0>],}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],[],[],[],[],[]}}},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 <0.672.0>,}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {state,fine,5000, 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 #Ref<0.4039704202.3895984129.147347>},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 false,1,}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 }}{{0,nil},{0,nil}}{{,}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [],}}
 
 {{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {{0,nil},{0,nil}},}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 [{<<""publisher_confirms"">>,bool,true},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""exchange_exchange_bindings"">>,bool,true},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""basic.nack"">>,bool,true},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""consumer_cancel_notify"">>,bool,true},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""connection.blocked"">>,bool,true},}}
 
 \{{ 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 {<<""authentication_failure_close"">>,bool,true}],}}
 
 \{{ 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 혻 none,65535,none,flow,[]}}}
 
 \{{ ** Reason for termination ==혻}}
 
 \{{ ** {{badmatch,{empty,{[],[]}
 
 }},
 
 혻 혻 [\{amqp_channel,rpc_bottom_half,2, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 [ {file,""src/amqp_channel.erl""}
 
 ,\{line,623}]},
 
 혻혻 혻
 
 \{amqp_channel,handle_method_from_server1,3, 혻혻 혻 혻 혻 혻 혻 혻 혻 혻 [ {file,""src/amqp_channel.erl""}
 
 ,\{line,800}]},
 
 혻혻 혻
 
 \{gen_server,try_dispatch,4,[ {file,""gen_server.erl""}
 
 ,\{line,616}]},
 
 혻혻 혻
 
 \{gen_server,handle_msg,6,[ {file,""gen_server.erl""}

,\{line,686}]},

혻혻 혻

{proc_lib,init_p_do_apply,3,[ \\{file,""proc_lib.erl""}

,\{line,247}]}]}

혻

혻

gdb backtrace:

(gdb) r

Starting program: /mnt/user/dev/rabbit_mq_test/hello_world혻

[Thread debugging using libthread_db enabled]

Using host libthread_db library ""/lib/x86_64-linux-gnu/libthread_db.so.1"".

broker: localhost:5672

address: topic.hello.world

connectionOptions:혻

[New Thread 0x7ffff3d53700 (LWP 26650)]

[New Thread 0x7ffff3340700 (LWP 26651)]

[New Thread 0x7ffff2b3f700 (LWP 26652)]

Pre Receive

^C

Thread 1 ""hello_world"" received signal SIGINT, Interrupt.

0x00007ffff610f9f3 in futex_wait_cancelable (private=<optimized out>, expected=0, futex_word=0x555555785d04) at ../sysdeps/unix/sysv/linux/futex-internal.h:88

88 ../sysdeps/unix/sysv/linux/futex-internal.h: No such file or directory.

(gdb) bt

#0혻 0x00007ffff610f9f3 in futex_wait_cancelable (private=<optimized out>, expected=0, futex_word=0x555555785d04) at ../sysdeps/unix/sysv/linux/futex-internal.h:88

#1혻 __pthread_cond_wait_common (abstime=0x0, mutex=0x555555785cb0, cond=0x555555785cd8) at pthread_cond_wait.c:502

#2혻 __pthread_cond_wait (cond=0x555555785cd8, mutex=0x555555785cb0) at pthread_cond_wait.c:655

#3혻 0x00007ffff7ad70b1 in qpid::sys::Condition::wait (this=0x555555785cd8, mutex=...) at /home/user/qpid-cpp-1.39.0/src/qpid/sys/posix/Condition.h:59

#4혻 0x00007ffff7ad7333 in qpid::sys::Monitor::wait (this=0x555555785cb0) at /home/user/qpid-cpp-1.39.0/src/qpid/sys/Monitor.h:41

#5혻 0x00007ffff7acd008 in qpid::messaging::amqp::ConnectionContext::wait (this=0x5555557858e0) at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/amqp/ConnectionContext.cpp:706

#6혻 0x00007ffff7acd11a in qpid::messaging::amqp::ConnectionContext::wait (this=0x5555557858e0, ssn=..., lnk=...) at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/amqp/ConnectionContext.cpp:721

#7혻 0x00007ffff7ac8a5a in qpid::messaging::amqp::ConnectionContext::fetch (this=0x5555557858e0, ssn=..., lnk=..., message=..., timeout=...)

혻 혻 at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/amqp/ConnectionContext.cpp:271

#8혻 0x00007ffff7ae7b61 in qpid::messaging::amqp::ReceiverHandle::fetch (this=0x55555579b200, message=..., timeout=...) at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/amqp/ReceiverHandle.cpp:55

#9혻 0x00007ffff7ae7c30 in qpid::messaging::amqp::ReceiverHandle::fetch (this=0x55555579b200, timeout=...) at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/amqp/ReceiverHandle.cpp:61

#10 0x00007ffff7b575e4 in qpid::messaging::Receiver::fetch (this=0x7fffffffe780, timeout=...) at /home/user/qpid-cpp-1.39.0/src/qpid/messaging/Receiver.cpp:52

#11 0x000055555555589c in main ()

(gdb)혻

혻"
Bug,QPID-2236,12442466,cmake build fails to build cluster module.,aconway,aconway,Closed,Fixed,2017-03-14 20:08,C++,C++ Build,,,,,,,"On 12/02/2009 07:53 PM, Andrew Stitcher wrote:

> Cmake build is mostly fine - however the clustering module doesn't build
> due to a complication of recent versions of boost. And r886259 breaks
> building the clustering tests (due to missing the new
> tests/cluster.cmake from EXTRA_DIST)
"
Bug,QPID-6858,12913319,Port all python swig input files to support python 3 and 2,gsim,kgiusti,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,Python Client (Wrapped),,,,,,"Python3 cannot link against code from the swig python templates:

qpid/cpp/include/qpid/swig_python_typemaps.i

These templates reference python C interfaces that have been removed in python3.   It should be possible to port the *.i files to python3 while preserving python2 support."
Bug,QPID-4879,12648960,"Merged patch removed endif(), breaking CMake build on 0.22",mcpierce,mcpierce,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,QPID-4344 patches were applied out of order and caused a conditional to be added to the bindings Cmake file. This didn't show up until the last patch pulled in removed the end() directive for it.
Bug,QPID-1467,12408677,C++ M4 Alpha doesn't contain Windows pieces,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"The current M4 alpha release doesn't contain pieces needed to build on Windows. This is because:

- The release script uses the ""make dist"" to produce the release artifacts.
- The Windows-only files are not listed in the Makefile.am

If the Windows C++ code is to be included in the C++ kit, something needs to be done. I assume that the Windows pieces are desired in the C++ kit along with the Linux, Solaris, etc. stuff. If so, one possible approach is to add the Windows-specific files to the Makefile.am EXTRA_DIST files list. I can do this but would like feedback from the community on whether one Linux/Solaris/Windows C++ kit is desired.
"
Bug,QPID-4856,12648036,make distcheck fails on qpid.pm file,mcpierce,mcpierce,Closed,Fixed,2016-09-06 20:26,C++,C++ Build,,,,,,,"In the Makefile.am file for qpid/cpp/bindings/qpid, the reference is to perl/qpid.pm. However, the file is actually in perl/lib/qpid.pm, so the reference needs to be updated."
Bug,QPID-6415,12777661,Core dump in ha_tests and interlink_tests with proton 0.9,aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"The qpid-send and qpid-receive clients dump core in 
    ha_tests.LongTests.test_failover_send_receive
The python test driver process dumps core in interlink_tests

In both cases there is a double free during connection clean-up as part of a reconnect. It is not clear if this is a bug in the c++ qpid messaging client or in proton.

{noformat}
==20092== Invalid read of size 8
==20092==    at 0x5ABACF5: pn_connection_unbound (engine.c:167)
==20092==    by 0x5ABE1CB: pn_transport_unbind (transport.c:636)
==20092==    by 0x5ABE247: pn_transport_finalize (transport.c:519)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x5ABA204: pn_connection_finalize (engine.c:463)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x4C5A8C6: qpid::messaging::amqp::ConnectionContext::reset() (ConnectionContext.cpp:547)
==20092==    by 0x4C5AD4C: qpid::messaging::amqp::ConnectionContext::checkDisconnected() (ConnectionContext.cpp:572)
==20092==    by 0x4C5A99D: qpid::messaging::amqp::ConnectionContext::check() (ConnectionContext.cpp:559)
==20092==    by 0x4C5AF4B: qpid::messaging::amqp::ConnectionContext::wait() (ConnectionContext.cpp:593)
==20092==    by 0x4C5B0C2: qpid::messaging::amqp::ConnectionContext::wait(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::SenderContext>) (ConnectionContext.cpp:612)
==20092==    by 0x4C59DAD: qpid::messaging::amqp::ConnectionContext::send(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::SenderContext>, qpid::messaging::Message const&, bool) (ConnectionContext.cpp:462)
==20092==    by 0x4C79D80: qpid::messaging::amqp::SenderHandle::send(qpid::messaging::Message const&, bool) (SenderHandle.cpp:42)
==20092==    by 0x4CD4399: qpid::messaging::Sender::send(qpid::messaging::Message const&, bool) (Sender.cpp:40)
==20092==    by 0x40E45B: main (qpid-send.cpp:413)
==20092==  Address 0x5fee1b0 is 192 bytes inside a block of size 272 free'd
==20092==    at 0x4A07577: free (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==20092==    by 0x5AAF545: pn_class_decref (object.c:103)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x5ABACF4: pn_connection_unbound (engine.c:168)
==20092==    by 0x5ABE1CB: pn_transport_unbind (transport.c:636)
==20092==    by 0x5ABE247: pn_transport_finalize (transport.c:519)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x5ABA204: pn_connection_finalize (engine.c:463)
==20092==    by 0x5AAF527: pn_class_decref (object.c:97)
==20092==    by 0x4C5A8C6: qpid::messaging::amqp::ConnectionContext::reset() (ConnectionContext.cpp:547)
==20092==    by 0x4C5AD4C: qpid::messaging::amqp::ConnectionContext::checkDisconnected() (ConnectionContext.cpp:572)
==20092==    by 0x4C5A99D: qpid::messaging::amqp::ConnectionContext::check() (ConnectionContext.cpp:559)
==20092==    by 0x4C5AF4B: qpid::messaging::amqp::ConnectionContext::wait() (ConnectionContext.cpp:593)
==20092==    by 0x4C5B0C2: qpid::messaging::amqp::ConnectionContext::wait(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::SenderContext>) (ConnectionContext.cpp:612)
==20092==    by 0x4C59DAD: qpid::messaging::amqp::ConnectionContext::send(boost::shared_ptr<qpid::messaging::amqp::SessionContext>, boost::shared_ptr<qpid::messaging::amqp::SenderContext>, qpid::messaging::Message const&, bool) (ConnectionContext.cpp:462)
==20092==    by 0x4C79D80: qpid::messaging::amqp::SenderHandle::send(qpid::messaging::Message const&, bool) (SenderHandle.cpp:42)
==20092==    by 0x4CD4399: qpid::messaging::Sender::send(qpid::messaging::Message const&, bool) (Sender.cpp:40)
==20092==    by 0x40E45B: main (qpid-send.cpp:413)
{noformat}"
Bug,QPID-6049,12737109,[AMQP 1.0] ssl broken over 1.0,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"Caused by the change in https://issues.apache.org/jira/browse/QPID-5788

NSS is not correctly initialised for 1.0 connections."
Bug,QPID-5646,12703761,Can't build against any released version of proton,astitcher,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,"as a result of changes for QPID-5631.

Both trunk and beta need to be able to build against a released version of proton."
Bug,QPID-5648,12704047,basic C++ AMQP 1.0 ssl client connections broken,cliffjansen,cliffjansen,Closed,Fixed,2014-04-02 18:57,C++,C++ Client,,,,,,,"In attached commands, the two spout examples are identical except choice of 0-10 or 1.0 protocol version.  The second one fails starting in r1570231 (QPID-5568).

export QPID_SSL_CERT_DB=/b/amqp/b/q2504/ssl9/client/db
export QPID_SSL_CERT_PASSWORD_FILE=/b/amqp/b/q2504/ssl9/client/pwf


qbuild/examples/messaging/spout --broker hex.cjyvr.com:5671 --connection-options ""{transport:ssl,protocol:amqp0-10}"" --content ""hello"" --count 1 ""my_queue; {create:always , node: {durable : False} }""
qbuild/examples/messaging/spout --broker hex.cjyvr.com:5671 --connection-options ""{transport:ssl,protocol:amqp1.0}"" --content ""hello"" --count 1 ""my_queue; {create:always , node: {durable : False} }""

qbuild/examples/messaging/drain --broker hex.cjyvr.com:5671 --connection-options ""{transport:ssl,protocol:amqp0-10}"" ""my_queue; {create:always , node: {durable : False} }"""
Bug,QPID-5488,12689352,Apparent corruption of SSL connection,astitcher,jross,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,ssl_test fails.  See attached output for details.
Bug,QPID-5445,12686235,Make install writes to OS-reserved location despite setting prefix,mcpierce,jross,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"The qmfgen install ignores the install prefix.  An unprivileged install will fail:

http://people.apache.org/~jross/qpid-cpp-0.26-rc2-make-install-to-prefix.txt

Worse, a privileged install can overwrite system-installed code."
Bug,QPID-4907,12650887,qpid-tool displays duplicate entries for objects managed by the broker.,kgiusti,kgiusti,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Tools,QMF,,,,,"qpid-tool displays two entries for each object managed by the broker.

Example:

$ qpid-config add queue KEN-Q
$ qpid-tool

Management Tool for QPID
qpid: list queue
Object Summary:
    ID   Created   Destroyed  Index
    ============================================================
    141  14:19:42  -          169.KEN-Q
<SNIP>
    156  14:19:42  -          org.apache.qpid.broker:queue:KEN-Q
<SNIP>
qpid: "
Bug,QPID-5014,12659421,Make autotools build require special argument to work,astitcher,astitcher,Closed,Fixed,2013-09-08 13:37,C++,C++ Build,,,,,,,"autotools builds have been deprecated and will be removed in 0.26. To make sure that users really notice this we will stop the autotools build from working by default in 0.24.

It will require the user to specify specifically that they want to use the deprecated build system before autotools builds will run."
Bug,QPID-2674,12467117,heartbeats can cause seg faults under tcp on linux,astitcher,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"If there is a queued callback that is processed during a writeable
event (or read-writeable) the writeable callback, i.e. AsynchIO::writeable(), takes the path through
line 536 of AsyncIO.cpp, then AsynchIOHandler::closedSocket() is called
which deletes the AsynchIOHandler instance, the thread then goes on to process the callbacks in DipatchHandle, which invoke on the now deleted AsynchIOHandler.

Results in cores like:

Core was generated by `/home/gordon/qpid/cpp/build/src/.libs/lt-qpidd
--load-module /home/gordon/qpid/'.
Program terminated with signal 11, Segmentation fault.
[New process 9483]
[New process 9516]
[New process 9490]
[New process 9489]
[New process 9488]
[New process 9487]
[New process 9486]
[New process 9484]
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
194     if (codec) codec->closed();
(gdb) bt
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
#1  0x00002aaefd5e9c29 in qpid::sys::AsynchIOHandler::eof (this=0x2aaab1b330c0,
a=@0x1a8778a0) at ../../src/qpid/sys/AsynchIOHandler.cpp:177
#2  0x00002aaefd51ccbf in boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#3  0x00002aaefd51c873 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, boost::function1<void,
qpid::sys::AsynchIO&, std::allocator<boost::function_base> > >,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::_bi::value<boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> > > > >, void,
qpid::sys::DispatchHandle&>::invoke (function_obj_ptr=<value optimized out>,
a0=<value optimized out>) at /usr/include/boost/bind/mem_fn_template.hpp:149
#4  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#5  0x00002aaefd5ed2b6 in qpid::sys::DispatchHandle::processEvent
(this=0x1a8778a8, type=qpid::sys::Poller::READ_WRITABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:309
#6  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#7  0x00002aaefd0844e4 in qpid::broker::Broker::run (this=<value optimized
out>) at ../../src/qpid/broker/Broker.cpp:339
#8  0x0000000000409014 in QpiddDaemon::child (this=0x7fff989850d0) at
../../src/posix/QpiddBroker.cpp:130
#9  0x00002aaefd0a482f in qpid::broker::Daemon::fork (this=0x7fff989850d0) at
../../src/qpid/broker/Daemon.cpp:91
#10 0x0000000000407585 in QpiddBroker::execute (this=<value optimized out>,
options=<value optimized out>) at ../../src/posix/QpiddBroker.cpp:168
#11 0x00000000004057ff in main (argc=12, argv=0x7fff989856b8) at
../../src/qpidd.cpp:80
(gdb) print codec
$1 = (class qpid::sys::ConnectionCodec *) 0x2aaab1b330c0
(gdb) thread apply all bt

Thread 8 (process 9484):
#0  0x00000038f9c92149 in strftime_l () from /lib64/libc.so.6
#1  0x00002aaefd51f111 in qpid::sys::outputFormattedNow (o=@0x413214b0) at
../../src/qpid/sys/posix/Time.cpp:89
#2  0x00002aaefd5da5a1 in qpid::log::Logger::log (this=0x2aaefd895680,
s=@0x2aaefd894d80, msg=@0x41321770) at ../../src/qpid/log/Logger.cpp:77
#3  0x00002aaefd5dfa9c in qpid::log::Statement::log (this=0x2aaefd894d80,
message=@0x41321f90) at ../../src/qpid/log/Statement.cpp:57
#4  0x00002aaefd5f3b4b in qpid::sys::Timer::run (this=0x19b59b40) at
../../src/qpid/sys/Timer.cpp:129
#5  0x00002aaefd51f14a in runRunnable (p=0x413213f0) at
../../src/qpid/sys/posix/Thread.cpp:35
#6  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#7  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 7 (process 9486):
#0  0x00000038fa40ad09 in pthread_cond_wait@@GLIBC_2.3.2 () from
/lib64/libpthread.so.0
#1  0x00002aaefd5f3b73 in qpid::sys::Timer::run (this=0x19b5f490) at
../../include/qpid/sys/posix/Condition.h:63
#2  0x00002aaefd51f14a in runRunnable (p=0x19b5f4c4) at
../../src/qpid/sys/posix/Thread.cpp:35
#3  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#4  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 6 (process 9487):
#0  0x00000038f9cd4018 in epoll_wait () from /lib64/libc.so.6
#1  0x00002aaefd526343 in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:570
#2  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#3  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#4  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#5  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 5 (process 9488):
#0  0x00000038f9cd3f9a in epoll_ctl () from /lib64/libc.so.6
#1  0x00002aaefd525fd7 in qpid::sys::PollerPrivate::resetMode (this=0x19b593a0,
eh=@0x2aaab4090920) at ../../src/qpid/sys/epoll/EpollPoller.cpp:389
#2  0x00002aaefd52624d in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:558
#3  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#4  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#5  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#6  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 4 (process 9489):
#0  0x00000038f9cd447b in accept () from /lib64/libc.so.6
#1  0x00002aaefd511ca4 in qpid::sys::Socket::accept (this=<value optimized
out>) at ../../src/qpid/sys/posix/Socket.cpp:215
#2  0x00002aaefd51a085 in qpid::sys::posix::AsynchAcceptor::readable
(this=0x19b634b0, h=@0x19b634d0) at ../../src/qpid/sys/posix/AsynchIO.cpp:121
#3  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x157, a0=@0x0)
    at /usr/include/boost/function/function_template.hpp:576
---Type <return> to continue, or q <return> to quit---
#4  0x00002aaefd5ed1f9 in qpid::sys::DispatchHandle::processEvent
(this=0x19b634d0, type=qpid::sys::Poller::READABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:278
#5  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#6  0x00002aaefd51f14a in runRunnable (p=0x13) at
../../src/qpid/sys/posix/Thread.cpp:35
#7  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#8  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 3 (process 9490):
#0  0x00000038f9cd3f9a in epoll_ctl () from /lib64/libc.so.6
#1  0x00002aaefd525fd7 in qpid::sys::PollerPrivate::resetMode (this=0x19b593a0,
eh=@0x2aaab40dc910) at ../../src/qpid/sys/epoll/EpollPoller.cpp:389
#2  0x00002aaefd52624d in qpid::sys::Poller::wait (this=0x19b4ee00,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:558
#3  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#4  0x00002aaefd51f14a in runRunnable (p=0x5) at
../../src/qpid/sys/posix/Thread.cpp:35
#5  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#6  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 2 (process 9516):
#0  0x00000038f9cd4018 in epoll_wait () from /lib64/libc.so.6
#1  0x00002aaefd526343 in qpid::sys::Poller::wait (this=0x19b65e60,
timeout=<value optimized out>) at ../../src/qpid/sys/epoll/EpollPoller.cpp:570
#2  0x00002aaefd526ea7 in qpid::sys::Poller::run (this=0x19b65e60) at
../../src/qpid/sys/epoll/EpollPoller.cpp:517
#3  0x00002aaefd51f14a in runRunnable (p=0x14) at
../../src/qpid/sys/posix/Thread.cpp:35
#4  0x00000038fa406617 in start_thread () from /lib64/libpthread.so.0
#5  0x00000038f9cd3c2d in clone () from /lib64/libc.so.6

Thread 1 (process 9483):
#0  0x00002aaefd5e999d in qpid::sys::AsynchIOHandler::disconnect
(this=0x1a4f0880) at ../../src/qpid/sys/AsynchIOHandler.cpp:194
#1  0x00002aaefd5e9c29 in qpid::sys::AsynchIOHandler::eof (this=0x2aaab1b330c0,
a=@0x1a8778a0) at ../../src/qpid/sys/AsynchIOHandler.cpp:177
#2  0x00002aaefd51ccbf in boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#3  0x00002aaefd51c873 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO, boost::function1<void,
qpid::sys::AsynchIO&, std::allocator<boost::function_base> > >,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::_bi::value<boost::function1<void, qpid::sys::AsynchIO&,
std::allocator<boost::function_base> > > > >, void,
qpid::sys::DispatchHandle&>::invoke (function_obj_ptr=<value optimized out>,
a0=<value optimized out>) at /usr/include/boost/bind/mem_fn_template.hpp:149
#4  0x00002aaefd5ee49f in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() (this=0x2aaefd5e9c20, 
    a0=@0x1a8778a0) at /usr/include/boost/function/function_template.hpp:576
#5  0x00002aaefd5ed2b6 in qpid::sys::DispatchHandle::processEvent
(this=0x1a8778a8, type=qpid::sys::Poller::READ_WRITABLE)
    at ../../src/qpid/sys/DispatchHandle.cpp:309
#6  0x00002aaefd526e98 in qpid::sys::Poller::run (this=0x19b4ee00) at
../../src/qpid/sys/Poller.h:125
#7  0x00002aaefd0844e4 in qpid::broker::Broker::run (this=<value optimized
out>) at ../../src/qpid/broker/Broker.cpp:339
#8  0x0000000000409014 in QpiddDaemon::child (this=0x7fff989850d0) at
../../src/posix/QpiddBroker.cpp:130
#9  0x00002aaefd0a482f in qpid::broker::Daemon::fork (this=0x7fff989850d0) at
../../src/qpid/broker/Daemon.cpp:91
---Type <return> to continue, or q <return> to quit---
#10 0x0000000000407585 in QpiddBroker::execute (this=<value optimized out>,
options=<value optimized out>) at ../../src/posix/QpiddBroker.cpp:168
#11 0x00000000004057ff in main (argc=12, argv=0x7fff989856b8) at
../../src/qpidd.cpp:80
(gdb)    "
Bug,QPID-2086,12435128,intermittent federated cluster hangs since r810591,aconway,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"On revision 810590 I can run federated_cluster_test_with_node_failure in a loop for over 100 iterations without any hangs.

However on revision 810591 the same loop hangs quite easily (generally within 10 runs or so). "
Bug,QPID-4579,12631962,Fails to build from source with GCC 4.8.0,mcpierce,mcpierce,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The compiler error seen is:

In file included from ./qpid/framing/FrameHandler.h:23:0,
                 from ./qpid/framing/Proxy.h:22,
                 from qpid/framing/Proxy.cpp:19:
./qpid/framing/Handler.h:52:47: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     template <class F> class Functor : public Handler<T> {
                                               ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
./qpid/framing/Handler.h:64:30: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     class MemFunRef : public Handler<T> {
                              ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
cc1plus: all warnings being treated as errors
make[3]: *** [qpid/framing/Proxy.lo] Error 1
In file included from ./qpid/framing/FrameHandler.h:23:0,
                 from ./qpid/framing/InputHandler.h:24,
                 from ./qpid/framing/amqp_framing.h:28,
                 from ./qpid/framing/SendContent.h:22,
                 from qpid/framing/SendContent.cpp:22:
./qpid/framing/Handler.h:52:47: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     template <class F> class Functor : public Handler<T> {
                                               ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^
./qpid/framing/Handler.h:64:30: error: invalid use of incomplete type 'struct qpid::framing::Handler<T>' [-Werror]
     class MemFunRef : public Handler<T> {
                              ^
./qpid/framing/Handler.h:32:8: error: declaration of 'struct qpid::framing::Handler<T>' [-Werror]
 struct Handler {
        ^"
Bug,QPID-3338,12513092,qpidxarm CMake target is missing in 0-12,cliffjansen,cliffjansen,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"cpp/src/CMakeLists.txt was altered for mingw builds in QPID-2905 (r1104662).

The qpidxarm target builds the XA distributed transaction resource manager for use with the Microsoft distributed trasanction coordinator.  It was targeted for Windows builds only, using the CMake variable ""WIN32"".

This variable was changed to ""_MSC_VER"" for QPID-2905, presumably to indicate that the build target should only apply to builds using the Microsoft compiler, and not mingw.  Unfortunately ""_MSC_VER"" is not a recognized CMAKE variable and the qpidxarm target is never generated.

The CMake documentation indicates the the variable ""MSVC"" should be used to indicate The Microsoft compiler compared to mingw.
"
Bug,QPID-3586,12530360,Changes for QPID-3464 break cmake build in tar.gz distribution,astitcher,astitcher,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,The changes to the cmake build system in QPID-3464 added some new cmake build files however they weren't added to the autotools list of files to distribute. As it's autotools that creates the .tar.gz this means that the distribution doesn't have all teh files for the cmake build.
Bug,QPID-3926,12549210,Fixes how unsigned 16 bit ints are assigned in the UUID test.,tross,mcpierce,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"On Fedora 17, or any compiler that uses the C++11 standard, the existing test fails to compile with errors like:

/home/mcpierce/Programming/Qpid/qpid/cpp/src/tests/Uuid.cpp:51:165: error: narrowing conversion of ''\37777777672'' from 'char' to 'unsigned char' inside { } is ill-formed in C++11 [-Werror=narrowing]"
Bug,QPID-1835,12424419,C++ qpidbroker.vcproj missing from RC1 kit,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Build,,,,,,The cpp/src/qpidbroker.vcproj file is missing from the RC1 kit. This is required to build the C++ broker.
Bug,QPID-1477,12408901,"If linked with boost_serialization, client application using c++ lib will crash on connecting to broker",,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"==10300== Invalid read of size 4
==10300==    at 0x4325A38: boost::spirit::impl::object_with_id<boost::spirit::impl::grammar_tag, unsigned>::~object_with_id() (object_with_id.ipp:122)
==10300==    by 0x432215A: qpid::Url::parse(char const*) (grammar.hpp:50)
==10300==    by 0x804984B: qpid::Url::Url(char const*) (Url.h:60)

Valgrind shows problem to be an issue with the spirit based url parser.

#include <qpid/Url.h>
using namespace qpid;

int main(int argc, char ** argv)
{
    for (uint i = 0; i < 100; i++) {
        Url url(argc > 1 ? argv[1] : ""amqp:tcp:127.0.0.1"");
    }
    return 0;
}

Compiling the above and linking with boost_serialization causes a crash. As known urls are passed to the client on opening a connection, this is causing crashes when c++ client apps are also linked against boost_serialization.
"
Bug,QPID-3898,12546396,qpid-tool bounces repeatedly when using SSL,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"when qpid-tool connects through SSL it starts disconnecting and reconnecting every 10 seconds.
qpid-stat does not do this."
Bug,QPID-1525,12410405,Missing pure virtual method in Windows AsynchIO.cpp,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,svn rev 724233 added a pure virtual method to qpid/sys/AsynchIO.h which was not added to qpid/sys/windows/AsynchIO.cpp. This causes the common lib compile to fail. Must be fixed for M4.
Bug,QPID-4345,12609110,Windows memory leak,cliffjansen,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,In our large system performance test environments we see Broker memory growth until the process crashes.  This appears to be reproducible simply by opening and closing connections as fast as possible.  Marked as 'Blocker' as it was blocking shipment of our Windows based product - the Broker would exhaust memory and crash itself every few days of operation.
Bug,QPID-1546,12411098,M4 RC5 Windows Visual Studio files munged,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The Visual Studio project files for the C++ build had some licensing inserted and the line endings changed to Unix. These made them unusable by Visual Studio, so they won't load. I can change the line endings to DOS easily enough, but does the Apache license have to be included in the project files (*.vcproj)? If so, can it go further down the file (right now it's right at the top and Visual Studio screams about it).

I'll fix these things Monday 22-Dec-08 if I can get clarification about the license placement."
Bug,QPID-3915,12548116,"Add missing newlines to the end of the following source modules: ManagementAgentImpl.cpp, Exchange.cpp, Queue.cpp, ManagementAgent.cpp",,mcpierce,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"The four mentioned files do not have a newline at the end of the file. This causes gcc to fail to compile the modules with the error:

/home/mcpierce/Programming/Qpid/qpid/cpp/src/qpid/broker/Queue.cpp:1830:3: error: no newline at end of file
make[2]: *** [src/CMakeFiles/qpidbroker.dir/qpid/broker/Queue.o] Error 1
make[1]: *** [src/CMakeFiles/qpidbroker.dir/all] Error 2"
Bug,QPID-2344,12445953,qpid/messaging/uuid.h r899657 breaks Windows build...,shuston,kbonin,Closed,Fixed,2010-01-19 18:18,C++,C++ Client,,,,,,,The friend declarations break the VS2008 build - the compiler doesn't seem to automatically apply the Microsoft declspec from the operators with the friend function keyword.
Bug,QPID-7893,13096466,compilation failure on Fedora 26,jross,robbie,Resolved,Fixed,2021-02-01 11:54,C++,C++ Broker,C++ Build,C++ Client,,,,,"When trying to compile qpid-cpp master (commit 55d4171a8155d9f6a07a48507e33d43b8cb6d904) on Fedora 26, I get some 'maybe-uninitialized' related complication failures (see attachment). 

Adding ""-DCMAKE_CXX_FLAGS=-Wno-error=maybe-uninitialized"" to the initial cmake run seemed to get things going though obviously might not be correct.
"
Bug,QPID-4545,12628547,AMQP 1.0 support doesn't work under cmake build,gsim,gsim,Closed,Fixed,2017-03-14 20:07,C++,C++ Build,,,,,,,Dues to required internal symbols being hidden now (http://svn.apache.org/viewvc/qpid/trunk/qpid/cpp/src/CMakeLists.txt?r1=1406353&r2=1406352&pathrev=1406353).
Bug,QPID-6470,12787068,FieldValue::getFloatingPointValue() converts endian each time it is called,aconway,pokutnev,Closed,Fixed,2016-09-08 10:26,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"When calling getFloatingPointValue multiple times, the octets are endian-converted each time.
Actually we need to make a copy first and then call convertIfRequired()."
Bug,QPID-4225,12603275,"CLONE - ""qpid::TransportFailure"" exception leak in AutoCancel destructor leads to termination of client",gsim,gsim,Closed,Fixed,2015-10-26 0:30,C++,C++ Client,,,,,,,"=== Code ====

SubscriptionManager subscriptions(session);
subscriptions.get(response, queue,
 timeout * TIME_SEC);

when the connection to qpid is lost during the wait period client application gets crashed with following exception

terminate called after throwing an instance of 'qpid::TransportFailure'
what(): 
aborted

==== GDB Backtrace output ====

Starting program: /home/vmware/Desktop/qpidc-0.6/examples/direct/direct_producer 
[Thread debugging using libthread_db enabled]
[New Thread 0x7f349456c780 (LWP 5097)]
[New Thread 0x425b3950 (LWP 5100)]
2012-08-09 16:39:09 warning Connection closed
terminate called after throwing an instance of 'qpid::TransportFailure'
  what():  Connection closed

Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7f349456c780 (LWP 5097)]
0x00007f34930c75c5 in raise () from /lib64/libc.so.6
(gdb) bt full
#0  0x00007f34930c75c5 in raise () from /lib64/libc.so.6
No symbol table info available.
#1  0x00007f34930c8bb3 in abort () from /lib64/libc.so.6
No symbol table info available.
#2  0x00007f34939231d4 in __gnu_cxx::__verbose_terminate_handler () from /usr/lib64/libstdc++.so.6
No symbol table info available.
#3  0x00007f34939215f6 in ?? () from /usr/lib64/libstdc++.so.6
No symbol table info available.
#4  0x00007f34939207eb in ?? () from /usr/lib64/libstdc++.so.6
No symbol table info available.
#5  0x00007f34939213b8 in __gxx_personality_v0 () from /usr/lib64/libstdc++.so.6
No symbol table info available.
#6  0x00007f34933fece3 in ?? () from /lib64/libgcc_s.so.1
No symbol table info available.
#7  0x00007f34933feda8 in _Unwind_Resume () from /lib64/libgcc_s.so.1
No symbol table info available.
#8  0x0000000000405333 in qpid::client::AutoCancel::~AutoCancel ()
No locals.
#9  0x00007f3493c22369 in qpid::client::SubscriptionManagerImpl::get (this=0x823000, result=@0x7fff9c58d060, queue=@0x7fff9c58d070, 
    timeout=<value optimized out>) at qpid/client/SubscriptionManagerImpl.cpp:128
	lq = {<qpid::client::Handle<qpid::client::LocalQueueImpl>> = {impl = 0x822ee0}, <No data fields>}
	unique = {static npos = 18446744073709551615, 
  _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, 
    _M_p = 0x6104e8 ""dbd23f8c-061e-41c1-bee5-a5712fbece52""}}
	sm = {<qpid::sys::Runnable> = {_vptr.Runnable = 0x7f3493ee0e50}, <qpid::client::Handle<qpid::client::SubscriptionManagerImpl>> = {impl = 0x823000}, 
  static UNLIMITED = <optimized out>}
	ac = {sm = @0x7fff9c58cf70, tag = {static npos = 18446744073709551615, 
    _M_dataplus = {<std::allocator<char>> = {<__gnu_cxx::new_allocator<char>> = {<No data fields>}, <No data fields>}, 
      _M_p = 0x6104e8 ""dbd23f8c-061e-41c1-bee5-a5712fbece52""}}}
#10 0x0000000000404c38 in main ()
No locals.

======= Bug description =======

get() method of subscriptionmanager class registers for the AutoCancel. During the Destruction of AutoCancel class object 
( goes out of scope due to the return of get() or other exception in get() ) if the connection to the qpid is lost or not available,
""qpid::TransportFailure"" exception is being thrown somewhere from inside the SubscriptionManager::Cancel()

""  As the execption is not handled in the destructor and can not propagate beyond destructor ( Execption leak ), eventually leads to termination of the application ""


"" Handling of Exception in the application does not work in this case ""


Just for the confirmation I tried to handle the exception in ~AutoCancel() and it worked , application was able to survive.

~AutoCancel() {

	try{

		sm->cancel()

	} catch ( qpid::TransportFailure& Ex) {

		std::cout<< "" Inside ~AutoCancel() "" <<Ex.what()<<std::endl;

	}

}

This was produced in the 0.6 version but by looking at the code of 0.16 I  believe this problem is present the latest version also.
"
Bug,QPID-5669,12707115,"""SSL negotiation failed"" spurious error on connection close (Windows C++)",cliffjansen,cliffjansen,Closed,Fixed,2014-04-17 6:25,C++,C++ Client,,,,,,,"The AMQP 1.0 protocol transport driver has a different interaction between threads on connection close.  This exposes bugs in the existing SslAsynchIO driver that leads to spurious error messages about failed negotiation setup, even though the setup succeeded long ago.

The associated ""reason"" for the failure varies, because the contents of the error code is unrelated to any SSL processing error.
"
Bug,QPID-5139,12668561,"HA transactions block a thread, can deadlock the broker.",aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Clustering,,,,,,,"When the client sends a ""prepare"" command for a transaction, the thread handling that command is blocked until all backups have responded with their prepare status. This can easily deadlock the broker if there are more concurrent transactions than worker threads.

To reproduce you need a way to delay completion of a transaction. The following regression test illustrates, it will be added to TransactionTests in ha_tests.py as part of the fix:
{noformat}
    def test_tx_block_threads(self):
        """"""Verify that TXs blocked in commit don't block broker threads.""""""
        cluster = HaCluster(self, 2, args=[""--worker-threads=2""])
        sessions = [cluster[0].connect().session(transactional=True) for i in xrange(2)]
        for s in sessions: s.sender(""foo;{create:always}"").send(""foo"")
        self.assertEqual(2, len(cluster[1].agent().tx_queues()))
        os.kill(cluster[1].pid, signal.SIGSTOP) # Freeze backup so tx can't complete.
        threads = [ Thread(target=s.commit) for s in sessions]
        for t in threads: t.start()
        cluster[0].ready(timeout=1) # Should not block
        os.kill(cluster[1].pid, signal.SIGCONT) # Allow tx to complete.
        for t in threads: t.join()
        c.close()
{noformat}
"
Bug,QPID-3292,12509279,Client doesn't completely honor reconnect=false Connection option,gsim,ncdc,Closed,Fixed,2013-08-21 11:02,C++,C++ Client,,,,,,,"The C++ client currently does not honor the reconnect=false Connection option correctly.  If the client loses the connection to the broker, the client will attempt to reconnect one time, even if reconnect is set to false.

In qpid::client::amqp0_10::ConnectionImpl::connect, the method has !tryConnect() as the condition for the ""for"" loop, which means that tryConnect() will be invoked at least 1 time.  Next, in the loop body, it will look at the value of the reconnect setting, and stop if it's set to false.

The client should not try to reconnect at all if reconnect is set to false."
Bug,QPID-3849,12542818,Client connection breaks broker-to-broker cluster SASL authentication (CVE-2012-3467),aconway,pcolby,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"There is a very strange problem that causes ordinary C++ clients to break C++ broker cluster authentication.

I have two brokers, let's call them {{gateway03}} and {{gateway04}}.  They are both configured to cluster using SSL and CRAM-MD5 (see their configuration files / environment below).

h3. Scenario 1
This scenario works fine.  I'm simply reporting it to show that it does work.
# I start the broker on {{gateway04}}.
# I start the broker on {{gateway03}}.
# {{gateway03}} discovers the cluster.
# {{gateway03}} creates a new persistent store.
# {{gateway03}} receives updates from {{gateway04}}
# {{gateway03}} caught-up
# {{gateway04}} marks store as dirty (no longer last man standing).
# Start as many of my C++ clients as I want, and they all connect with no issues (note, I've included a sample C++ client that I used to test below, but the same happens with a number of fully-fledged C++ client applications I've written too).

This is all perfect! :)

h3. Scenario 2
This is the one that reveals a problem :(
# I start the broker on {{gateway04}}.
#* I *don't* start the broker on {{gateway03}} yet.
# I start one or more C++ clients on {{gateway04}} (or {{gateway03}} telling the client to connect to {{gateway04}}) (see sample C++ client code below).
# C++ clients all connect correctly, with no issues.
# I start the broker on {{gateway03}}.
# {{gateway03}} discovers the cluster.
# {{gateway03}} creates a new persistent store.
#* Up to this point the results of the two scenarios is the same, just the order is different.
# The broker on {{gateway03}} reports ""warning Client closed connection with 501: Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN)"" then ""critical cluster(192.168.9.90:24784 UPDATEE) catch-up connection closed prematurely"".
# At the same time {{gateway04}} reports ""warning Closing connection due to Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN)}"" then ""error sending update: Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN)""
# Then, of course, the broker on {{gateway03}} shuts down.

Note, more complete broker / client logs are included below.

So, it seems that somehow once an ordinary C++ client (ie not another broker) connects to the broker, the broker no longer accepts CRAM-MD5 authentication from other joining brokers.  But already-joined brokers participating in the cluster are not affected.

This may be the result of some misconfiguration on my part, but looks like a pretty serious clustering bug to me... ?

Some further notes:
* I don't know at this stage if the use of SSL has any affect (ie I haven't tried these same tests with SSL turned off).
* it doesn't matter which broker is started first - I can swap {{gateway03}} and {{gateway04}} in every instance, and the result is the same.
* I have a third broker that I use as part of this cluster, and it sees that same affect.  If, for example, I have two brokers clustered, and a client connects, then the third broker will not be able to join the cluster for the same reason as above.

h3. Broker Configuration

The {{gateway03}} broker is configured as follows ({{gateway04}} config is the same, but with {{03}} replaced with {{04}} where relevant).

{code:title=/etc/qpidd.conf}
cluster-name=""mm-queue-cluster""
cluster-mechanism=CRAM-MD5
cluster-username=guest
cluster-password=guest
cluster-size=0
cluster-url=ssl:gateway03:5671

auth=yes

ssl-cert-db=/etc/qpid/certs/broker
ssl-cert-password-file=/etc/qpid/certs/pass.txt
ssl-cert-name=broker
require-encryption=yes
{code}

{code:title=/etc/sasl2/qpidd.conf}
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /var/lib/qpidd/qpidd.sasldb
mech_list: CRAM-MD5 DIGEST-MD5 PLAIN
sql_select: dummy select
{code}

{code:title=broker environment}
export QPID_SSL_CERT_DB=/etc/qpid/certs/broker
export QPID_SSL_CERT_NAME=broker
export QPID_SSL_CERT_PASSWORD_FILE=/etc/qpid/certs/pass.txt
{code}

h3. Sample Test Client
{code:title=main.cpp}

#include <iostream>
#include <qpid/messaging/Connection.h>

int main(int argc, char *argv[]) {
    qpid::types::Variant::Map options;
    options[""username"" ] = ""guest"";
    options[""password"" ] = ""guest"";
    qpid::messaging::Connection connection(""ssl:gateway04:5671"", options);
    connection.open();
    std::cout << ""sleeping..."" << std::endl;
    sleep(300);
    return 0;
}
{code}

{code:title=client environment}
export QPID_SSL_CERT_DB=/etc/qpid/certs/client
export QPID_SSL_CERT_NAME=client
export QPID_SSL_CERT_PASSWORD_FILE=/etc/qpid/certs/pass.txt
{code}

h3. Scenario 1 Logs
This is the one where everything works as expected.

{code:title=""Broker on gateway04""}
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Journal ""TplStore"": Created
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Store module initialized; store-dir=/var/lib/qpidd
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Initializing CPG
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Cluster store state: clean cluster-id=63f8f108-5a60-4efe-8506-27385006c5fc shutdown-id=969b7c98-b4f6-4a01-93f4-962f3ab5f77d
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice cluster(192.168.9.92:6749 PRE_INIT) configuration change: 192.168.9.92:6749
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice cluster(192.168.9.92:6749 PRE_INIT) Members joined: 192.168.9.92:6749
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Journal ""..."": Created
(queues being loading from persistent store...)
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Journal ""..."": Created
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Listening on TCP/TCP6 port 5672
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Listening for SSL connections on TCP port 5671
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice cluster(192.168.9.92:6749 INIT) cluster-uuid = 63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice cluster(192.168.9.92:6749 READY) joined cluster ""mm-queue-cluster""
Feb 16 12:58:03 gateway04 qpidd[6749]: 2012-02-16 12:58:03 notice Broker running
(broker on gateway03 started here...)
Feb 16 12:58:21 gateway04 qpidd[6749]: 2012-02-16 12:58:21 notice cluster(192.168.9.92:6749 READY) configuration change: 192.168.9.90:28152 192.168.9.92:6749
Feb 16 12:58:21 gateway04 qpidd[6749]: 2012-02-16 12:58:21 notice cluster(192.168.9.92:6749 READY) Members joined: 192.168.9.90:28152
Feb 16 12:58:21 gateway04 qpidd[6749]: 2012-02-16 12:58:21 notice cluster(192.168.9.92:6749 UPDATER) sending update to 192.168.9.90:28152 at amqp:ssl:gateway03:5671
Feb 16 12:58:50 gateway04 qpidd[6749]: 2012-02-16 12:58:50 warning Broker closed connection: 200, OK
Feb 16 12:58:50 gateway04 qpidd[6749]: 2012-02-16 12:58:50 notice cluster(192.168.9.92:6749 UPDATER) update sent
Feb 16 12:58:50 gateway04 qpidd[6749]: 2012-02-16 12:58:50 notice Running in a cluster, marking store dirty.
(client connected here...)
{code}

{code:title=""Broker on gateway03""}
(broker on gateway04 already started)
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Journal ""TplStore"": Created
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Store module initialized; store-dir=/var/lib/qpidd
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Initializing CPG
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Cluster store state: dirty cluster-id=63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice cluster(192.168.9.90:28152 PRE_INIT) configuration change: 192.168.9.90:28152 192.168.9.92:6749
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice cluster(192.168.9.90:28152 PRE_INIT) Members joined: 192.168.9.90:28152
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Cluster recovery: recovered journal data discarded and journal files pushed down
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Store directory /var/lib/qpidd/rhm was pushed down (saved) into directory /var/lib/qpidd/_cluster.bak.0004.
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Journal ""TplStore"": Created
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Listening on TCP/TCP6 port 5672
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Listening for SSL connections on TCP port 5671
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice cluster(192.168.9.90:28152 INIT) cluster-uuid = 63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice cluster(192.168.9.90:28152 JOINER) joining cluster ""mm-queue-cluster""
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Broker running
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice cluster(192.168.9.90:28152 UPDATEE) receiving update from 192.168.9.92:6749
Feb 16 12:58:21 gateway03 qpidd[28152]: 2012-02-16 12:58:21 notice Journal ""..."": Created
(queues being added to persistent store...)
Feb 16 12:58:49 gateway03 qpidd[28152]: 2012-02-16 12:58:49 notice Journal ""..."": Created
Feb 16 12:58:50 gateway03 qpidd[28152]: 2012-02-16 12:58:50 notice cluster(192.168.9.90:28152 CATCHUP) update complete, starting catch-up.
Feb 16 12:58:50 gateway03 qpidd[28152]: 2012-02-16 12:58:50 notice cluster(192.168.9.90:28152 READY) caught up.
{code}

{code:title=client}
(brokers on gateway03 and gateway04 already started)
2012-02-16 12:58:59 debug Created connection ssl:gateway04:5671 with {password:guest, username:guest}
2012-02-16 12:58:59 info Trying to connect to ssl:gateway04:5671...
2012-02-16 12:58:59 debug Created IO thread: 0
2012-02-16 12:58:59 debug SslConnector created for \x00-

2012-02-16 12:58:59 debug RECV [[59347 192.168.9.92:5671]]: INIT(0-10)
2012-02-16 12:58:59 debug CyrusSasl::start(PLAIN CRAM-MD5 DIGEST-MD5)
2012-02-16 12:58:59 debug external SSF detected and set to 128
2012-02-16 12:58:59 debug external auth detected and set to dummy
2012-02-16 12:58:59 debug min_ssf: 0, max_ssf: 256
2012-02-16 12:58:59 debug CyrusSasl::start(PLAIN CRAM-MD5 DIGEST-MD5): selected DIGEST-MD5 response: ''
2012-02-16 12:58:59 debug getUserFromSettings(): guest
2012-02-16 12:58:59 debug CyrusSasl::step(nonce=""zFwuPhC+6PbfNOHDqfuf4U6E2mE8E3ApAWqfMdNxTJ8="",realm=""QPID"",qop=""auth"",maxbuf=65535,charset=utf-8,algorithm=md5-sess): username=""guest"",realm=""QPID"",nonce=""zFwuPhC+6PbfNOHDqfuf4U6E2mE8E3ApAWqfMdNxTJ8="",cnonce=""a8bswbmo7ThWIV6o++rfJbMbC3PiF+EhxopFREICAHw="",nc=00000001,qop=auth,maxbuf=65535,digest-uri=""qpidd/gateway04"",response=55178f8db5c1a5df13aa98ac2582d873
2012-02-16 12:58:59 debug CyrusSasl::step(rspauth=645945230c3b9d71d00ef3221ce9514c):
2012-02-16 12:58:59 info Connection [59347 192.168.9.92:5671] connected to ssl:gateway04:5671
2012-02-16 12:58:59 debug Connection [59347 192.168.9.92:5671] no security layer in place
2012-02-16 12:58:59 info Connected to ssl:gateway04:5671
2012-02-16 12:58:59 debug Added known-hosts, reconnect-urls=[ssl:gateway04:5671, amqp:ssl:gateway03:5671, amqp:ssl:gateway04:5671]
sleeping...
2012-02-16 12:58:59 debug Known-brokers for connection: amqp:ssl:gateway03:5671, amqp:ssl:gateway04:5671
{code}

h3. Scenario 2 Logs
This is the one where the cluster SASL mechanism breaks.

{code:title=""Broker on gateway04""}
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Journal ""TplStore"": Created
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Store module initialized; store-dir=/var/lib/qpidd
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Initializing CPG
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Cluster store state: clean cluster-id=63f8f108-5a60-4efe-8506-27385006c5fc shutdown-id=c058c1be-31ea-44a9-bc71-e76c37732d8f
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice cluster(192.168.9.92:7100 PRE_INIT) configuration change: 192.168.9.92:7100
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice cluster(192.168.9.92:7100 PRE_INIT) Members joined: 192.168.9.92:7100
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Journal ""..."": Created
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Journal ""..."": Created
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Listening on TCP/TCP6 port 5672
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Listening for SSL connections on TCP port 5671
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice cluster(192.168.9.92:7100 INIT) cluster-uuid = 63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice cluster(192.168.9.92:7100 READY) joined cluster ""mm-queue-cluster""
Feb 16 13:09:32 gateway04 qpidd[7100]: 2012-02-16 13:09:32 notice Broker running
(client connected here...)
(broker on gateway03 started here...)
Feb 16 13:09:51 gateway04 qpidd[7100]: 2012-02-16 13:09:51 notice cluster(192.168.9.92:7100 READY) configuration change: 192.168.9.90:28717 192.168.9.92:7100
Feb 16 13:09:51 gateway04 qpidd[7100]: 2012-02-16 13:09:51 notice cluster(192.168.9.92:7100 READY) Members joined: 192.168.9.90:28717
Feb 16 13:09:51 gateway04 qpidd[7100]: 2012-02-16 13:09:51 notice cluster(192.168.9.92:7100 UPDATER) sending update to 192.168.9.90:28717 at amqp:ssl:gateway03:5671
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 warning Closing connection due to Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN) (qpid/client/ConnectionHandler.cpp:252)
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 error cluster(192.168.9.92:7100 UPDATER) error sending update: Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN) (qpid/client/ConnectionHandler.cpp:252)
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 notice cluster(192.168.9.92:7100 UPDATER) update sent
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 warning Session was not closed cleanly: guest.x-qpid.cluster-update
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 warning Connection [37089 192.168.9.90:5671] closed
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 notice cluster(192.168.9.92:7100 READY) configuration change: 192.168.9.92:7100
Feb 16 13:10:19 gateway04 qpidd[7100]: 2012-02-16 13:10:19 notice cluster(192.168.9.92:7100 READY) Members left: 192.168.9.90:28717
{code}

{code:title=client}
(broker on gateway04 already started, but not gateway03)
2012-02-16 13:09:42 debug Created connection ssl:gateway04:5671 with {password:guest, username:guest}
2012-02-16 13:09:42 info Trying to connect to ssl:gateway04:5671...
2012-02-16 13:09:42 debug Created IO thread: 0
2012-02-16 13:09:42 debug SslConnector created for \x00-

2012-02-16 13:09:42 debug RECV [[52892 192.168.9.92:5671]]: INIT(0-10)
2012-02-16 13:09:42 debug CyrusSasl::start(PLAIN CRAM-MD5 DIGEST-MD5)
2012-02-16 13:09:42 debug external SSF detected and set to 128
2012-02-16 13:09:42 debug external auth detected and set to dummy
2012-02-16 13:09:42 debug min_ssf: 0, max_ssf: 256
2012-02-16 13:09:42 debug CyrusSasl::start(PLAIN CRAM-MD5 DIGEST-MD5): selected DIGEST-MD5 response: ''
2012-02-16 13:09:42 debug getUserFromSettings(): guest
2012-02-16 13:09:42 debug CyrusSasl::step(nonce=""DrF43YwEJoxB4MLHa7s12XjlVJVl6uKMfrqlcfsWlkE="",realm=""QPID"",qop=""auth"",maxbuf=65535,charset=utf-8,algorithm=md5-sess): username=""guest"",realm=""QPID"",nonce=""DrF43YwEJoxB4MLHa7s12XjlVJVl6uKMfrqlcfsWlkE="",cnonce=""ElxXCVBQPW7vRNzqMU0fNOcLQWaBZoTt8E3HJsTliLY="",nc=00000001,qop=auth,maxbuf=65535,digest-uri=""qpidd/gateway04"",response=a03283bbb65221600b7917462e49945b
2012-02-16 13:09:42 debug CyrusSasl::step(rspauth=5980599c97fee618ad059b00a381dd5b):
2012-02-16 13:09:42 debug Known-brokers for connection: amqp:ssl:gateway04:5671
2012-02-16 13:09:42 info Connection [52892 192.168.9.92:5671] connected to ssl:gateway04:5671
2012-02-16 13:09:42 debug Connection [52892 192.168.9.92:5671] no security layer in place
2012-02-16 13:09:42 info Connected to ssl:gateway04:5671
2012-02-16 13:09:42 debug Added known-hosts, reconnect-urls=[ssl:gateway04:5671, amqp:ssl:gateway04:5671]
sleeping...
{code}

{code:title=""Broker on gateway03""}
(broker on gateway04 already started)
(client already connected to gateway04)
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Journal ""TplStore"": Created
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Store module initialized; store-dir=/var/lib/qpidd
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Initializing CPG
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Cluster store state: dirty cluster-id=63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice cluster(192.168.9.90:28717 PRE_INIT) configuration change: 192.168.9.90:28717 192.168.9.92:7100
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice cluster(192.168.9.90:28717 PRE_INIT) Members joined: 192.168.9.90:28717
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Cluster recovery: recovered journal data discarded and journal files pushed down
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Store directory /var/lib/qpidd/rhm was pushed down (saved) into directory /var/lib/qpidd/_cluster.bak.0005.
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Journal ""TplStore"": Created
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Listening on TCP/TCP6 port 5672
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Listening for SSL connections on TCP port 5671
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice cluster(192.168.9.90:28717 INIT) cluster-uuid = 63f8f108-5a60-4efe-8506-27385006c5fc
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice cluster(192.168.9.90:28717 JOINER) joining cluster ""mm-queue-cluster""
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice Broker running
Feb 16 13:09:50 gateway03 qpidd[28717]: 2012-02-16 13:09:50 notice cluster(192.168.9.90:28717 UPDATEE) receiving update from 192.168.9.92:7100
Feb 16 13:09:51 gateway03 qpidd[28717]: 2012-02-16 13:09:51 notice Journal ""..."": Created
(queues being added to persistent store...)
Feb 16 13:10:17 gateway03 qpidd[28717]: 2012-02-16 13:10:17 notice Journal ""..."": Created
Feb 16 13:10:18 gateway03 qpidd[28717]: 2012-02-16 13:10:18 warning Client closed connection with 501: Desired mechanism(s) not valid: CRAM-MD5 (supported: ANONYMOUS PLAIN) (qpid/client/ConnectionHandler.cpp:252)
Feb 16 13:10:18 gateway03 qpidd[28717]: 2012-02-16 13:10:18 critical cluster(192.168.9.90:28717 UPDATEE) catch-up connection closed prematurely 192.168.9.92:5671-192.168.9.92:52892(192.168.9.90:28717-2 local,catchup)
Feb 16 13:10:18 gateway03 qpidd[28717]: 2012-02-16 13:10:18 notice cluster(192.168.9.90:28717 LEFT) leaving cluster ""mm-queue-cluster""
Feb 16 13:10:18 gateway03 qpidd[28717]: 2012-02-16 13:10:18 notice Shut down
{code}

I'm only too happy try anything that might help trace the problem! :)"
Bug,QPID-2214,12441432,memory leak in qpid::client::Connection,astitcher,detzi,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Hi,
when executing the code below (connecting and disconnecting to a local broker without sending any messages) the memory usage increases constantly and rapidly. After 10.000 iterations several hundred megabytes of resident memory are used.
When commenting out the lines ""connection.open()"" and ""close()"" the memory usage does not increase.

So, is there a memory leak in Connection open/close?

int
main(int argc, char** argv)
{
    while (1) {
        qpid::client::Connection connection;
        connection.open(""localhost"", 5672);
        connection.close();
    }
}

Running my test binary with valgrind (the loop is limited to 100 iterations) 
  valgrind --leak-check=full ./myqpidtest
it seems that valgrind does not find any memory leaks.

=17321== 76 bytes in 1 blocks are definitely lost in loss record 2 of 2
==17321==    at 0x4007ADE: calloc (vg_replace_malloc.c:279)
==17321==    by 0x430CD4E7: (within /lib/ld-2.3.6.so)
==17321==    by 0x430CD58B: _dl_allocate_tls (in /lib/ld-2.3.6.so)
==17321==    by 0x43AE428F: pthread_create@@GLIBC_2.1 (in /lib/tls/i686/cmov/libpthread-2.3.6.so)
==17321==    by 0x43AE4AA7: pthread_create@GLIBC_2.0 (in /lib/tls/i686/cmov/libpthread-2.3.6.so)
==17321==    by 0x4AA3B55: qpid::sys::ThreadPrivate::ThreadPrivate(qpid::sys::Runnable*) (in libqpidcommon.so.0.1.0)
==17321==    by 0x4AA3682: qpid::sys::Thread::Thread(qpid::sys::Runnable*) (in libqpidcommon.so.0.1.0)
==17321==    by 0x4C8BC6B: qpid::client::TCPConnector::init() (in libqpidclient.so.0.1.0)
==17321==    by 0x4C8040A: qpid::client::ConnectionImpl::open() (in libqpidclient.so.0.1.0)
==17321==    by 0x4C6CD4A: qpid::client::Connection::open(qpid::client::ConnectionSettings const&) (in libqpidclient.so.0.1.0)
==17321==    by 0x4C6CED2: qpid::client::Connection::open(std::string const&, int, std::string const&, std::string const&, std::string const&, unsigned short) (in libqpidclient.so.0.1.0)
==17321==    by 0x805EE1E: main (myqpidtest.cpp:281)
==17321== 
==17321== LEAK SUMMARY:
==17321==    definitely lost: 76 bytes in 1 blocks.
==17321==      possibly lost: 0 bytes in 0 blocks.
==17321==    still reachable: 48 bytes in 3 blocks.
==17321==         suppressed: 0 bytes in 0 blocks.

The 76 bytes which are reported to be definitely lost is constant whether running the loop 100 time or 1000 times.

Regards,
Daniel
"
Bug,QPID-2842,12473116,references to other objects in qpid-tool use id that doesn't match anything else,tross,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Tools,QMF,,,,,"E.g. in the following qpid-tool session it is impossible to accurately identify the session for a given subscription:

qpid: list subscription
Object Summary:
    ID   Created   Destroyed  Index
    =================================================================
    128  08:07:24  -          0-1447-1-0-13:0-1447-1-0-25:v2TopicHB
    129  08:07:24  -          0-1447-1-0-13:0-1447-1-0-23:v2TopicUI
    130  08:07:24  -          0-1447-1-0-13:0-1447-1-0-14:rdest
    131  08:07:24  -          0-1447-1-0-13:0-1447-1-0-18:tdest
    138  08:07:37  -          0-1447-1-0-35:0-1447-1-0-36:my-queue
    127  08:07:24  -          0-1447-1-0-13:0-1447-1-0-21:v2dest
qpid: show 138
Object of type: org.apache.qpid.broker:subscription:_data(7cc0ee44-57d4-2ed7-1a4b-3156ed9a4343)
    Attribute     138
    =============================
    sessionRef    0-1447-1-0-35
    queueRef      0-1447-1-0-36
    name          u'my-queue'
    browsing      False
    acknowledged  True
    exclusive     False
    creditMode    u'CREDIT'
    arguments     {}
    delivered     0

The session ref is shown as 0-1447-1-0-35, but this doesn't help me identify the session...

qpid: list session
Object Summary:
    ID   Created   Destroyed  Index
    ==========================================================================
    137  08:07:37  -          0-0-1-0-3:7c777430-1622-4ad2-923e-40e7074f1df4
    126  08:07:24  -          0-0-1-0-3:GRST500.4398.1
qpid: show 137
Object of type: org.apache.qpid.broker:session:_data(9a57d0d2-8b17-8c84-4fac-5c9a96c2cf75)
    Attribute          137
    ============================================================
    vhostRef           0-0-1-0-3
    name               u'7c777430-1622-4ad2-923e-40e7074f1df4'
    channelId          1
    connectionRef      0-1447-1-0-34
    detachedLifespan   0
    attached           True
    expireTime         None
    maxClientRate      None
    framesOutstanding  0
    TxnStarts          0
    TxnCommits         0
    TxnRejects         0
    TxnCount           0
    clientCredit       0
qpid: show 126
Object of type: org.apache.qpid.broker:session:_data(9a57d0d2-8b17-8c84-4fac-5c9a96c2cf75)
    Attribute          126
    ======================================
    vhostRef           0-0-1-0-3
    name               u'GRST500.4398.1'
    channelId          1
    connectionRef      0-1447-1-0-12
    detachedLifespan   0
    attached           True
    expireTime         None
    maxClientRate      None
    framesOutstanding  0
    TxnStarts          0
    TxnCommits         0
    TxnRejects         0
    TxnCount           0
    clientCredit       0
qpid: 

...as neither the list nor the detail view for sessions use the id of that form.
"
Bug,QPID-2598,12464302,"C++ clients hang at program end since April 16, 2010",gsim,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"C++ client code on Windows hangs at program shutdown. It appears that this started with svn r934503 (related to QPID-2511).

Symptom is that at program end, the IOThread is hung waiting for there to be 0 connections but that never happens. The sockets are open. All the python-based tests are ok, but the C++ ones hang."
Bug,QPID-688,12383010,c++ client: decoding exceptions during connection setup hang the client.,,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"An exception from frame.decode in client::Connector::readbuff (e.g. a decoding error) kills the network thread but does not raise an exception in the user thread, which is left hanging in client::ConnectionHandler::waitForOpen.

An exception in the connector should close the associated Connection with error & status, which will wake up any waiting user threads."
Bug,QPID-986,12395058,Need to link libuuid.a to libqpidbroker.so and libqpidclient.so in Qpid/C++,,danushka,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"When I try to compile a repository working copy of Qpid/C++ I get a build error saying that there are undefined references to ""uuid_generate"" in both libqpidbroker.so and libqpidclient.so. When I was going through the makefile I found that libuuid.a is not linked to these two libs and I could easily get rid of the issue simply by modifying the makefile to link libuuid.a to these two libs."
Bug,QPID-555,12376452,c++ client hangs if broker closes connection unexpectedly.,,aconway,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"Run the broker, start tests/perftest, kill the broker. The client logs the socket error but never exits.
"
Bug,QPID-488,12369102,Concurrent access to apr_pools (which are not thread safe),astitcher,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,The c++ codebase is now set to share an apr pool per process which is a problem as apr_pools are not thread safe.
Bug,QPID-2896,12476905,Incorrect detection of data types in address parameters - C++ client,jonathan.robie,tross,Closed,Fixed,2010-10-29 17:29,C++,C++ Client,,,,,,,"Numeric values in address parameters are incorrectly interpreted as strings.  The following address, run on the c++ client, causes the problem:

my-queue;{create:always,node:{type:queue,x-declare:{arguments:{'qpid.max_count':60}}}}

Reproducer:

$ drain ""my-queue;{create:always,node:{type:queue,x-declare:{arguments:{'qpid.max_count':60}}}}""
$ qpid-config queues
Queue Name                                         Attributes
======================================================================
my-queue                                           Failed: TypeError: %d format: a number is required, not str

No only does qpid-config misinterpret the value of the 'qpid.max_count' field, but the broker does as well (i.e. the limit on the queue remains the default).

Note that this works properly when using the Python API.  It is an inconsistency in the way addresses are parsed and encoded with Python doing it correctly.
"
Bug,QPID-6275,12762280,reduce default timeout for durable subscription queues,gsim,gsim,Closed,Fixed,2021-04-14 5:57,C++,C++ Client,,,,,,,Currently set to 15 minutes which is felt to be too long as a default. Value can always be directly set be user via the 'timeout' link option in the address used to create the receiver.
Bug,QPID-8453,13316508,The message encoder for AMQP 1.0 incorrectly switches between map8 and map32 representations.,cliffjansen,cliffjansen,Resolved,Fixed,2021-03-31 0:06,C++,C++ Client,,,,,,,"The encoder will use a more compact map8 encoding if it can write out a map that way. The wire representation of the map is:

size_of_count_and_data
 count
 data

Where the first two are 8 bits each for a map8 and 32 bits each for a map32.

The test to switch between map8 and map32 neglects to factor in the additional ""count"" byte, but does add the extra byte and size while writing the encoding. This can result in using a map with size of 255 (excluding the count), deciding to use map8 encoding, and then writing a size_of_count_and_data of zero (uint8_t: 255 + 1).

혻"
Bug,QPID-5020,12660436,Autotools deprecation release note for 0.24,jross,astitcher,Closed,Fixed,2019-10-02 17:34,C++,C++ Documentation,,,,,,,0.24 needs a release note pointing out that it is the last release that will contain an autotools build system and that users need to switch to cmake from now onwards.
Bug,QPID-5021,12660437,qpid::client API deprecation notice,jross,astitcher,Closed,Fixed,2019-10-02 17:34,C++,C++ Documentation,,,,,,,0.24 needs a release note pointing out that the qpid::client API has been deprecated for a while is will be removed (as an externally available API - still used internal to qpid) from the 0.26 release.
Bug,QPID-5022,12660439,QMFv1 code removal notice,jross,astitcher,Closed,Fixed,2019-10-02 17:34,C++,C++ Documentation,,,,,,,0.24 needs a release note pointing out that it is the last release that has the QMFv1 things that have been removed from the 0.26 release.
Bug,QPID-8169,13154139,Build fails on Windows due to faulty library link,jross,jross,Closed,Fixed,2019-04-24 9:07,C++,C++ Build,,,,,,,"I introduced the problem here:

[https://github.com/apache/qpid-cpp/commit/3b789332cc5ca02a7bddee04751b8f229d4603a5#diff-a443396c858e95fa94dee40a36ee26b4]

혻"
Bug,QPID-8221,13174131,[qpid-cpp] Client open connections to broker and waits forever,gsim,Chen.Wan,Closed,Fixed,2019-04-24 9:07,C++,C++ Client,,,,,,,"I have a problem with qpid-cpp C++ clients stuck on the open connection call while reconnecting with the broker.혻 혻It is a rare event, sometimes takes weeks or months to happen. 혻But when it혻occurs, I have to manually restart the client process in order to혻re-establish the broker connection.혻

I have summarized the details of this issue in this mailing list post:혻http://qpid.2158936.n2.nabble.com/Open-connection-to-broker-waits-forever-td7678381.html

Attached is a patch (qpidcpp_client_connect_timeout.patch) to add a timeout to qpid-cpp client's open혻connection call.혻 A new option called ""connect-timeout"" can be used to specify how long to wait for the connection::open call in seconds. 혻When the ""connect-timeout""혻is set, qpid-cpp client calls ""waitFor"" with a timeout.혻

I have tested it in my environment, and it seems to be able to time out혻properly when the open call gets stuck.

혻"
Bug,QPID-7051,12937510,Crash after reconnect with transactional session (with patch),jross,hakanj,Closed,Fixed,2018-04-03 23:23,C++,C++ Client,,,,,,,"I have a test program (see the ""consumer.cc"" attachment) that creates a connection with ""reconnect"" enabled.
It then creates a transactional session and a receiver to some queue from that session.
It then reads all messages from the queue and prints out their content.
A sleep is used between each read to make the test possible.

While the broker is down the program will try to reconnect to it.
As soon as it succeeds with that the fetch call throws an exception because the transaction has become invalid.
The exception is caught and the read loop is broken out of.
The test function then exits, causing the _Receiver_, _Session_, and _Connection_ objects to be destructed.

The crash happens while destructing the _Connection_ object.

It took some digging, but I managed to find the reason for the crash.
When the _Connection_ object is destructed it automatically destructs its _ConnectionHandle_ object, which in turn destructs its _ConnectionContext_ object. Nothing strange here.
The _ConnectionContext_ destructor makes a call to its own _close_ method, which tries to shut down all its sessions.

The problem is that the session has been made invalid by the disconnect, which causes the call to _syncLH_ to throw an exception,
which is not caught anywhere, indirectly causing the _ConnectionContext_ destructor to throw an exception. This is a big no-no in C++.

A side effect of this is that the transport object is not closed before it is destructed,
which means that it is still listening for events. The crash happens when the next pending event tries to use
the destructed transport object.

The solution, in my humble opinion, is to catch the exception throws by the _syncLH_ call in the _ConnectionContext::close_ method.
This way we can try to close all sessions even if one or more of them are invalidated for some reason.
The rest of the cleanup process will also be done properly.


How to run the test program:
* Compile both ""producer.cc"" and ""consumer.cc"". They both need to be linked to the ""qpidmessaging"" library.
* Run ""producer"" once. This will add ten messages to the ""apa.bepa"" queue on the broker.
* Start ""consumer"".
* When the consumer starts to print out the messages, shut down and restart the broker.
"
Bug,QPID-7054,12937817,Crash when closing a sender after the connection has been closed (with patch).,jross,hakanj,Closed,Fixed,2018-04-03 23:23,C++,C++ Client,,,,,,,"There will be a crash if you close your _Sender_ after the _Connection_ has been closed.

To reproduce, compile and run the attached ""crash_test.cc"" file.

The test program is very simple. It creates _Connection_, _Session_, and _Sender_ instances, then closes the connection explicitly followed by closing the sender. The closing of the sender causes an exception to be thrown as the connection is dead, but that is caught.

The crash happens when the _Session_ object is destructed at the end of the test function. This causes the _SenderContext_ from the sender to be destructed, which tries to close the underlying _pn_link_t_ object to be freed, but that object refers to a deleted _pn_connection_t_ object. The exception during _Sender::close_ stopped the proper cleanup to be done.

The _Sender::close_ method calls _ConnectionContext::detach_ to disconnect it from its session. One problem here is that the _Connection::close_ method made the connection forget all its sessions, but the sessions still remember their connection, including the underlying proton objects. The connection tries to reconnect to the broker and resets its internal connection, causing the proton connection object to be freed. It then tells all its sessions about this, but those are forgotten earlier. This means that we end up with _pn_link_t_ objects that refer to a deleted _pn_connection_t_ object.

I have a attached a patch to this jira which stops the _ConnectionContext::detach_ method from trying to do remote actions if not connected. The row numbers in this patch assumes that the patch in QPID-7051 is already applied, which might cause some offset warnings when applying this patch."
Bug,QPID-7669,13042093,Unintended UI changes from switch to swigged Python client for management tools,aconway,jross,Resolved,Fixed,2017-11-22 9:54,C++,C++ Broker,C++ Client,,,,,,http://qpid.2158936.n2.nabble.com/Qpid-tools-with-python-vs-qpid-cpp-messaging-td7659017.html
Bug,QPID-7671,13042684,Problem building on debian (unstable) distribution:,aconway,iboverma,Resolved,Fixed,2017-11-16 0:23,C++,C++ Build,,,,,,,"This does not work:
--
cmake . -DCMAKE_BUILD_TYPE=DebWithRelInfo
make -j4
...
[ 34%] Linking CXX shared library libqpidcommon.so
CMakeFiles/qpidcommon.dir/qpid/log/Logger.cpp.o: In function `boost::serialization::singleton<qpid::log::Logger>::get_mutable_instance()':
Logger.cpp.text._ZN5boost13serialization9singletonIN4qpid3log6LoggerEE20get_mutable_instanceEv[_ZN5boost13serialization9singletonIN4qpid3log6LoggerEE20get_mutable_instanceEv]+0x5): undefined reference to `boost::serialization::singleton_module::is_locked()'
collect2: error: ld returned 1 exit status
src/CMakeFiles/qpidcommon.dir/build.make:5583: recipe for target 'src/libqpidcommon.so.2.0.0' failed
make[2]: *** [src/libqpidcommon.so.2.0.0] Error 1
CMakeFiles/Makefile2:1271: recipe for target 'src/CMakeFiles/qpidcommon.dir/all' failed
make[1]: *** [src/CMakeFiles/qpidcommon.dir/all] Error 2
Makefile:160: recipe for target 'all' failed
make: *** [all] Error 2
--

In both cases:

 Boost version: 1.62.0
-- Found the following Boost libraries:
--   program_options
--   system

"
Bug,QPID-7713,13057018,Clang build fails with link error,jross,jross,Resolved,Fixed,2017-10-27 14:18,C++,C++ Build,,,,,,,"{noformat}
CXX=clang++ cmake .. && make -j8
---
[100%] Linking CXX executable event_driven_list_agents
[100%] Built target qmf2_event_driven_list_agents
[100%] Linking CXX executable agent
[100%] Built target qmf2_agent
[100%] Linking CXX shared module cqmf2_ruby.so
[100%] Built target cqmf2_ruby
1 warning generated.
[100%] Linking CXX shared module _cqmf2.so
[100%] Built target _cqmf2
[100%] Linking CXX executable unit_test
/usr/bin/ld: CMakeFiles/unit_test.dir/ExchangeTest.cpp.o: undefined reference to symbol 'pthread_rwlock_init@@GLIBC_2.2.5'
/usr/lib64/libpthread.so.0: error adding symbols: DSO missing from command line
clang-3.9: error: linker command failed with exit code 1 (use -v to see invocation)
src/tests/CMakeFiles/unit_test.dir/build.make:1479: recipe for target 'src/tests/unit_test' failed
make[2]: *** [src/tests/unit_test] Error 1
CMakeFiles/Makefile2:2715: recipe for target 'src/tests/CMakeFiles/unit_test.dir/all' failed
make[1]: *** [src/tests/CMakeFiles/unit_test.dir/all] Error 2
Makefile:160: recipe for target 'all' failed
make: *** [all] Error 2

real	4m22.309s
user	25m59.212s
sys	1m3.917s
{noformat}"
Bug,QPID-7595,13029473,[C++ Windows] CMake required version is too low for installation,chug,chug,Resolved,Fixed,2017-05-24 13:38,C++,C++ Build,,,,,,,"The top level cmake lists declares

{noformat}
cmake_minimum_required(VERSION 2.8.7 FATAL_ERROR)
{noformat}

But the installation in src/msvc.cmake on Windows uses 

{noformat}
$<TARGET_PDB_FILE:${theLibrary}>
{noformat}
 
which was introduced in CMake 3.1.
"
Bug,QPID-4072,12595009,HA use backup messages in failover.,aconway,aconway,Closed,Fixed,2017-03-14 20:12,C++,C++ Clustering,,,,,,,"When a backup fails over to a new primary, it already has many/most of the messages it needs. 
ReplicatingSubscription should sync. the primary and backup queues, and not re-send messages that are already on the backup."
Bug,QPID-3901,12546779,0.16 Release issues for Windows,chug,chug,Closed,Fixed,2017-03-14 20:08,C++,C++ Client,,,,,,,"This issue collects various minor issues related to the 0.16 Release and Windows.
The expectation is that the only issues solved here are of trivial, NO-JIRA complexity."
Bug,QPID-4733,12641853,Fix cmake installation of init scripts,aconway,aconway,Closed,Fixed,2017-03-14 20:08,C++,C++ Build,,,,,,,"The cmake build does not correctly substitute and install the init scripts qpidd and qpidd-primary. 
"
Bug,QPID-4176,12600863,HA Error handling,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"Fix error handling so that backup brokers shut down on replication errors.

Previously replication errors were being thrown to the primary, breaking the replication
session. This would put the primary into an endless futile reconnect attempt.
"
Bug,QPID-4179,12600903,Cluster does not replicate exclusive status of queues.,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"To reproduce run this script:
-----
QPIDD=""qpidd --auth=no -d --cluster-name=foo -p0 --no-data-dir -t --load-module=src/.libs/cluster.so  --log-to-file""
PORTA=$($QPIDD qpiddA.log)
./examples/messaging/spout -b user/user@localhost:$PORTA ""exclQ.A; {create: sender, delete:receiver, node:{ x-declare:{ auto-delete: false, exclusive: true } } }"" ""$(date| md5sum)""
PORTB=$($QPIDD qpiddB.log)
echo $PORTA $PORTB

qpid-stat -b localhost:$PORTA -q
qpid-stat -b localhost:$PORTB -q
-----

Note the queue is exclusive in the first qpid-stat output and not in the second.

They should be the same. 
"
Bug,QPID-2785,12470825,QpidTypes.pdb is not installed,tross,chug,Closed,Fixed,2017-03-14 20:07,C++,C++ Build,,,,,,,The qpidtypes.pdb and qpidtypesd.pdb files are missing from the WinSDK.
Bug,QPID-2755,12470040,Windows SDK has no README,tross,chug,Closed,Fixed,2017-03-14 20:07,C++,C++ Documentation,,,,,,,The winsdk file is produced with no README.
Bug,QPID-4391,12613177,HA replicating subscriptions should not auto-delete queues,,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"Description of problem:
When an auto-delete queue is replicated, the replicating subscription attempts to auto-delete the queue after it has already been auto-deleted by the closing of the last non-HA consumer.  An issue occurs if a new auto-delete queue with the same name is created shortly after the deletion of the previously queue.  This can occur when a client subscribes to an auto-delete queue and is temporarily disconnected from the broker.  It is possible for the cancelled HA subscription to remove the newly created queue from the queue registry since the old and new queues use the same names.  The HA replicating subscription should not execute the auto-delete logic when the subscription is cancelled. 

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
Frequently

Steps to Reproduce:
Race condition between a consumer auto-deleting and recreating a queue of the same name and the HA replicating subscription auto-deleting the original queue.  If the HA replicating subscription auto-deletes the original queue after the new queue is created, the new queue is removed from the queue registry.
  
Actual results:
New queue is removed from the queue registry.

Expected results:
HA subscription does not attempt to auto-delete the queue and therefore the new queue is not removed from the queue registry.

Additional info: https://bugzilla.redhat.com/show_bug.cgi?id=868364"
Bug,QPID-2805,12471716,The windows resource version for qmfengine dll is hard coded to an unusable value,tross,chug,Closed,Fixed,2017-03-14 20:07,C++,C++ Build,,,,,,,"One line in the cmake for cpp/qmf.dll confuses the ""windows resource version"" that ones sees from windows explorer with the ""image version"" that is embedded in the binary optional header.

The cmake must be changed so that all dll files created by a bld-winsdk.ps1 build have the same windows resource version."
Bug,QPID-3105,12500224,Alternate-Exchange configuration not communicated between nodes in a cluster,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"When an exchange is declared with an alternate-exchange, the alternate-exchange is not communicated to new members joining the cluster.

See https://bugzilla.redhat.com/show_bug.cgi?id=681331
"
Bug,QPID-3198,12503945,Clustered broker should exit on unknown connection.,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"A clustered broker that receives data for an unknown connection currently logs a debug message and drops the data.

The broker should exit, as the existence of an unknown connection means it is out of sync with respect to other brokers in the cluster."
Bug,QPID-2266,12443142, error sending update: Enqueue capacity threshold exceeded,aconway,aconway,Closed,Fixed,2017-03-14 20:07,C++,C++ Clustering,,,,,,,"From https://bugzilla.redhat.com/show_bug.cgi?id=509796
Description of problem:

Adding a new node to a cluster failed with a journal capacity exception.
However the new node was using the default journal size options as was the
existing cluster node so its not clear why this error should occur.

Version-Release number of selected component (if applicable):

qpidd-0.5.752581-22.el5
rhm-0.5.3206-5.el5

How reproducible:

Fairly easily

Steps to Reproduce:
1. start one cluster node
2. run  while perftest --durable true --count 50000 --size 8 --summary; do
true; done
3. while this is running add a new node to the cluster, then stop it, then
re-add it and repeat this for several times until eventually you see an error

Actual results:

2009-jul-06 05:07:10 notice Journal ""perftest0"": Created
2009-jul-06 05:07:11 warning Journal ""perftest0"": Enqueue capacity threshold
exceeded on queue ""perftest0"".
2009-jul-06 05:07:11 error Unexpected exception: Enqueue capacity threshold
exceeded on queue ""perftest0"". (JournalImpl.cpp:576)
2009-jul-06 05:07:11 error Connection 10.16.44.221:46092 closed by error:
Enqueue capacity threshold exceeded on queue ""perftest0"".
(JournalImpl.cpp:576)(501)
2009-jul-06 05:07:11 error Channel exception: not-attached: Channel 1 is not
attached (qpid/amqp_0_10/SessionHandler.cpp:40)
2009-jul-06 05:07:11 critical 10.16.44.221:19499(UPDATEE) catch-up connection
closed prematurely 10.16.44.221:19499-1(local,catchup)
2009-jul-06 05:07:11 notice 10.16.44.221:19499(LEFT) leaving cluster
grs-mrg14-test-cluster
2009-jul-06 05:07:11 notice Shut down


Expected results:

Should always be able to add the new node since the queue on the original node
in the cluster has the same capacity.

"
Bug,QPID-2764,12470285,WinSdk cpp examples do not compile,tross,chug,Closed,Fixed,2017-03-14 20:07,C++,C++ Client,,,,,,,The vcproj files for the \examples directory are missing a reference to the relatively new qpidtypes.lib. 
Bug,QPID-5336,12678887,Script interpreters need to be found on the path and not have hardcoded locations,astitcher,astitcher,Closed,Fixed,2017-03-14 19:51,C++,C++ Tests,,,,,,,"The qpid test scripts will not run under FreeBSD because they have a hardcoded notion that bash is found at /bin/bash. However under FreeBSD it is actually found in /usr/local/bin/bash.

We need to change the line which says {{""\#\!/bin/bash""}} to {{""\#\!/usr/bin/env bash""}}

There are actually a small number of places where other script interpreters have their location hardcoded too - python. ruby and perl. These all need to be {{""\#\!/usr/bin/env ...""}}.

The *only* script interpreter (that we use) that can be hardcoded is {{/bin/sh}} as this is its guaranteed location."
Bug,QPID-4535,12627471,Cmake build is broken by default since legacy store enabled,chug,astitcher,Closed,Fixed,2017-03-14 19:42,C++,C++ Build,,,,,,,"The cmake build doesn't check if libaio is available before enabling the legacy store so unless you have the libraries and headers installed the build breaks.

This will be a particular problem on non Linux systems that don't have these libraries available at all."
Bug,QPID-4955,12654961,"CMake ""make install"" puts config files inthe wrong place",astitcher,astitcher,Closed,Fixed,2017-03-14 19:42,C++,C++ Build,,,,,,,"Since the fix for QPID-4698. We've been putting the client/broker config files in different places and not where the build tells the executables to look for the config files:

* qpidc.conf in <prefix>/etc/qpid/qpidc.conf
* qpidd.conf in <prefix>/etc/qpidd.conf

*The correct place is <prefix>/etc/qpid/ for both.*

The executables are being told to look in <prefix>/etc for the config files which is incorrect."
Bug,QPID-5829,12721592,Swigged bindings code does not link on windows,astitcher,astitcher,Closed,Fixed,2017-03-14 19:42,C++,C++ Build,,,,,,,"Until very recently the swigged bindings code was not built on windows. When it was built it became apparent that some of the modules did not link because of missing symbols due to required libraries not linked into the final loadable module.

The real cause of this bug is that the compile options for these modules did not ensure that all symbols were resolved in them, which should be the case on Unix platforms too. If this issue had been spotted on Unix it need not have arisen on Windows."
Bug,QPID-5262,12675981,Install debug versions of MS runtime DLLs,chug,astitcher,Closed,Fixed,2017-03-14 19:42,C++,C++ Build,,,,,,,Currently we are installing the non debug version only which is not very useful if you are making a debug build
Bug,QPID-5631,12701714,Adjust Cmake build files to change in detecting proton,astitcher,astitcher,Closed,Fixed,2017-03-14 19:42,C++,C++ Build,,,,,,,Need to adjust the qpid proton detection logic to allow for the differences in the cmake files exported by proton in the 0.7 version.
Bug,QPID-4498,12623288,HA module should only initialize if requested,,aconway,Closed,Fixed,2017-03-14 19:34,C++,C++ Clustering,,,,,,,"The HA module formerly loaded and initialized even if there were no --ha options set. This can cause conflicts with other modules, in particular the old active-active cluster module (see https://bugzilla.redhat.com/show_bug.cgi?id=885658)

This patch initializes the HA module only if one of --ha-cluster or --ha-queue-replication is set.
--ha-cluster has the same meaning as before. --ha-queue-replication enables queue replication without joining a cluster - this was the old behaviour if no --ha options were set."
Bug,QPID-4944,12654168,HA Sporadic failure in ha_tests:  test_failover_send_receive and test_expected_backup_timeout,aconway,aconway,Closed,Fixed,2017-03-14 19:34,C++,C++ Clustering,,,,,,,"Rare sporadic failures in:

ha_tests.RecoveryTests.test_expected_backup_timeout
  AssertionError: 'recovering' != 'active

ha_tests.LongTests.test_failover_send_receive  
  AssertionError: Broker<006:cluster1-1.log qpidd-26 :44493> expected='ready', actual='catchup'


To reproduce you need to run ha_tests.py in a loop overnight or longer.

See also: https://bugzilla.redhat.com/show_bug.cgi?id=969039"
Bug,QPID-4787,12645252,HA brokers find self-address in brokers_url.,aconway,aconway,Closed,Fixed,2017-03-14 19:34,C++,C++ Clustering,,,,,,,"HA brokers need to know their own addresses, but it is not safe to simply use
local hosts name and Broker::getPort() since the broker may be listening on
multiple addresses. The solution is to have brokers check the ha-rokers-url for their own address while doing the initial status check of the cluster.

"
Bug,QPID-4506,12623988,Qpid HA's '--ha-public-url' option duplicates the '--known-hosts-url' option but cannot be disabled,,aconway,Closed,Fixed,2017-03-14 19:34,C++,C++ Clustering,,,,,,,"This commit simplifies the semantics of setting
--ha-public-url and --ha-brokers-url.  There is no longer any over-riding or
implicit updating of values. That means you must set --ha-public-url as well as
--ha-brokers-url, it will not be defaulted.  Likewise if you *dont* set
ha-public-url, it will remain empty, which is the use case in this bug.

The defaulting was adding complexity without adding much value.

"
Bug,QPID-7693,13049000,SSL client socket leaks a file descriptor,gsim,gsim,Resolved,Fixed,2017-03-14 19:05,C++,C++ Client,,,,,,,"A prototype socket is create for every client ssl socket, even though that prototype socket is actually only needed/used for server sockets. The prototype socket is not closed when the SslSocket instance is closed."
Bug,QPID-2520,12462559,Broken POM generation on Windows,robbie,ebourg,Closed,Fixed,2017-03-13 12:44,C++,C++ Tools,Java Build,,,,,,"The genpom script doesn't work on Windows. Calling ""ant pom"" gives the following stacktrace :

{code}
pom:
     [java] Traceback (most recent call last):
     [java]   File ""C:\dev\apache\qpid\java/genpom"", line 95, in <module>
     [java]     pom = search(expanded_path, ""%s.pom"" % base)
     [java]   File ""C:\dev\apache\qpid\java/genpom"", line 83, in search
     [java]     return mllib.xml_parse(f)
     [java]   File ""C:\dev\apache\qpid\python\mllib\__init__.py"", line 79, in xml_parse
     [java]     p.parse(source)
     [java]   File ""C:\dev\apache\qpid\java\lib\jython-2.5.0.jar\Lib\xml\sax\drivers2\drv_javasax.py"", line 141, in parse
     [java]     at java.io.FileInputStream.open(Native Method)
     [java]     at java.io.FileInputStream.<init>(FileInputStream.java:106)
     [java]     at java.io.FileInputStream.<init>(FileInputStream.java:66)
     [java]     at sun.net.www.protocol.file.FileURLConnection.connect(FileURLConnection.java:70)
     [java]     at sun.net.www.protocol.file.FileURLConnection.getInputStream(FileURLConnection.java:161)
     [java]     at com.sun.org.apache.xerces.internal.impl.XMLEntityManager.setupCurrentEntity(XMLEntityManager.java:653)
     [java]     at com.sun.org.apache.xerces.internal.impl.XMLVersionDetector.determineDocVersion(XMLVersionDetector.java:186)
     [java]     at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:772)
     [java]     at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
     [java]     at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)
     [java]     at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)
     [java]     at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)
     [java]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     [java]     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
     [java]     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
     [java]     at java.lang.reflect.Method.invoke(Method.java:597)
     [java]
     [java] java.io.FileNotFoundException: java.io.FileNotFoundException: C:\dev\apache\qpid\java\common\dev\apache\qpid\java\lib\poms\slf4j-api-1.4.0.pom (Le chemin d'acc챔s sp챕cifi챕 est introuvable)
{code}

It works fine on Linux
"
Bug,QPID-2851,12473702,Programming with Apache Qpid doc confusing over confirmations,,whenry,Closed,Fixed,2017-03-13 12:01,C++,C++ Documentation,,,,,,,"Section on Sender Capacity and Replay says:

""A synchronous send call will block until the broker has confirmed receipt of the message."" This sounds like the confirmation is received when the broker has received the message on an exchange or you could possibly interpret it as delivered on a queue.

Then:
""The sender can be queried for the available space (i.e. the unused capacity), and for the current count of unsettled messages (i.e. those held in the queue pending confirmation by the server). When the unsettled count is zero, all messages on that sender have been successfully sent. ""

This makes it sound like confirmations are when a/all receiver(s) has received the messages from a queue.
Are there two confirmations?

It seems this section needs to be more explicit on types of confirmations and confirmation events.

e.g. in some sense there is also the idea of a blocked call when sending (synch or asyn) which is in itself a kind of confirmation. e.g. if I have a successful unblocked send in synch or asynh mode doesn't that imply that the broker has received the message?"
Bug,QPID-2701,12468095,"""Programming in Apache Qpid"" sect 4.2 has a broken link to Section 13",,shuston,Closed,Fixed,2017-03-13 12:01,C++,C++ Documentation,,,,,,,"Reading ""Programming in Apache Qpid"" html version, section 4.2 ""Subjects"" has a link named Section 13, ""The AMQP 0-10 mapping"" with a target url that doesn't exist (gets 404 error when clicked) http://qpid.apache.org/books/0.7/Programming-In-Apache-Qpid/html/ch02s13.html
"
Bug,QPID-5751,12712849,File qpid/cpp/RELEASE_NOTES is out of date,,chug,Closed,Fixed,2017-03-13 11:58,C++,C++ Documentation,,,,,,,"This file has stale content last updated for release 0.8. Keeping a file like this up to date for a release is difficult since the contents keep changing as the release drags out with more and more inclusions.

This file could be disposed in two ways:

* The file, along with the sole reference to it in cpp/README.txt, could be deleted . 
* Its content could be replaced with a reference to http://qpid.apache.org/releases/ where there is a wealth of autogenerated and  up-to-date release information."
Bug,QPID-2948,12480019,Generated API docs have extraneous macro names in method signatures,shuston,shuston,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,"The doxygen-generated docs for the qpid::messaging and qmf classes have the DLL-exporting macros in the generated documentation. The doxygen options (user.doxygen.in and developer.doxygen.in) predefine these macros for the other libs so that the names don't appear in the generated documentation, but these new libraries weren't added to the list of macros.
"
Bug,QPID-2358,12446374,SVN conflict,jonathan.robie,bmm,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,"Subversion checkout has a conflict with the files: http://svn.apache.org/repos/asf/qpid/trunk/qpid/doc/book/src/AMQP Compatibility.xml and http://svn.apache.org/repos/asf/qpid/trunk/qpid/doc/book/src/AMQP compatibility.xml.

Could you please see that?

Thank you!

Regards."
Bug,QPID-2553,12463091,CMakeLists wrong file name ,shuston,bmm,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,In cpp/docs/api/CMakeLists.txt: 29 the file name is typed incorrectly.
Bug,QPID-5548,12693985,C++ Messaging API does not specify the connection Connection URL format,chug,chug,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,"The Programming In Apache Qpid documentation never discusses the format of the Connection URL string, the only required argument for constructing a Messaging Connection. The URL is specified by AMPQ 0.10:
{noformat}
amqp_url = ""amqp:"" prot_addr_list
prot_addr_list = [prot_addr "",""]* prot_addr
prot_addr = tcp_prot_addr | tls_prot_addr

tcp_prot_addr = tcp_id tcp_addr
tcp_id = ""tcp:"" | """"
tcp_addr = [host ["":"" port] ]
host = <as per http://www.ietf.org/rfc/rfc3986.txt>
port = number
{noformat}

The C++ Messaging connection string is not the same as the JMS Connection
http://qpid.apache.org/releases/qpid-0.24/programming/book/QpidJNDI.html#section-jms-connection-url

This issue tracks adding a few lines to the documentation describing the connection format.
"
Bug,QPID-6668,12850349,[C++] INSTALL-WINDOWS is out of date,chug,chug,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,Again.
Bug,QPID-4337,12608530,qpid-tools' SSL support for systems with python < 2.6 is broken,kgiusti,kgiusti,Closed,Fixed,2017-03-12 14:06,C++,C++ Tools,Python Client,,,,,,"Since release 2.6, python's SSL support is based on OpenSSL.  Prior to 2.6, it was based on a more-limited implementation.

It appears that this earlier implementation may fail to connect when the underlying socket is configured as non blocking, or configured with a timeout.

This causes some of the qpid tools to fail to connect when used with SSL.  For example, qpid-config.

Also, the use of the older version of SSL's client-authentication appears to be broken."
Bug,QPID-6191,12751004,Unable to communicate to Windows Azure using qpid messaging,,rajvael,Closed,Fixed,2016-12-09 20:31,C++,C++ Examples,,,,,,,"import sys
from qpid.messaging import *

if len(sys.argv)<2:
  broker =  ""***namespace***.servicebus.windows.net""
else:
  broker = sys.argv[1]

if len(sys.argv)<3: 
  address = ""**queuename**"" 
else:
  address = sys.argv[2]

connection = Connection(broker)
connection.username = ""owner""
connection.password = ""****passwordkey****""
connection.protocol = ""amqp1.0""
try:
  connection.open()
  session = connection.session()

  sender = session.sender(address)
  receiver = session.receiver(address)

  sender.send(Message(""Hello world!""));

  message = receiver.fetch()
  print message.content
  session.acknowledge()

except MessagingError,m:
  print m

connection.close()

I have tried the above code to send message to Azure queue. But I got ""client: 0-10, server: 0-0"" when open a connection. Please anyone help me."
Bug,QPID-4273,12605636,qpid-cpp Makefile for swig bindings overwrites DESTDIR,,travisghansen,Closed,Fixed,2016-12-09 20:00,C++,C++ Build,,,,,,,"The build system's DESTDIR value is being ignore due to the use of DESTDIR=$(prefix) in the Makefile.  There are 2 effects of this...

1. prefix becomes double accounted for so it's trying to install to /usr/usr in my case
2. we're writing to the live filesystem instead of the sandbox which makes the build fail"
Bug,QPID-7501,13019158,[AMQP 1.0] sessions and links should be freed under lock,gsim,gsim,Resolved,Fixed,2016-11-09 21:30,C++,C++ Client,,,,,,,"For active connections, sessions and links should be freed under the connection lock to prevent concurrent access to the underlying proton structure(s)."
Bug,QPID-7500,13019157,[AMQP 1.0] session close is not synchronous,gsim,gsim,Resolved,Fixed,2016-11-09 19:51,C++,C++ Client,,,,,,,The method should block until peer confirms close.
Bug,QPID-7494,13017863,Invocation of check_dependencies.py fails on CMake 2.8.11,jross,jross,Resolved,Fixed,2016-11-04 0:07,C++,C++ Broker,C++ Client,,,,,,"This annoying issue is discussed here: https://public.kitware.com/Bug/view.php?id=13887 .

It's a bug introduced in cmake 2.8.10 and resolved in 2.8.12.  RHEL 7's cmake version is 2.8.11."
Bug,QPID-7415,13002778,"[AMQP 1.0]: reject, release & modified ignored by qpid::messaging",gsim,gsim,Resolved,Fixed,2016-10-10 19:46,C++,C++ Client,,,,,,,At present the client only logs warnings as it has no good way to communicate the status in the asynchronous model.
Bug,QPID-7182,12955682,[C++ broker] high CPU usage on backup brokers following QPID-7149 scenario,aconway,pmoravec,Closed,Fixed,2016-09-08 10:04,C++,C++ Clustering,,,,,,,"Following scenario from QPID-7149 with --ha-replicate=all, with whatever patch fixing it applied or not, CPU usage of backup brokers grow over the time.

gdb shows one active thread always with backtrace:

{noformat}
#0  0x00007f9295fc9c98 in find (this=0x7f9270055840, data=<value optimized out>)
    at /usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/tr1_impl/hashtable:786
#1  qpid::ha::QueueReplicator::dequeueEvent (this=0x7f9270055840, data=<value optimized out>)
    at /data_xfs/qpid/cpp/src/qpid/ha/QueueReplicator.cpp:306
#2  0x00007f9295fca82b in operator() (this=0x7f9270055840, deliverable=<value optimized out>)
    at /usr/include/boost/function/function_template.hpp:1013
#3  qpid::ha::QueueReplicator::route (this=0x7f9270055840, deliverable=<value optimized out>)
    at /data_xfs/qpid/cpp/src/qpid/ha/QueueReplicator.cpp:329
#4  0x00007f9296b9b854 in qpid::broker::SemanticState::route (this=0x7f927001d088, msg=..., strategy=...)
    at /data_xfs/qpid/cpp/src/qpid/broker/SemanticState.cpp:506
#5  0x00007f9296bb8ab7 in qpid::broker::SessionState::handleContent (this=0x7f927001cec0, frame=<value optimized out>)
    at /data_xfs/qpid/cpp/src/qpid/broker/SessionState.cpp:233
#6  0x00007f9296bb90a1 in qpid::broker::SessionState::handleIn (this=0x7f927001cec0, frame=...)
    at /data_xfs/qpid/cpp/src/qpid/broker/SessionState.cpp:293
#7  0x00007f92965d4c31 in qpid::amqp_0_10::SessionHandler::handleIn (this=0x7f927002fbb0, f=...)
    at /data_xfs/qpid/cpp/src/qpid/amqp_0_10/SessionHandler.cpp:93
#8  0x00007f9296b29a2b in operator() (this=0x7f9270002060, frame=...) at /data_xfs/qpid/cpp/src/qpid/framing/Handler.h:39
#9  qpid::broker::ConnectionHandler::handle (this=0x7f9270002060, frame=...)
    at /data_xfs/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp:93
#10 0x00007f9296b247e8 in qpid::broker::amqp_0_10::Connection::received (this=0x7f9270001e80, frame=...)
    at /data_xfs/qpid/cpp/src/qpid/broker/amqp_0_10/Connection.cpp:198
#11 0x00007f9296ab2863 in qpid::amqp_0_10::Connection::decode (this=0x7f92700018b0, buffer=<value optimized out>, 
    size=<value optimized out>) at /data_xfs/qpid/cpp/src/qpid/amqp_0_10/Connection.cpp:59
#12 0x00007f92965fdca0 in qpid::sys::AsynchIOHandler::readbuff (this=0x7f92700009b0, buff=0x7f9270001880)
    at /data_xfs/qpid/cpp/src/qpid/sys/AsynchIOHandler.cpp:138
#13 0x00007f929657be89 in operator() (this=0x7f9270000a50, h=...) at /usr/include/boost/function/function_template.hpp:1013
#14 qpid::sys::posix::AsynchIO::readable (this=0x7f9270000a50, h=...) at /data_xfs/qpid/cpp/src/qpid/sys/posix/AsynchIO.cpp:453
#15 0x00007f92966025b3 in boost::function1<void, qpid::sys::DispatchHandle&>::operator() (this=<value optimized out>, 
    a0=<value optimized out>) at /usr/include/boost/function/function_template.hpp:1013
#16 0x00007f9296601246 in qpid::sys::DispatchHandle::processEvent (this=0x7f9270000a58, type=qpid::sys::Poller::READABLE)
    at /data_xfs/qpid/cpp/src/qpid/sys/DispatchHandle.cpp:280
#17 0x00007f92965a1d1d in process (this=0x7961c0) at /data_xfs/qpid/cpp/src/qpid/sys/Poller.h:131
..
{noformat}

or with:

{noformat}
#0  0x00000032c4c0a7b0 in pthread_mutex_unlock () from /lib64/libpthread.so.0
#1  0x00007fb0958038fa in qpid::sys::Mutex::unlock (this=<value optimized out>) at /data_ext4/qpid/cpp/src/qpid/sys/posix/Mutex.h:120
#2  0x00007fb095840628 in ~ScopedLock (this=0x112cfd0, data=<value optimized out>) at /data_ext4/qpid/cpp/src/qpid/sys/Mutex.h:34
#3  qpid::ha::QueueReplicator::dequeueEvent (this=0x112cfd0, data=<value optimized out>)
    at /data_ext4/qpid/cpp/src/qpid/ha/QueueReplicator.cpp:308
..
{noformat}

Not sure where the busy loop origins."
Bug,QPID-6308,12766869,[C++ Messaging] Server example never sends utf8 responses,chug,chug,Closed,Fixed,2016-09-06 21:33,C++,C++ Client,,,,,,,"Qpid C++ Messaging and Amqp.Net Lite have some issues interoperating.

* Amqp.Net Lite encodes/decodes strings with binary encoding primitive 
** str8-utf8 0xA1

* Qpid C++ Server decodes received str8-utf8 0xA1 strings ok but sends all replies with
** vbin8 0xA0

* Qpid C++ Client always sends strings as
** vbin8 0xA0

Modifying the Server example to:
{noformat}
    Message response;
    response.setContentObject( request.getContentObject() );
    sender.send(response);
{noformat}

preserves the str8-utf8 encoding in the response but doesn't process the message.

The server example would be improved if it generated utf8 replies to utf8 requests.
"
Bug,QPID-7233,12963449,qpid-receive uses 0 prefetch unless an explicit message count is provided,gsim,gsim,Closed,Fixed,2016-09-06 21:33,C++,C++ Client,,,,,,,"Error introduced as part of https://svn.apache.org/viewvc/qpid/trunk/qpid/cpp/src/tests/qpid-receive.cpp?r1=1662743&r2=1662742&pathrev=1662743.

The capacity should not exceed the message count, but if the message count is zero and the capacity is not, the capacity specified should be used. As it is now there is no way to get unlimited messages with a non-zero capacity.

I've marked this against the client but its really just the test tool that is affected; there did not seem to be a better component to mark it against."
Bug,QPID-6767,12902134,qpidd tools don't allow sasl service name to be changed,kgiusti,gsim,Closed,Fixed,2016-09-06 21:33,C++,C++ Tools,,,,,,,"QPID-6532 made the sasl service name that qpidd uses configurable. However if this is changed then the python based cli tools are unable to use mechanisms that rely on it (e.g. DIGEST-MD5, GSSAPI) as they have no way to configure the service name used from the 'qpidd' default."
Bug,QPID-7234,12963451,client does not update credit for expired messages,gsim,gsim,Closed,Fixed,2016-09-06 21:33,C++,C++ Client,,,,,,,"Messages that expire on the client, i.e. after being received from the server but before being fetched by the application, do not result in the credit window being moved (or in a new credit being issued in the case of capacity 0).

The expiration of messages on the client was added for QPID-5828."
Bug,QPID-7357,12990459,c++ HA Backup crash during re-connect in failover,aconway,aconway,Closed,Fixed,2016-09-06 21:33,C++,C++ Broker,C++ Clustering,,,,,,"A backup creates an UpdateTracker to delete non-existent queues at the end of an update, in the UpdateTracker destructor. However if an update is interrupted, it can leave a partially-used UpdateTracker behind. When the next update starts this can incorrectly delete queues at a sensitive moment and cause a crash.

See also https://bugzilla.redhat.com/show_bug.cgi?id=1333767"
Bug,QPID-6966,12924892,C++ broker and client to support TLS1.1 and TLS1.2 by default,pmoravec,pmoravec,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"Description of problem:
Currently, neither C++ client or broker allows TLS1.1 or TLS1.2 protocol versions. Please enable it, esp. since Java client 6.1 will disable TLS1.0 and use 1.1 and 1.2 only.


Version-Release number of selected component (if applicable):
qpid-cpp-server-0.34-5.el6.x86_64
qpid-cpp-client-0.34-5.el6.x86_64


How reproducible:
100%


Steps to Reproduce:
1. Start qpid broker with SSL configured
2. openssl s_client -tls1_1 -connect localhost:5671
3. openssl s_client -tls1_2 -connect localhost:5671


Actual results:
Both 2 and 3 fails with:

{noformat}
139817551390536:error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number:s3_pkt.c:337:
{noformat}


Expected results:
Both should return something like:

{noformat}
CONNECTED(00000003)
depth=0 CN = localhost
verify error:num=18:self signed certificate
verify return:1
depth=0 CN = localhost
verify return:1
140319888385864:error:14094412:SSL routines:SSL3_READ_BYTES:sslv3 alert bad certificate:s3_pkt.c:1256:SSL alert number 42
140319888385864:error:1409E0E5:SSL routines:SSL3_WRITE_BYTES:ssl handshake failure:s3_pkt.c:596:
---
Certificate chain
 0 s:/CN=localhost
   i:/CN=localhost
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIBoDCCAQmgAwIBAgIFAKUDcMswDQYJKoZIhvcNAQEFBQAwFDESMBAGA1UEAxMJ
bG9jYWxob3N0MB4XDTE1MTIzMDExMDYwN1oXDTE2MDMzMDExMDYwN1owFDESMBAG
A1UEAxMJbG9jYWxob3N0MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCgCq6w
o6FW7gIpAQu8y74wuREH6aGo6hc6YVfATz503o7dxqmUUKs6+DkqbEiDu43r51QL
Sb7oduLMmrvC5TfhWEZGe3PYPOuCBbpqDxXs5kKlqSCuIbvDv1ua1WXdqb27/jGr
d6Lf+DsnU+GXrGwLY1W1zchagmFU1P2dLh8JhQIDAQABMA0GCSqGSIb3DQEBBQUA
A4GBACUauXrJB/P0za8mPj5As4uQ3kr7CHIAtFBEAd3MvVmf9RHniMU/resXeE1B
CBOZ4kXmTvVQ+/kDxYTXO/pLq0wh4HHuZC4LrmlIHG2WagEskVnYgqJiHUchKi+8
URu/CX4rW6/EdcAHhPsKX6nlHFFKYg5u9b9ZtQHYMrfryStZ
-----END CERTIFICATE-----
subject=/CN=localhost
issuer=/CN=localhost
---
Acceptable client certificate CA names
/CN=dummy
---
SSL handshake has read 565 bytes and written 202 bytes
---
New, TLSv1/SSLv3, Cipher is AES128-GCM-SHA256
Server public key is 1024 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : AES128-GCM-SHA256
    Session-ID: 7D6C1CB53B37700F2BF007D0D079AB72F26A9D289BCA8D98B5B3F1E283311991
    Session-ID-ctx: 
    Master-Key: 448215BEAADBFF90B82B421D182F8AD7174426D9292835775C405A7C3AEC2763E5F2A1127E5AE210ADC6B7335EE1F6FA
    Key-Arg   : None
    Krb5 Principal: None
    PSK identity: None
    PSK identity hint: None
    Start Time: 1451483784
    Timeout   : 7200 (sec)
    Verify return code: 18 (self signed certificate)
---
{noformat}

Additional info:"
Bug,QPID-7376,12994634,fetch with capacity=0 can hang or timeout if fetched message expires client-side,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,,,,,,,"This is a special case of QPID-7234 where there is no prefetch. If a messages received from the broker as part of a fetch is expired on the client, the call won't complete but neither will the credit be issued, and so the call will either hang or timeout."
Bug,QPID-7393,12996942,Unavailable buffers in Windows SSL,cliffjansen,cliffjansen,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"From the user list (acartcat Cartwright_Andrew@cat.com):

> I get the following error in the broker, looks like the same error as
> QPID-5033.
[...]
> 2016-05-26 05:22:23 [System] error No IO buffers available: getQueuedBuffer
> with empty queue. Debug data: 0 1 0 3 0 0 1
[...]
> This can be triggered on demand using:
> qpid-send -b ssl:XXXXXXXX.com:5671 --connection-options {protocol:amqp1.0}
> -a testerq --content-string=hello --messages 200

In my testing, qpid-send must also be Windows based.  I do not see the error
if it is sent from a client running on Linux.

This error is caused by the SChannel driver generating (valid but
useless) empty SSL packets when a zero length write is requested from
the codec on the client side.  On the server side, these are
processed and empty read callbacks are generated, even after close.

The WSAENOBUFS happens as a side effect of recursive calls to
sslDataIn while processing adjacent empty packets.

"
Bug,QPID-7145,12950854,auto_ptr is deprecated from C++11 and onwards and its use causes a warning with GCC 6,astitcher,astitcher,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"As we compile qpid with warnings turned to errors this causes the build to fail by default when compiling with GCC6.

The simplest ""fix"" is just to turn of deprecation warnings.

A better fix would be to stop using auto_ptr. An good alternative in the context of qpid would be boost::scoped_ptr.

If we change the base C++ version for qpid we could use std::unique_ptr instead."
Bug,QPID-7302,12979297,race between auto-delete and re-declare/consume ,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"In AMQP 0-10, declare and consume are two distinct operations. When creating a receiver through qpid::messaging, we first declare then consume from the queue.

For a timed auto-delete queue, the delayed auto-delete can tae place between the declare and the consume, resulting in a session error. It would be nice to avoid this. The workaround of course is to set the delay for auto-delete to be sufficiently large that the client will either have reconnected or is likely not reconnecting.

However a simple solution would be to reset the timer on the declare, allowing time for the consume.

This does not prevent the race between a non-timed auto-delete triggered by one session and declare/consume from a different client connection."
Bug,QPID-7361,12992379,[AMQP-1.0] sender sometimes waits for credit without flushing buffered transfers to disk,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,,,,,,,E.g. against dispatch router use qpid-receive with --ack-frequency of 200 (where dispatch router is setting link credit window to 250). Then send with qpid-send. With tracing on you can observe that the sender sometimes stalls until a heartbneat is sent at which point buffered transfer are written out.
Bug,QPID-5855,12723986,"JAVA Client Can not recieve message with qpid ha cluster ""Session exception occured while trying to commit""",aconway,aconway,Closed,Fixed,2016-09-06 21:32,C++,C++ Clustering,JMS AMQP 0-x,,,,,,"Description of problem:

the java client can not recieve message in qpid ha cluster
but drain message is work fine 
if i remove ha cluster ,all are OK


2014-05-09 00:20:18,695 WARN  [org.springframework.jms.listener.DefaultMessageListenerContainer] Execution of JMS message listener failed, and no ErrorHandler has been set.
""javax.jms.JMSException: Session exception occured while trying to commit: timed out waiting for sync: complete = 8, point = 10
	at org.apache.qpid.client.AMQSession.toJMSException(AMQSession.java:3465)
	at org.apache.qpid.client.AMQSession.commit(AMQSession.java:843)
	at org.springframework.jms.support.JmsUtils.commitIfNecessary(JmsUtils.java:217)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.commitIfNecessary(AbstractMessageListenerContainer.java:575)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:481)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1058)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1050)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:947)
	at java.lang.Thread.run(Thread.java:722)
Caused by: org.apache.qpid.transport.SessionException: timed out waiting for sync: complete = 8, point = 10
	at org.apache.qpid.transport.Session.sync(Session.java:867)
	at org.apache.qpid.transport.Session.sync(Session.java:837)
	at org.apache.qpid.transport.Session.invoke(Session.java:789)
	at org.apache.qpid.transport.Session.invoke(Session.java:627)
	at org.apache.qpid.transport.SessionInvoker.txCommit(SessionInvoker.java:145)
	at org.apache.qpid.client.AMQSession_0_10.commitImpl(AMQSession_0_10.java:1037)
	at org.apache.qpid.client.AMQSession.commit(AMQSession.java:830)
	... 9 more
Version-Release number of selected component (if applicable):


How reproducible:


Steps to Reproduce:
1.
2.
3.

Actual results:
throw excpeion

Expected results:
no exception


Additional info:
[reply] [??  Private Comment 1 masterQi@126.com 2014-05-08 12:37:17 EDT
there are manay qpid-ha tx queue


qpid: list
Summary of Objects by Type:
    Package                      Class         Active  Deleted
    ============================================================
    org.apache.qpid.broker       binding       17      0
    org.apache.qpid.broker       broker        1       0
    org.apache.qpid.broker       memory        1       0
    org.apache.qpid.broker       system        1       0
    org.apache.qpid.ha           habroker      1       0
    org.apache.qpid.legacystore  store         1       0
    org.apache.qpid.broker       subscription  8       0
    org.apache.qpid.broker       connection    3       0
    org.apache.qpid.legacystore  journal       2       0
    org.apache.qpid.broker       session       4       0
    org.apache.qpid.broker       queue         42      0
    org.apache.qpid.broker       exchange      9       0
    org.apache.qpid.broker       vhost         1       0
qpid: list queue
Object Summary:
    ID   Created   Destroyed  Index
    ==================================================================================================================================================================================
    132  16:01:41  -          org.apache.qpid.broker:queue:log
    133  16:01:41  -          org.apache.qpid.broker:queue:meizu.game.order.notify
    134  16:34:38  -          org.apache.qpid.broker:queue:qmfc-v2-GZ-GAME-19.65.19797.1
    135  16:34:38  -          org.apache.qpid.broker:queue:qmfc-v2-hb-GZ-GAME-19.65.19797.1
    136  16:34:38  -          org.apache.qpid.broker:queue:qmfc-v2-ui-GZ-GAME-19.65.19797.1
    137  16:01:52  -          org.apache.qpid.broker:queue:qpid.bridge_queue_qpid.broker-replicator.bridge.55f21fec-fb5d-49e2-92e3-45c3b8c6a31f_58b2be25-5a48-4691-8dcb-2f05e22af240
    138  16:25:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:050dee8e-eb28-43ae-8853-6b8774ec467a
    139  16:31:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:16df28dd-47f0-4a39-a96f-c7e07fd79c05
    140  16:28:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:1b2d1353-8c42-484b-b231-25964a5f6453
    141  16:16:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:26239421-986e-4dc3-b22a-243e44d36a40
    142  16:01:53  -          org.apache.qpid.broker:queue:qpid.ha-tx:2dfbb304-2020-464a-a14f-c87418956867
    143  16:01:53  -          org.apache.qpid.broker:queue:qpid.ha-tx:2e54c358-c200-4d4e-b4ac-ef8edb7c6b9d
    144  16:16:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:30815be3-714d-4e4b-9733-b61359120ac3
    145  16:14:12  -          org.apache.qpid.broker:queue:qpid.ha-tx:31521fd7-5308-4a08-8882-bd8aefa0050e
    146  16:25:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:34fe2710-9243-4884-8abb-85ab54685b1e
    147  16:34:19  -          org.apache.qpid.broker:queue:qpid.ha-tx:4c4dcb65-7a2c-4ee0-92a1-567da5ae5aba
    148  16:01:53  -          org.apache.qpid.broker:queue:qpid.ha-tx:5b0fa3f5-264c-4477-b6a0-46c0b39a6a79
    149  16:19:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:5b8eb722-1a3d-4c46-97b1-26b108703044
    150  16:12:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:6457ac02-fcb7-4144-b0c2-3339cfa2cf4f
    151  16:04:54  -          org.apache.qpid.broker:queue:qpid.ha-tx:701ac0c7-b3fd-41da-8832-70dc700cf0f3
    152  16:31:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:70b0f4a0-2de0-49f7-ad6b-08506dbd211f
    153  16:09:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:7b171b6a-8f17-4519-9fe5-204fc5626529
    154  16:34:25  -          org.apache.qpid.broker:queue:qpid.ha-tx:7c003fc5-9986-4598-8950-c409ff86b709
    155  16:09:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:7c6c8f9a-8eab-4446-9bc2-50deaf66d627
    156  16:15:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:80c0e04c-5f80-4f75-95ba-81091292cd4d
    157  16:12:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:8c3aea7e-f333-48c8-829b-564f89d600ba
    158  16:22:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:a11e7cbd-d5c0-4a50-b94d-d6bd8f36d8bc
    159  16:17:12  -          org.apache.qpid.broker:queue:qpid.ha-tx:ad1ab060-2a6f-41e8-80c2-16aabdfcf8de
    160  16:28:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:b0454339-4759-44de-906f-d1bf3465a2cb
    161  16:10:00  -          org.apache.qpid.broker:queue:qpid.ha-tx:b4c5ad63-ec07-4619-b45c-35593894e072
    162  16:04:54  -          org.apache.qpid.broker:queue:qpid.ha-tx:d57c3e52-8f65-44e4-9595-6e8440d39978
    163  16:19:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:da34735a-6e9c-44c0-bd8c-c8368ab74912
    164  16:22:18  -          org.apache.qpid.broker:queue:qpid.ha-tx:dad4938e-7308-4c9e-b648-49494da41682
    165  16:04:54  -          org.apache.qpid.broker:queue:qpid.ha-tx:e82f5575-9e2b-4567-be77-fb2a766fa74b
    166  16:07:54  -          org.apache.qpid.broker:queue:qpid.ha-tx:ead7752b-54f0-4e5b-a389-5d2b46b8949a
    167  16:34:23  -          org.apache.qpid.broker:queue:qpid.ha-tx:ecd4b7e9-1199-44be-927a-b5230ed8aa3c
    168  16:07:00  -          org.apache.qpid.broker:queue:qpid.ha-tx:ed388289-24b8-4415-9b3e-3568874c6f39
    169  16:34:19  -          org.apache.qpid.broker:queue:qpid.ha-tx:ed4417bf-ee74-4928-ad2d-989b3ed6b44a
    170  16:12:06  -          org.apache.qpid.broker:queue:qpid.ha-tx:f64dd47f-c174-40a9-aba9-f39c4ce9f5c6
    171  16:01:53  -          org.apache.qpid.broker:queue:qpid.ha-tx:fc85c5e7-be8e-44fd-8521-cf99dcfc3f96
    172  16:34:38  -          org.apache.qpid.broker:queue:reply-GZ-GAME-19.65.19797.1
    173  16:34:38  -          org.apache.qpid.broker:queue:topic-GZ-GAME-19.65.19797.1
    195  16:34:53  16:34:53   org.apache.qpid.broker:queue:64fdbc38-22a9-4950-91d6-28bdc4e9cf8d:0.0
[reply] [??  Private Comment 2 masterQi@126.com 2014-05-08 12:43:31 EDT
broker:
   qpid-cpp-0.26
client version:
  qpid-client-0.26.jar
  qpid-common-0.26.jar
[reply] [??  Private Comment 3 masterQi@126.com 2014-05-19 07:36:57 EDT
when i set ""sessionTransacted"" false the it's OK.
[reply] [??  Private"
Bug,QPID-7134,12948750,"[C++ client] Message::setContent("""") does not work",gsim,pmoravec,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,,,,,,,"Message::setContent internally updates just ""bytes"" property of the Message object but not the ""content"" object. That brings problems when trying to reset content to empty one - original content is still stored in ""content"" object property and e.g. an attempt to send this ""empty"" message sends the message with original content.

Reproducer (outside a broker, feel free to add receiving initial message from the broker, or sending the result to it back):

{noformat}
#include <iostream>
#include <qpid/messaging/Message.h>

using namespace std;
using namespace qpid::messaging;

int main(int argc, char* argv[])
{
    qpid::types::Variant content(""some content"");
    Message m1(content);
    cout << ""Message 1: initial content set to \"""" << m1.getContent() << ""\"", contentSize = "" << m1.getContentSize() << endl;
    m1.setContent(""message 1"");
    cout << ""Message 1: after content set to \"""" << m1.getContent() << ""\"", contentSize = "" << m1.getContentSize() << endl;
    m1.setContent(std::string());
    cout << ""Message 1: after content set to an empty string, the content is still \"""" << m1.getContent() << ""\"" and contentSize = "" << m1.getContentSize() << endl;

    return 0;
}
{noformat}

That returns:

{noformat}
Message 1: initial content set to ""some content"", contentSize = 12
Message 1: after content set to ""message 1"", contentSize = 9
Message 1: after content set to an empty string, the content is still ""some content"" and contentSize = 12
{noformat}

See ""some content"" of size 12 returned after an attempt to empty the message content. See it is the _original_ content before first setContent called."
Bug,QPID-2707,12468183,Cmake build doesn't output all needed settings to build a valid shared library name for loading,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"The config.h file generated from config.h.cmake contains generated, platform-appropriate strings used to form dll/shared library names. The prefix setting is missing (QPID_MODULE_PREFIX)."
Bug,QPID-2298,12443951,CMake-based install based on released sources tries to include generated headers from build tree,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"The CMake-based install generator includes the generated AMQP/QMF headers in the installer. When run from a svn checkout, these headers are generated in the build tree, but when run from a source distribution released from Apache, they're in the source tree. The installer doesn't know the difference and fails when it can't find the 'include' directory in the build tree.

I have a fix here locally that works."
Bug,QPID-2439,12458557,CMake builds broken 08-Mar-2010,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"The cmake builds (Linux and Windows) broke overnight with the error:

CMake Error in src/CMakeLists.txt:
  Cannot find source file ""ManagementExchange.cpp"".  Tried extensions .c .C
  .c++ .cc .cpp .cxx .m .M .mm .h .hh .h++ .hm .hpp .hxx .in .txx


Did someone remove a file and not update CMakeLists.txt?
"
Bug,QPID-2441,12458644,make check fails because of wrong sorting,gsim,jasan,Closed,Fixed,2016-09-06 20:28,C++,C++ Examples,,,,,,,"When I do 'make check' after building qpid/cpp I got few failures
because the sorted input files were not sorted using traditional
sort order, see warning in sort(1) manual page.
"
Bug,QPID-4698,12640534,Fixes needed for the CMake build system when installing files.,mcpierce,mcpierce,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,Some of the installed files are going into the wrong directories.
Bug,QPID-2706,12468166,Visual Basic example includes a directory whose name contains a space,tross,chug,Closed,Fixed,2016-09-06 20:28,C++,C++ Examples,,,,,,,"A default new Visual Basic project places several files in a directory named ""My Projects"". The space in the name causes trouble for simple patch utilities on other systems. It's simple enough to rename the directory and references to it."
Bug,QPID-3723,12537310,qpid 0.12 make fails on Linux Mint 12 (I think derived from Ubuntu 11.10) ,,fadams,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"make for qpid 0.12 fails in a number of places.

See the following mailing list thread for more details:

http://qpid.2158936.n2.nabble.com/qpid-0-12-make-fails-on-Linux-Mint-12-I-think-derived-from-Ubuntu-11-10-td7140482.html

I believe this relates to changes made to the linker behaviour for recent gcc versions so I suspect that this issue isn't limited to Linux Mint 12. See http://fedoraproject.org/wiki/UnderstandingDSOLinkChange (this is a Fedora page and I'm using Mint but the symptoms seem identical). 

I've put together a patch for this which I'll attach when the Jira gets created.
"
Bug,QPID-3295,12509494,Under some conditions autoconf incorrectly detects that gcc doesn't support -Werror,astitcher,astitcher,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"If CFLAGS or CXXFLAGS contains ""-Wall"" when running configure, autoconf incorrectly detects that gcc doesn't support -Werror

This is problematic because it is an important aspect of our policy that there should be no compiler warnings, and this bug stops this being enforced.

Notably, the fedora package build has this issue and has been shipping with some unnoticed warnings for a while."
Bug,QPID-2212,12441247,C++ messaging spout and drain examples don't build on Windows,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Examples,,,,,,,"The new qpid/cpp/examples/messaging spout and drain examples get link failures for boost::program_options entrypoints.
"
Bug,QPID-5103,12666001,C++ build on Windows needs FindQpid-proton or equivalent,chug,chug,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"File qpid/cpp/src/amqp.cmake relies on pkg-config to locate installed qpid-proton libraries. In general pkg-config is absent on windows and finding qpid-proton could use help.

One solution is to write a FindQpid-proton.cmake library function. This solution still has an issue on Windows where there is no generally accepted place to find qpid-proton.

Another solution proposed here is to modify PROTON to produce a cmake EXPORT during installation. Then the export file is located by the definition of QPID_PROTON_ROOT and consumed during a qpid build. File qpid-proton.dll and the include directories are available as if they were built in the qpid source tree."
Bug,QPID-2299,12443952,C++ Messaging drain and spout examples need vcproj files,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Examples,,,,,,,"The C++ example programs in qpid/cpp/examples have checked-in Visual Studio project files that are included in releases (they can't be generated w/ current CMake facilities).
The new messaging/spout and messaging/drain examples don't have vcproj files."
Bug,QPID-3944,12550596,Autotools build system doesn't correctly detect python developer libraries,astitcher,astitcher,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"A change made for 0.15 as part of QPID-3464 broke the autotools python developer libraries/headers detection logic.

"
Bug,QPID-2202,12440729,CMake doesn't check for presence of boost-system,shuston,n1ywb,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"CMake doesn't check for presence of boost-system library. It successfully configures and generates, but building in VC9 fails on linking when it cannot find the library. Installing the library and re-linking works around the issue."
Bug,QPID-2003,12431244,Coverage report is unable to show generated files,aidan,ritchiem,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"Summary:

When viewing the coverage report (ant coverage-report) coverage is provided for generated file however the marked up source is not show for generated classes as the scratch space is not added to the list of files for cobertura to process.
"
Bug,QPID-2301,12443958,C++ examples changed at r880718; obsolete vcproj files not removed,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Examples,,,,,,,"svn r880718 removed the qpid/cpp/examples/messaging/topic_listener and queue_listener examples, but didn't remove the corresponding vcproj files or their entries in examples.sln and Makefile.am. When the resulting installer is installed, examples.sln attempts to load these projects but Visual Studio won't load them because the sources are missing.
"
Bug,QPID-2398,12455792,C++ examples'  Visual Studio projects need BOOST_ALL_DYN_LINK to build against installed kit,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Examples,,,,,,,The examples distributed with the C++ kit contain Visual Studio solution/project files so the examples can be built by users wanting to try the examples at an installed site. The vcproj files get build errors trying to refer to the static Boost libs because the dynamic Boost libs are packaged with the kit. The examples project files need BOOST_ALL_DYN_LINK added to the C++ preprocessor settings.
Bug,QPID-4697,12640514,Minor fixes to make distcheck,aconway,aconway,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"- add qmfengine.py to DIST.
- create directory qpid/bindings/perl if not already present.
- ssl_test: don't run python part of tests if python client not available.
"
Bug,QPID-1836,12424421,C++ examples and tests Visual Studio sln/vcproj files missing from 0.5 RC1,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,The Visual Studio sln/vcproj files are missing from the cpp/examples and cpp/src/tests directories.
Bug,QPID-3058,12498640,"Windows installer doesn't package qpidtypes, qpidmessaging, or dotnet bindings",shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,The installer builder on trunk doesn't package the qpidtypes or qpidmessaging or dotnet binding components. I have a patch from 0.8 to migrate to trunk to resolve this.
Bug,QPID-4869,12648450,Small fix: Perl shouldn't be required to build Qpid,mcpierce,mcpierce,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,A previous change to the CMake build files (QPID-4724) made building the Perl libraries required rather than option by causing the build to fail if it found Perl but not the Perl development libraries.
Bug,QPID-4434,12615847,Can't build C++ components with cmake if minimum swig version not present,mcpierce,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"When building the C++ components with cmake, the cmake configure step fails if swig is installed but is prior to version 1.3.32. If the configure fails, no make files are generated and nothing can be built. I believe the C++ components less the swig-generated bindings should still build."
Bug,QPID-3729,12537531,C++ cmake build does not install python pieces needed for tests,shuston,shuston,Closed,Fixed,2016-09-06 20:26,C++,C++ Build,,,,,,,"The cpp/src/tests/Makefile.am runs python setup.py install on the needed python items for the tests. The cmake build does not - it tries to rely on setting paths to the proper locations in the source tree. The paths to the source tree don't work right, and compiled python files get out of date easily, resulting is false fails when the tests are run via cmake. The cmake build should run the same python setup that the autotools build does."
Bug,QPID-5904,12728268,qpid HA cluster may end-up in joining state after HA primary is killed,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,," Frantisek Reznicek 2014-07-09 08:59:30 EDT

Description of problem:

qpid HA cluster may end-up in joining state after HA primary is killed.

Test scenario.
Let's have 3 node qpid HA cluster, all three nodes are operational.
Then a sender is executed and sending to queue (pure transactional with durable messages and durable queue address).
During that process primary broker is killed multiple times.
After N'th primary broker kill cluster is no longer functional as qpid brokers are ending all in joining states:

[root@dhcp-lab-216 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining
[root@dhcp-x-216 ~]# clustat
Cluster Status for dtests_ha @ Wed Jul  9 14:38:44 2014
Member Status: Quorate

 Member Name                                   ID   Status
 ------ ----                                   ---- ------
 192.168.6.60                                      1 Online, Local, rgmanager
 192.168.6.61                                      2 Online, rgmanager
 192.168.6.62                                      3 Online, rgmanager

 Service Name                         Owner (Last)                         State         
 ------- ----                         ----- ------                         -----         
 service:qpidd_1                      192.168.6.60                         started       
 service:qpidd_2                      192.168.6.61                         started       
 service:qpidd_3                      192.168.6.62                         started       
 service:qpidd_primary                (192.168.6.62)                       stopped       


[root@dhcp-x-165 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining

[root@dhcp-x-218 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining


I believe the key to hit the issue is to kill the newly promoted primary soon after it starts appearing in starting/started state in clustat.

My current understanding is that if we have 3 node cluster then applying any failures to single node at one time should be handled by HA. This is what the testing scenario does:
A    B    C (nodes)
pri  bck  bck
kill 
bck  pri  bck
     kill
bck  bck  pri
          kill
...
pri  bck  bck
kill
bck  bck  bck


It looks to me that there is short time when promoting new primary when kill causes (of such primary newbee) causes promotion procedure to stuck in all joining.

I haven't seen such behavior in past, either we are now more sensitive to such case (after -STOP case fixes) or the durability turned on rapidly raises the probability.


Version-Release number of selected component (if applicable):
# rpm -qa | grep qpid | sort
perl-qpid-0.22-13.el6.i686
perl-qpid-debuginfo-0.22-13.el6.i686
python-qpid-0.22-15.el6.noarch
python-qpid-proton-doc-0.5-9.el6.noarch
python-qpid-qmf-0.22-33.el6.i686
qpid-cpp-client-0.22-42.el6.i686
qpid-cpp-client-devel-0.22-42.el6.i686
qpid-cpp-client-devel-docs-0.22-42.el6.noarch
qpid-cpp-client-rdma-0.22-42.el6.i686
qpid-cpp-debuginfo-0.22-42.el6.i686
qpid-cpp-server-0.22-42.el6.i686
qpid-cpp-server-devel-0.22-42.el6.i686
qpid-cpp-server-ha-0.22-42.el6.i686
qpid-cpp-server-linearstore-0.22-42.el6.i686
qpid-cpp-server-rdma-0.22-42.el6.i686
qpid-cpp-server-xml-0.22-42.el6.i686
qpid-java-client-0.22-6.el6.noarch
qpid-java-common-0.22-6.el6.noarch
qpid-java-example-0.22-6.el6.noarch
qpid-jca-0.22-2.el6.noarch
qpid-jca-xarecovery-0.22-2.el6.noarch
qpid-jca-zip-0.22-2.el6.noarch
qpid-proton-c-0.7-2.el6.i686
qpid-proton-c-devel-0.7-2.el6.i686
qpid-proton-c-devel-doc-0.5-9.el6.noarch
qpid-proton-debuginfo-0.7-2.el6.i686
qpid-qmf-0.22-33.el6.i686
qpid-qmf-debuginfo-0.22-33.el6.i686
qpid-qmf-devel-0.22-33.el6.i686
qpid-snmpd-1.0.0-16.el6.i686
qpid-snmpd-debuginfo-1.0.0-16.el6.i686
qpid-tests-0.22-15.el6.noarch
qpid-tools-0.22-13.el6.noarch
ruby-qpid-qmf-0.22-33.el6.i686


How reproducible:
rarely, timing is the key

Steps to Reproduce:
1. have configured 3 node cluster
2. start the whole cluster up
3. execute transactional sender to durable queue address with durable messages and reconnect
4. repeatedly kill the primary broker once it is promoted


Actual results:
  After few kills cluster ends up not functional all in joining. Ability to bring qpid HA down by inserting single isolated failures to newly being promoted brokers.

Expected results:
  Qpid HA should be single failure at one time tolerant.

Additional info:
  Details on failure insertion:
    * kill -9 `pidof qpidd` is the failure action
    * Assuming the duration between failure insertion and primary is ready to serve named as T1
    * failure insertion period T2 > T1 i.e. there are no cummulative failures inserted while HA is getting through new primary promotion
      -> this fact (in my view) proves that there is real issue"
Bug,QPID-5404,12683204,HA broker message duplication when deleting a queue with an alt-exchange,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"See also: https://bugzilla.redhat.com/show_bug.cgi?id=859119

Description of problem:
When deleting a queue with an alternate exchange, both the primary and the backup brokers will route messages to the alt-exchange when the queue is deleted.  This will cause the backups to potentially receive duplicate copies of the message if the alt-exchange is bound to a replicated queue (one set from the local route to the alt-exchange and another from the primary due to its route to the alt-exchange).  Suggest that the backup brokers should not route messages to the alt-exchange when a queue is deleted.  

Additionally, for auto-delete queues with an alt-exchange, upon loss of a primary, the backup brokers should not immediately start the auto-delete process.  Instead, the backups should wait for the promotion of a new primary.  Upon selection of the new primary, the auto-delete process can start so that the new primary will route the messages to the alt-exchange and the backups will not route the messages to the alt-exchange.

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
Backup needs to receive the QMF queue delete event prior to receiving the queue's deque replication events.

Steps to reproduce:
1) Bind queue test0 to amq.fanout
2) Create queue test1 with an alt-exchange to amq.fanout
3) Send a message to test1
4) Delete queue test1

Actual results:
The queue test0 will have 1 message on the primary host but 2 messages on the backups

Expected results:
The queue test0 will have 1 message on all hosts"
Bug,QPID-5275,12676490,HA transactions failing in qpid-cluster-benchmark,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"Run the following test (from qpid/cpp/src/tests) against a 3 node cluster:

qpid-cluster-benchmark -b 20.0.20.200 -n1 -m 1000 -q6 -s3 -r3 --send-arg=--tx --send-arg=10 --receive-arg=--tx --receive-arg=10

Actual resullt: log file from the primary broker contains many errors like this:

Primary transaction 393340e4: Backup disconnected: e4886fe3@tcp:20.0.10.33:5672(ready) 

The log file on the backup brokers contain many messages like this:

Backup of transaction 6db1a2e2: Rollback

Expected result: no errors and no rollbacks in the log files."
Bug,QPID-5026,12660706,[AMQP 1.0] set address for 'local' terminus in attach,gsim,gsim,Closed,Fixed,2016-09-06 16:35,C++,C++ Client,,,,,,,"I.e. the target for receivers, the source for senders... this may be useful for some intermediaries (such as dispatch!)."
Bug,QPID-5454,12687895,Sporadic core dump in ha_tests.ReplicationTests.test_auto_delete_failover,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"ha_tests.ReplicationTests.test_auto_delete_failover sporadically dumps core.

This can be easily reproduced on RHEL5, but does not seem to be easy to reproduce on other platforms:
{noformat}
To reproduce: 

   cd src/tests; source test_env.sh; while ha_tests.py *test_auto_delete_failover; do true; done; find -name core*

Result: eventual failure with core dump

aconway1@mrg29 debug (trunk $%)$ cd src/tests; source test_env.sh; while ha_tests.py *test_auto_delete_failover; do true; done; find -name core*
ha_tests.ReplicationTests.test_auto_delete_failover .................................. fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway1/qpid/debug/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway1/qpid/qpid/cpp/src/tests/ha_tests.py"", line 762, in test_auto_delete_failover
      cluster[i].wait_no_queue(q,timeout=2)      # auto-deleted
    File ""/home/aconway1/qpid/qpid/cpp/src/tests/ha_test.py"", line 217, in wait_no_queue
      assert retry(lambda: agent.getQueue(queue) is None, timeout=timeout)
    File ""/home/aconway1/qpid/qpid/cpp/src/tests/brokertest.py"", line 88, in retry
      ret = function()
    File ""/home/aconway1/qpid/qpid/cpp/src/tests/ha_test.py"", line 217, in <lambda>
      assert retry(lambda: agent.getQueue(queue) is None, timeout=timeout)
    File ""/home/aconway1/qpid/qpid/tools/src/py/qpidtoollibs/broker.py"", line 183, in getQueue
      return self._getBrokerObject(Queue, ""org.apache.qpid.broker:queue:%s"" % name)
    File ""/home/aconway1/qpid/qpid/tools/src/py/qpidtoollibs/broker.py"", line 127, in _getBrokerObject
      obj = self._doNameQuery(oid)
    File ""/home/aconway1/qpid/qpid/tools/src/py/qpidtoollibs/broker.py"", line 101, in _doNameQuery
      correlator = self._sendRequest('_query_request', query)
    File ""/home/aconway1/qpid/qpid/tools/src/py/qpidtoollibs/broker.py"", line 77, in _sendRequest
      self.tx.send(message)
    File ""<string>"", line 6, in send
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 863, in send
      self._ecwait(lambda: self.linked, timeout=timeout)
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 50, in _ecwait
      result = self._ewait(lambda: self.closed or predicate(), timeout)
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 814, in _ewait
      result = self.session._ewait(lambda: self.error or predicate(), timeout)
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 580, in _ewait
      result = self.connection._ewait(lambda: self.error or predicate(), timeout)
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 219, in _ewait
      self.check_error()
    File ""/home/aconway1/qpid/debug/src/tests/python/qpid/messaging/endpoints.py"", line 212, in check_error
      raise e
  ConnectionError: connection aborted
Totals: 1 tests, 0 passed, 0 skipped, 0 ignored, 1 failed
./ha_tests.tmp/ha_tests.ReplicationTests.test_auto_delete_failover/core.27906

Expected result: passes indefinitely

{noformat}"
Bug,QPID-4840,12647586,HA Sporadic failure of ha_tests.ReplicationTests.test_backup_acquired,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"Fails with this error:

Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpid-trunk/opt/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpid-trunk/qpid/cpp/src/tests/ha_tests.py"", line 460, in test_backup_acquired
      for t in tests: t.verify(self, backup1)
    File ""/home/aconway/qpid-trunk/qpid/cpp/src/tests/ha_tests.py"", line 438, in verify
      backup.assert_browse_backup(self.queue, self.expect, msg=self.queue)
    File ""/home/aconway/qpid-trunk/qpid/cpp/src/tests/ha_test.py"", line 198, in assert_browse_backup
      assert_browse_retry(bs, queue, expected, **kwargs)
    File ""/home/aconway/qpid-trunk/qpid/cpp/src/tests/brokertest.py"", line 421, in assert_browse_retry
      assert expect_contents == actual_contents, msg
  AssertionError: plain: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] != ['1', '2', '3', '4', '5', '6', '7', '8', '9']
"
Bug,QPID-5318,12678308,"HA tests fail sporadically with ""AttributeError: 'NoneType' object has no attribute 'name'""",aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"Running ha_tests.py, tests occasionally fail with 
 ""AttributeError: 'NoneType' object has no attribute 'name'""
"
Bug,QPID-4850,12647841,HA Sporadic stall in ha_tests.test_failover_send_receive,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"To reproduce: in a loop call
  ha_tests.py *.test_failover_send_receive
The test occasionally fails with a message like:

ha_tests.LongTests.test_failover_send_receive .................................................... start
  Traceback (most recent call last):
    File ""/home/aconway/qpid/qpid/cpp/src/tests/ha_tests.py"", line 978, in test_failover_send_receive
      map(wait_passed, receivers, checkpoint)
    File ""/home/aconway/qpid/qpid/cpp/src/tests/ha_tests.py"", line 946, in wait_passed
      assert retry(check), ""Stalled %s at %s""%(r.queue, n)
  AssertionError: Stalled test8 at 2107
ha_tests.LongTests.test_failover_send_receive .................................................... fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpid/build2/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpid/qpid/cpp/src/tests/ha_tests.py"", line 993, in test_failover_send_receive
      for r in receivers: r.stop()
    File ""/home/aconway/qpid/qpid/cpp/src/tests/brokertest.py"", line 625, in stop
      join(self)
    File ""/home/aconway/qpid/qpid/cpp/src/tests/brokertest.py"", line 485, in join
      if thread.isAlive(): raise Exception(""Timed out joining thread %s""%thread)
  Exception: Timed out joining thread <NumberedReceiver(Thread-20, started 140175095092992)>
"
Bug,QPID-5105,12666138,HA Test failover for all clients using virtual IP and multi-address.,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"Need a test to verify all clients fail over correctly in a HA cluster using virtual IP or multi-address URLs.

The new test script is run manually against an exiting cluster setup with virtual IP. 

It is configured with the location of each client (defaults to location in a built checkout) and two cluster URLs: virtual IP and multi-address.

For each client (c++, python, java, ...) and each URL type (virtual IP and multi-address) it runs a send/receive pair, causes a failure while running and verifies the results."
Bug,QPID-5528,12692397,HA Clean up error messages around queue deletion,aconway,aconway,Closed,Fixed,2016-09-06 16:35,C++,C++ Clustering,,,,,,,"See also https://bugzilla.redhat.com/show_bug.cgi?id=1024528

Running the following simple transaction test:
{noformat}
qpid-cluster-benchmark -b 20.0.20.200 -n1 -m 1000 -q3 -s2 -r2 $AMQP10  --send-arg=--tx --send-arg=10 --receive-arg=--tx --receive-arg=10
{noformat}
Generates a lot of errors and rollback messages in the broker logs.
It should complete cleanly."
Bug,QPID-5482,12689071,HA Backup becomes useless if a connection-forced error is raised.,aconway,aconway,Closed,Fixed,2016-09-06 16:34,C++,C++ Clustering,,,,,,,"If the cluster is mis-configured so that backups do not have access to the primary (e.g. by using an ACL that does not provide full access to the ha-username) then the primary will close attempted connections with a connection-forced error.

This will close the backup link, so it no longer attempts to connect, rendering the backup useless. There is a warning message but its not obvious that this indicates a fatal problem:

2014-01-08 10:22:10 [Broker] warning Client closed connection with 320: ACL denied anonymous creating a federation link"
Bug,QPID-4975,12655860,AMQP 0_10 Messaging client sends empty correlation id even if no correlation Id is set,astitcher,astitcher,Closed,Fixed,2016-09-06 16:34,C++,C++ Client,,,,,,,"The qpid::messaging library holds no flag to say whether the correlation id has been set or not so when it converts the message properties to the amqp 0_10 it unconditionally sends """" if the user set no correlation id.

It would be better if it detected an empty correlation id property and didn't send a correlation id on the wire."
Bug,QPID-6493,12820717,cmake install (TARGET ...) component syntax is incorrect in the src/CMakeLists.txt,chug,starksm64,Closed,Fixed,2016-09-06 16:31,C++,C++ Build,,,,,,,"The cmake build uses a development component that should allow one to build the libraries/headers needed for a client to build against by running:

mkdir build
cd build
cmake ..
make qpidmessaging
cmake -DCOMPONENT=development -P src/cmake_install.cmake
cmake -DCOMPONENT=runtime -P src/cmake_install.cmake

However, this only installs the header files and then fails due to missing broker related target not existing. None of the libraries are installed.

One problem is that the cmake install command requires the component to be specified after each of the RUNTIME, LIBRARY and ARCHIVE specifications. Because the component specification is missing in all of the RUNTIME and LIBRARY elements, they end up being associated with the ""Unspecified"" component, and therefore, can only be installed when a component is not specified. This is seen in the generated build/src/cmake_install.cmake file.

The correct syntax for the install statement for a target is as shown for this updated qpidcommon target:

install (TARGETS qpidcommon
         RUNTIME DESTINATION ${QPID_INSTALL_BINDIR} COMPONENT ${QPID_COMPONENT_COMMON}
         LIBRARY DESTINATION ${QPID_INSTALL_LIBDIR} COMPONENT ${QPID_COMPONENT_COMMON}
         ARCHIVE DESTINATION ${QPID_INSTALL_LIBDIR} COMPONENT ${QPID_COMPONENT_COMMON})

Another issue is that the broker targets are grouped together with the runtime component. It should have a separate broker component in order to allow one to build just the client libraries and headers.

"
Bug,QPID-6602,12839169,[AMQP 1.0] prefetch is not always accurate,gsim,gsim,Closed,Fixed,2016-09-06 16:31,C++,C++ Client,,,,,,,"On fetching a message, if there is none waiting and the credit is drained, then on receiving a message as a result, an extra credit is allocated (a credit for the received message is allocated twice). "
Bug,QPID-6256,12758939,Improved control over AMQP versions tried,gsim,gsim,Closed,Fixed,2016-09-06 16:31,C++,C++ Client,,,,,,,"The qpid::messaging client defaults to 0-10, though the version can be explicitly specified also. If the broker doesn't support 0-10, but does support 1.0 and assuming that 1.0 support in the client is enabled and the application didn't explicitly request 0-10, the client should try 1.0.

This would make interoperability easier as it wouldn't require specific connection options to choose 1.0."
Bug,QPID-6409,12776994,Taking address of a 0-length vector throws exception,shuston,shuston,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"In Debug-mode builds, std::vector in VS2013 will throw an exception if trying to do:  &argv[0]  if argv has 0 length. This construct happens in cpp/src/tests/BrokerFixture.h, so happens in many of the unit tests."
Bug,QPID-6511,12823911,"[C++ Broker, clients] AMQP 0-10 windows clients can not connect to --no-auth broker",chug,chug,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Broker
{noformat}
./qpidd --auth no
{noformat}
Windows client
{noformat}
spout -b my-broker:5672 amq.topic
{noformat}
Fails with ""Not authenticated!""

The behavior change was in the broker as part of QPID-6325. Arguably the change is a good thing as it prevents clients connecting to the broker with no name. However, it makes for a poor out-of-the-box experience with a no-auth broker rejecting connections with an auth error. 

Clients can make a connection by adding:
{noformat}
--connection-options ""{username:dummy}""
or
--connection-options ""{sasl-mechanisms:ANONYMOUS}""
{noformat}
But the change breaks years of accumulated self tests that work just fine against older versions of qpidd.

The proposal to fix this is to make the Windows client provide the same connection defaults as linux cyrus sasl. "
Bug,QPID-4233,12603610,Windows C++ client does not reconnect when port is block then re-opened (e.g by firewall) ,,richard.sheath,Closed,Fixed,2016-09-06 16:31,C++,C++ Client,,,,,,,"Looking at the qpid client code it doesn't seem to handle reconnection if the tcp port is blocked and then unblocked.

We are using the Windows client with SSL and SASL having applied this patch to the 0.14 codebase: https://issues.apache.org/jira/browse/QPID-3914

I then noticed this JIRA which sounded like the same issue that I was experiencing https://issues.apache.org/jira/browse/QPID-3759 and applied the patch but I am still getting the same issue. 

This is a sample of how we are creating the connection:
m_pConnection = new qpid::messaging::Connection::Connection(""amqp:ssl:<IP1>:<port1>,<IP2>:<port2>"", """"); //(IP1:port1 and IP2:port2 are the same as we currently only have one server to connect to.
m_pConnection->setOption(""transport"",""ssl"");
m_pConnection->setOption(""sasl_mechanisms"", ""EXTERNAL"");
m_pConnection->setOption(""ssl-cert-filename"", m_strSslCertFileName.c_str());
m_pConnection->setOption(""ssl-cert-filenamepass"",m_strSslCertFileNamePassword.c_str());
m_pConnection->setOption(""host-cert-filename"",m_strHostCertFileName.c_str());
m_pConnection->setOption(""heartbeat"",30); //30 seconds, defaults to 0 which is no heartbeats
m_pConnection->setOption(""reconnect"",true); //defaults to false
m_pConnection->setOption(""reconnect-interval"",30); //30 seconds, default is 60 seconds
m_pConnection->open();

We then create 3 Sessions from the connection e.g.:
m_SessionResponse = m_pConnection->createSession(""Response"");
Using one of these sessions we create both a receiver and a sender.
And we create a receiver for each of the other 2 sessions.

I am expecting these receivers and sender to remain active for the lifetime of the program. We call receiver.fetch(Duration::SECOND * 10); in a loop on its own thread for each receiver.

We start the application and it connects and runs ok. Then we block the port using windows firewall to simulate a network issue. At this point the .fetch(Duration::SECOND * 10); never returns from the call. And if you call the qpid::messaging::Sender::send function this returns with no exceptions thrown.

I am not sure what exactly should happen in this scenario these are my thoughts please advise/correct:
1) At worst the fetch should throw an exception so the calling application knows there is a problem.
2) Possibly the send should also throw an exception, again so the calling application knows there is a problem.
3) If ""reconnect"" is enabled then we should try to reconnect (to the same IP:port).
4) If multiple IPs are specified we should failover to the next IP on reconnect.

I can see in the qpid log that the heartbeats are timing out with this message ""Traffic timeout"". This could possibly be used to trigger the reconnect.
Also I noticed when debugging that void TCPConnector::eof(AsynchIO&) is called much before the heartbeat timeout and maybe this could be used instead.


"
Bug,QPID-6526,12826419,[AMQP 1.0]: race condition in creating senders/receivers,gsim,gsim,Closed,Fixed,2016-09-06 16:31,C++,C++ Client,,,,,,,"There is insufficient locking when creating senders or receivers, which can in rare cases cause corruption in proton, and segfaults or assertions."
Bug,QPID-6529,12827038,[C++ Client] Fails to compile with Proton 0.10,chug,chug,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Proton version detection logic
{noformat}
if (Proton_VERSION GREATER 0.8)
{noformat}
gets it wrong when Proton is 0.10.
"
Bug,QPID-6559,12833741,NullSaslClient only support ANONYMOUS,gsim,gsim,Closed,Fixed,2016-09-06 16:31,C++,C++ Client,,,,,,,"So on linux, if the client is built without cyrus-sasl-devel installed then there is no PLAIN support."
Bug,QPID-6399,12776036,Windows run_test.ps1 script needs revamp to match run_test,shuston,shuston,Closed,Fixed,2016-09-06 16:31,C++,C++ Broker,C++ Client,,,,,,"Some time back the run_test script was expanded to offer new capabilities and the cmake testing invocation changed to match. The run_test.ps1 script is still expecting ""old"" invocation and needs a makeover."
Bug,QPID-4601,12633990,HA backup broker shuts down after redeclaring exchange,aconway,aconway,Closed,Fixed,2016-09-06 16:23,C++,C++ Clustering,,,,,,,"There is a bug in ExchangeRegistry, it is always setting disp=created even if
the exchange was already present.

See also https://bugzilla.redhat.com/show_bug.cgi?id=888435"
Bug,QPID-4430,12615501,HA QMF queue events do not propagate to backups under load,aconway,aconway,Closed,Fixed,2016-09-06 16:22,C++,C++ Clustering,,,,,,,See https://bugzilla.redhat.com/show_bug.cgi?id=872696
Bug,QPID-5540,12693295,Windows connection close error: SCHANNEL_SHUTDOWN called twice,cliffjansen,cliffjansen,Closed,Fixed,2016-09-06 16:22,C++,C++ Client,,,,,,,SslAsynchIO::queueWriteClose can be called by both user and IO threads causing two SCHANNEL_SHUTDOWN actions in separate threads and a spurious error from SChannel.  A mutex can prevent the second shutdown.
Bug,QPID-4133,12598580,Non-responsive peer in federated link can result in entire cluster shutdown,aconway,dillaman,Closed,Fixed,2016-09-06 16:22,C++,C++ Clustering,,,,,,,"If a federated link is established to a source broker that is slow to respond with the AMQP handshake, the destination broker cluster will shutdown with an ""Unknown connection"" error.  

Exception constructed: Unknown connection: Frame[BEbe; channel=0; {ClusterConnectionDeliverDoOutputBody: limit=2048; }] control 2.0.0.0:22138-14 (qpid/cluster/Cluster.cpp:542)

Steps to Reproduce:

1. Configure a clustered broker
2. Start netcat in listen mode (nc -l 6000)
3. Add a route between the clustered broker and nc (qpid-route queue add localhost:5672 localhost:6000 amq.fanout foo)
4. Clustered broker shuts down"
Bug,QPID-4369,12611543,HA backup brokers core dump in benchmark test.,aconway,aconway,Closed,Fixed,2016-09-06 16:22,C++,C++ Clustering,,,,,,,"Description of problem: Backup brokers in a HA cluster show errors and dump core.


Version-Release number of selected component (if applicable):
0.18-mrg branch: e0bd483
trunk: f367a03

How reproducible: 100%


Steps to Reproduce:
1. Start a 3 node HA cluster.
2. run: qpid-cpp-benchmark --repeat 10 -b 20.0.10.33 --summarize -q 6 -s 3 -r 3 -m 1000 --connection-options {tcp-nodelay:false,reconnect:true,heartbeat:1}

  
Actual results: 
Backup brokers core dump. Their logs show errors like :
2012-10-12 11:16:56 [HA] error Backup queue benchmark-0: Execution error: not-found: Exchange not found: qpid.replicator-benchmark-0 


Expected results: No crash or errors on backups. 
"
Bug,QPID-4555,12630012,HA tests fail when run in a loop.,aconway,aconway,Closed,Fixed,2016-09-06 16:22,C++,C++ Clustering,,,,,,,"Description of problem: HA tests fail when run in a loop.

Version-Release number of selected component (if applicable): 0.18-mrg

How reproducible: usually in < 10 iterations

Steps to Reproduce: while make check TESTS=ha_tests.py; do true; done
  
Actual results: A test eventually fails

Expected results: no failures

Additional info:

The following tests were observed to fail occasionally:

ha_tests.LongTests.test_failover_send_receive
ha_tests.RecoveryTests.test_expected_backup_timeout
ha_tests.ReplicationTests.test_auto_delete_timeout
ha_tests.ReplicationTests.test_queue_replica_failover
ha_tests.ReplicationTests.test_alternate_exchange
ha_tests.ReplicationTests.test_stale_response
ha_tests.ReplicationTests.test_delete_qpid_4285
ha_tests.ReplicationTests.test_failover_python
ha_tests.RecoveryTests.test_expected_backup_timeout
ha_tests.RecoveryTests.test_send_receive
ha_tests.ReplicationTests.test_delete_qpid_4285

See also: https://bugzilla.redhat.com/show_bug.cgi?id=906060"
Bug,QPID-4641,12636424,C++ build errors re virtual functions but non-virtual destructor,aconway,shuston,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"The C++ HA component is experiencing these build errors on RHEL 5, g++ 4.1.2:

/.../cpp/src/qpid/ha/Role.h:39: warning: class qpid::ha::Role has virtual functions but non-virtual destructor
/.../cpp/src/qpid/ha/Backup.h:51: warning: class qpid::ha::Backup has virtual functions but non-virtual destructor
/.../cpp/src/qpid/ha/Primary.h:63: warning: class qpid::ha::Primary has virtual functions but non-virtual destructor
/.../cpp/src/qpid/ha/StandAlone.h:34: warning: class qpid::ha::StandAlone has virtual functions but non-virtual destructor
"
Bug,QPID-4514,12624654,Remove obsolete code related to active-active-cluster,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,The active-active cluster module has been removed. Remove remaining code that was only needed by the cluster module.
Bug,QPID-4322,12608253,HA sporadic failure in ha_tests,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"To reproduce run this in a loop: ha_tests.py-DDURATION=3

Fails about 8% of the time with:
{noformat}
ha_tests.LongTests.test_failover_send_receive ....................................... start
  Traceback (most recent call last):
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/ha_tests.py"", line 930, in test_failover_send_receive
      map(wait_passed, receivers, checkpoint)
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/ha_tests.py"", line 898, in wait_passed
      assert retry(check), ""Stalled %s at %s""%(r.queue, n)
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/brokertest.py"", line 86, in retry
      ret = function()
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/ha_tests.py"", line 896, in check
      r.check()       # Verify no exceptions
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/brokertest.py"", line 672, in check
      if self.error: raise self.error
  RethrownException: qpid-receive-19
  Traceback (most recent call last):
    File ""/home/aconway/qpidrel/qpid/cpp/src/tests/brokertest.py"", line 661, in run
      assert m <= self.received, ""%s missing message %s>%s""%(self.queue, m, self.received)
  AssertionError: test6 missing message 51645>51525
  
ha_tests.LongTests.test_failover_send_receive ....................................... fail
{noformat}"
Bug,QPID-4630,12635660,HA Fix starting from persistent store.,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"This was implemented as QPID-4325 but was broken by subsequent changes.

When re-starting a persistent HA cluster, the broker that becomes primary should
keep its store data while all the backup brokers should discard their store data
and catch up from the primary. Backups cannot simply use their own stores
because sequence numbers of stored messages will not match on all brokers. The
backup erases individual queues and exchanges as the catch-up process gets to
them.

To reproduce: see tests in qpid/cpp/src/tests/ha_store_tests.py"
Bug,QPID-4516,12624723,Sporadic failure in ha_tests test_failover_send_receive,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"Description of problem: 
Sporadic failures in ha_tests.py test_failover_send_receive. Two types of failure observed: 
- core dumps in a debug build at a C++ assertion
- python test assertion like:   AssertionError: Broker<137:cluster0-0.log qpidd-157 :35273> expected='ready', actual='catchup'

Version-Release number of selected component (if applicable): 
mrg2.3-checkpoint-11

How reproducible: easy

Steps to Reproduce:

Run a loop like this: 
 cd tests; . test_env.sh; ha_tests.py *.test_failover_send_receive

Actual results:
The test fails with 3-4 iterations. 

Expected results:
No failure.

Additional info: See also https://bugzilla.redhat.com/show_bug.cgi?id=886262"
Bug,QPID-4600,12633975,New HA regularly shutting down active node,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=891689

    Bug 891689 - New HA regularly shutting down active node
    
    qpid-primary script was incorrect and failing on status calls,
    causing the broker to be restarted by rgmanager."
Bug,QPID-4436,12616113,HA fix qpidd crash when mgmt-enable=no,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"See also https://bugzilla.redhat.com/show_bug.cgi?id=875660

qpidd crashes if configured with mgmt-enable=no and loading the HA plugin. Caused by incorrect assumption in HA that management is enabled.
Added a fix to skip HA initialization if management is off."
Bug,QPID-4508,12624038,HA backup broker does not properly increment the alternate exchange user count ,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"Description of problem:
When an exchange or queue that utilizes an alternate exchange is replicated to a backup broker, the backup broker does not increment the user count on the alternate exchange.  This will incorrectly allow an alternate exchange to be deleted when it is still in use and will incorrectly prevent a exchange from being deleted when it is no longer an alternate exchange.

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
100%

Steps to Reproduce:
1. Start primary and backup HA brokers
2. Create an exchange to use as the alternate
3. Create a queue or exchange w/ the alternate set to the previously create exchange
4. Fail the primary and promote the backup
5. Delete the alternate exchange
  
Actual results:
The alternate exchange is deleted while still in use

Expected results:
The client should receive a not-allowed exception

Additional info:
See also https://bugzilla.redhat.com/show_bug.cgi?id=886656"
Bug,QPID-4394,12613364,HA replication hangs when QMF events arrive out of order,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"With the new replication-based clustering in 0.18 MRG-M, it is possible for the replication to hang if the QMF events arrive in the wrong order.  I am running the following test that generates the hanging:

- Start a client with 2 threads
- Each thread creates its own Connection, Session, and a Receiver using the address ""someQueue; {create:always, node: {x-declare: {auto-delete:True}}}""
- Run a loop like this (pseudocode):

while(receiver.get(message)) {
  // do stuff

  if at least 5 seconds have passed {
    connection.close();
    reconnectAndRecreateReceiver();
    receiver.setCapacity(1000);
  }
}

During this loop, the 2 threads will disconnect and reconnect every 5 seconds.  When connecting, 1 of them will create a queue.  When disconnecting, the queue will be deleted.  At some point, the queue creation event will possibly arrive at the backup broker before the queue deletion event (i.e. in the wrong order) because there is no lock that governs when queue creation/deletion events are emitted.  When this happens, the backup broker doesn't subscribe to the primary to replicate the queue in question, and things hang."
Bug,QPID-4118,12597818,HA does not work with auhentication and authorization.,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"If authentication and ACL are enabled on brokers in a HA cluster, backup brokers
are unable to replicate even if --ha-username etc. are set to a user with all priviledges.

Need to correct this, and update the documentation explaining what permissions are required to run a secure HA cluster.
"
Bug,QPID-4481,12617882, HA replication of propagated bindings can lead to incorrect configuration,aconway,aconway,Closed,Fixed,2016-09-06 16:21,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=876688

There is a fix posted at the above link, it should be ported to Qpid trunk."
Bug,QPID-6577,12836266,HA - backup broker messages are larger than primary messages.,aconway,aconway,Closed,Fixed,2016-08-30 12:52,C++,C++ Clustering,,,,,,,"Start a HA cluster, send some messages to a queue, then run 
    qpid-stat -q <somequeue> --ha-admin
on each broker in the cluster. Messages on the backup brokers will be slighlty larger than on the primary.

This is a problem when backup brokers reach their queue limits before the primary due to the larger messages, they are no longer able to function as backups."
Bug,QPID-3175,12503025,SSL support in Python client libraries,kgiusti,scholzj,Closed,Fixed,2016-08-10 15:38,C++,C++ Tools,Python Client,,,,,,"I was trying to connect to my broker with SSL encrypted connection (both PLAIN and EXTERNAL authentication methods). However, it seems to be not working. I get following error messages:

Traceback (most recent call last):
  File ""ssl-external.py"", line 20, in <module>
    connection.open()
  File ""<string>"", line 6, in open
  File ""c:\opt\!_EUREX14\tests\qpid.python-0.8\python\qpid\messaging\endpoints.py"", line 244, in open
    self.attach()
  File ""<string>"", line 6, in attach
  File ""c:\opt\!_EUREX14\tests\qpid.python-0.8\python\qpid\messaging\endpoints.py"", line 262, in attach
    self._ewait(lambda: self._transport_connected and not self._unlinked())
  File ""c:\opt\!_EUREX14\tests\qpid.python-0.8\python\qpid\messaging\endpoints.py"", line 197, in _ewait
    self.check_error()
  File ""c:\opt\!_EUREX14\tests\qpid.python-0.8\python\qpid\messaging\endpoints.py"", line 190, in check_error
    raise self.error
qpid.messaging.exceptions.ConnectError: [Errno 1] _ssl.c:499: error:14094412:SSL routines:SSL3_READ_BYTES:sslv3 alert bad certificate

In the source codes (messaging/transports.py), the SSL seems to be supported and implemented, but it is not working. I didn't found any possibilities how to pass the certificates to the SSL libraries and the wrap_socket call in transports.py is calling the wrap_socket without any additional attributes except the original socket.

I didn't had the chance to test other platforms or Python versions, except Python 2.4.3 on RHEL 5.5, where the SSL is not supported at all (the SSL support in Python changed significantly with 2.6)"
Bug,QPID-3540,12526463,"Typecasting and alignment requirements for various platforms - ""increases required alignment of target type""",,chug,Closed,Fixed,2015-06-16 8:35,C++,C++ Broker,C++ Client,,,,,,"On sparc/solaris (and others) the following code generates an error:

  qpid/cpp/src/qpid/RefCountedBuffer.cpp line 37
    boost::intrusive_ptr<RefCounted>(reinterpret_cast<RefCountedBuffer*>(store)),

A workaround is the '(void *)' hack that quiets the compiler but leaves the
code exposed to a run time fault if the store object is not properly aligned:

    boost::intrusive_ptr<RefCounted>(reinterpret_cast<RefCountedBuffer*>((void*)store)),

Another error shows up in
  
  qpid/cpp/src/tests/qpid-perftest.cpp line 647
    size_t n = *reinterpret_cast<const size_t*>(msg.getData().data() + offset);

The (void *) hack silences the error here, too, but the run time code is exposed to
a data alignment fault.

I propose that these two pieces of code need work to guarantee the alignment
or to work around any memory reference fault.

1. In the store case, new() probably returns an address that meets the alignment
requirement. An assert would help diagnose when this assumption fails.

2. In the qpid-perftest case the size_t could be extracted from the raw buffer
with a memcpy and that would be safe to do in all architectures.

2A. A separate issue is the fact that size_t changes between 32-bit and 64-bit
platforms, and that the size_t does not appear to be byte swapped for interop
between big and little endian systems. If these messages are consumed only
by the sender then no problem.


"
Bug,QPID-6252,12758698,AMQP 1.0 browsing client generates large number of errors on broker.,aconway,aconway,Closed,Fixed,2015-04-29 19:47,C++,C++ Client,,,,,,," An AMQP 1.0 client that uses a mixtiure of browsing and acquiring receivers on the same session generates spurious error messages in the broker log like this:

[Broker] error Delivery returned for unknown link

The following python program illustrates the problem.

{noformat}
from qpid_messaging import *

c = Connection.establish(""localhost"", protocol=""amqp1.0"")
ssn = c.session()
ssn.sender(""foo;{create:always}"").send(""foo"")
r = ssn.receiver(""foo;{mode:browse}"")
r.fetch().content
r.close()
ssn.acknowledge()
{noformat}"
Bug,QPID-5842,12723391,Allow SSL hostname verification to be disabled on windows,cliffjansen,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"sometimes the certficate doesn't match the address used to establish the connection, and it would be convenient to be able to disable the verification for those cases

"
Bug,QPID-6323,12768159,[AMQP 1.0] don't set timeout by default for durable subscription if they are also flagged reliable,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,For consistency with existing 0-10 codepath
Bug,QPID-6212,12752872,[WinSDK] build script does not provide hooks to include proton (AMQP 1.0),chug,chug,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"Bld_winsdk.ps1 should allow a command line parameter to specify a shared install directory for including Proton.

If this parameter is absent then the random directory is used like before. Proton may be included by defining Proton_DIR to be the directory that holds file ProtonConfig.cmake (<install_dir>/lib/cmake/Proton).
 "
Bug,QPID-5974,12732769,HA qpid-txtest2 can bring down a cluster (JERR_MAP_LOCKED),aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Clustering,,,,,,,"Description of problem:

qpid-txtest2 AMQP0-10 transactional & durable transfer operation can bring down whole qpid HA.  Note no brokers were killed, just the txtest was run.

To reproduce:

3 node cluster 
whlie qpid-txtest2 -b 20.0.20.200 --tx-count 500 --queues 10 --messages-per-tx 10 --total-messages 1000 --durable 1

Result: 

Test fails. Broker logs show critical and error messages  like this:

{noformat}
[root@dhcp-lab-A ~]# grep -E 'error|critical' ~qpidd/qpidd.log
2014-07-24 14:10:33 [Protocol] error Connection qpid.192.168.6.246:5672-192.168.6.247:34210 timed out: closing


[root@dhcp-lab-B ~]# grep -E 'error|critical' ~qpidd/qpidd.log
2014-07-24 14:10:23 [HA] critical Shutting down: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x6da3) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)
2014-07-24 14:10:23 [Protocol] error Connection qpid.ha.link.09e80392-0c79-4239-a1d0-ea5b53c71bd9 closed by error: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x6da3) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)(501)
2014-07-24 14:10:24 [Broker] error Could not find dequeued message on commit
2014-07-24 14:10:24 [HA] error Backup of transaction 00648954: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 2f556197: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 5bd58ffe: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 5d34703c: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 7e93a7ea: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction e8856f6f: Destroyed prematurely, rollback
2014-07-24 14:10:38 [HA] critical Shutting down: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a42) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)
2014-07-24 14:10:38 [Protocol] error Connection qpid.ha.link.0fc6bd3c-48c2-4b27-9db3-2742b3ddc835 closed by error: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a42) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)(501)
2014-07-24 14:10:38 [Broker] error Could not find dequeued message on commit
2014-07-24 14:10:38 [HA] critical Shutting down: Backup of tx-test2-10: Replication failed: Queue tx-test2-10: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a43) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)
2014-07-24 14:10:38 [Protocol] error Connection qpid.ha.link.0fc6bd3c-48c2-4b27-9db3-2742b3ddc835 closed by error: Backup of tx-test2-10: Replication failed: Queue tx-test2-10: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a43) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)(501)
2014-07-24 14:10:38 [Broker] error Could not find dequeued message on commit
2014-07-24 14:10:40 [HA] critical Shutting down: Backup of tx-test2-7: Replication failed: Queue tx-test2-7: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a49) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)
2014-07-24 14:10:40 [Protocol] error Connection qpid.ha.link.0fc6bd3c-48c2-4b27-9db3-2742b3ddc835 closed by error: Backup of tx-test2-7: Replication failed: Queue tx-test2-7: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x7a49) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)(501)
2014-07-24 14:10:40 [Broker] error Could not find dequeued message on commit
2014-07-24 14:11:10 [HA] error Backup: Joining active cluster, cannot be promoted.


[root@dhcp-lab-C ~]# grep -E 'error|critical' ~qpidd/qpidd.log
2014-07-24 14:10:23 [HA] critical Shutting down: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x53a3) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)
2014-07-24 14:10:23 [Protocol] error Connection qpid.ha.link.1bb57f0a-48db-460c-9260-0f5b353e4bd1 closed by error: Backup of tx-test2-1: Replication failed: Queue tx-test2-1: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0x53a3) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/ha/QueueReplicator.cpp:315)(501)
2014-07-24 14:10:24 [Broker] error Could not find dequeued message on commit
2014-07-24 14:10:24 [HA] error Backup of transaction 00648954: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 2f556197: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 5bd58ffe: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 5d34703c: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction 7e93a7ea: Destroyed prematurely, rollback
2014-07-24 14:10:24 [HA] error Backup of transaction e8856f6f: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction 243b4279: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction 4f4a25df: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction 80cbe9af: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction a3ed917a: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction b7a4b9a0: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction b9ba9995: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction cbd0d6bf: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction e127288a: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction eb43e683: Destroyed prematurely, rollback
2014-07-24 14:10:35 [HA] error Backup of transaction f29196c1: Destroyed prematurely, rollback
2014-07-24 14:10:53 [HA] error Backup: Still catching up, cannot be promoted.

{noformat}"
Bug,QPID-6128,12745279,Error when casting from 'sockaddr*' to 'sockaddr_in*' on ARM platforms,,mcpierce,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"When building on ARM the following error occurs:

[ 18%] Building CXX object src/CMakeFiles/qpidcommon.dir/qpid/sys/posix/SystemInfo.cpp.o
cd /builddir/build/BUILD/qpid-cpp-0.30/src && /usr/bin/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -Dqpidcommon_EXPORTS -O2 -g -pipe -Wall -Werror=format-security -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches  -march=armv7-a -mfpu=vfpv3-d16  -mfloat-abi=hard  -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -DNDEBUG -fPIC -I/builddir/build/BUILD/qpid-cpp-0.30/src -I/builddir/build/BUILD/qpid-cpp-0.30/src/../include -I/usr/include/nss3 -I/usr/include/nspr4    -pthread -o CMakeFiles/qpidcommon.dir/qpid/sys/posix/SystemInfo.cpp.o -c /builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SystemInfo.cpp
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SocketAddress.cpp: In member function 'bool qpid::sys::SocketAddress::compareAddresses(const addrinfo&, const addrinfo&, int&) const':
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SocketAddress.cpp:290:62: error: cast from 'sockaddr*' to 'sockaddr_in*' increases required alignment of target type [-Werror=cast-align]
         struct sockaddr_in* sin4lo = (struct sockaddr_in*)lo.ai_addr;
                                                              ^
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SocketAddress.cpp:291:62: error: cast from 'sockaddr*' to 'sockaddr_in*' increases required alignment of target type [-Werror=cast-align]
         struct sockaddr_in* sin4hi = (struct sockaddr_in*)hi.ai_addr;
                                                              ^
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SocketAddress.cpp:294:64: error: cast from 'sockaddr*' to 'sockaddr_in6*' increases required alignment of target type [-Werror=cast-align]
         struct sockaddr_in6* sin6lo = (struct sockaddr_in6*)lo.ai_addr;
                                                                ^
/builddir/build/BUILD/qpid-cpp-0.30/src/qpid/sys/posix/SocketAddress.cpp:295:64: error: cast from 'sockaddr*' to 'sockaddr_in6*' increases required alignment of target type [-Werror=cast-align]
         struct sockaddr_in6* sin6hi = (struct sockaddr_in6*)hi.ai_addr;
                                                                ^
cc1plus: all warnings being treated as errors
src/CMakeFiles/qpidcommon.dir/build.make:2909: recipe for target 'src/CMakeFiles/qpidcommon.dir/qpid/sys/posix/SocketAddress.cpp.o' failed"
Bug,QPID-6278,12762664, HA broker abort in TXN soak test,aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Clustering,,,,,,,"see also https://bugzilla.redhat.com/show_bug.cgi?id=1145386

I have a repeatable crash in primary HA broker, by doing a soak test on TXNs.


This is with trunk code new as of an hour ago:
  
URL: https://svn.apache.org/repos/asf/qpid/trunk/qpid/cpp
Repository Root: https://svn.apache.org/repos/asf
Repository UUID: 13f79535-47bb-0310-9956-ffa450edef68
Revision: 1626916
Node Kind: directory
Schedule: normal
Last Changed Author: aconway
Last Changed Rev: 1626887


I did a standard build, first of proton and then of qpidd -- except that I had them install themselves in /usr instead of /usr/local .




Here are the scripts I use.


script 1
starting the HA cluster
{
#! /bin/bash


export PYTHONPATH=/home/mick/trunk/qpid/python

QPIDD=/usr/sbin/qpidd
QPID_HA=/home/mick/trunk/qpid/tools/src/py/qpid-ha


# This is where I put the log files.
rm -rf /tmp/mick
mkdir /tmp/mick



for N in 1 2 3
do
  $QPIDD                                                          \
    --auth=no                                                     \
    --no-module-dir                                               \
    --load-module /usr/lib64/qpid/daemon/ha.so                    \
    --log-enable debug+:ha::                                      \
    --ha-cluster=yes                                              \
    --ha-replicate=all                                            \
    --ha-brokers-url=localhost:5801,localhost:5802,localhost:5803 \
    --ha-public-url=localhost:5801,localhost:5802,localhost:5803  \
    -p 580$N                                                      \
    --data-dir /tmp/mick/data_$N                                  \
    --log-to-file /tmp/mick/qpidd_$N.log                          \
    --mgmt-enable=yes                                             \
    -d
  echo ""============================================""
  echo ""started broker $N from $QPIDD""
  echo ""============================================""
  sleep 1
done


# Now promote one broker to primary.
echo ""Promoting broker 5801...""
${QPID_HA} promote --cluster-manager -b localhost:5801
echo ""done.""

}


script 2
create the tx queues, and load the first one with 1000 messages
{
  #! /bin/bash

TXTEST2=/usr/libexec/qpid/tests/qpid-txtest2

echo ""Loading data to queues...""
${TXTEST2} --init=yes --transfer=no --check=no                           \
           --port 5801                                                   \
           --total-messages 1000 --connection-options '{reconnect:true}' \
           --messages-per-tx 10 --tx-count 100                           \
           --queue-base-name=tx --fetch-timeout=1
}



script 3
now beat the heck out of the TXN code
{
  #! /bin/bash

TXTEST2=/usr/libexec/qpid/tests/qpid-txtest2


echo ""starting transfers...""
${TXTEST2} --init=no --transfer=yes --check=no                           \
           --port 5801                                                   \
           --total-messages 5000000 --connection-options '{reconnect:true}' \
           --messages-per-tx 10 --tx-count 500000                          \
           --queue-base-name=tx --fetch-timeout=1

}





I do *not* do any failovers.  Just let that TXN-exercising script run until the primary broker dies.  

It took quite a while.  In my most recent test, I got through something like 300,000 transactions (10 messages each) before the broker became brokest.

I then tried the same test on a standalone broker and it got all the way through.




Here is the traceback:

#0  0x0000003186a328a5 in raise () from /lib64/libc.so.6
#1  0x0000003186a34085 in abort () from /lib64/libc.so.6
#2  0x0000003186a2ba1e in __assert_fail_base () from /lib64/libc.so.6
#3  0x0000003186a2bae0 in __assert_fail () from /lib64/libc.so.6
#4  0x00007f6bb72b4f16 in operator-> (this=0x7f6b48378060, sync=<value optimized out>)
    at /usr/include/boost/smart_ptr/intrusive_ptr.hpp:166
#5  qpid::broker::SessionState::IncompleteIngressMsgXfer::completed (this=0x7f6b48378060, 
    sync=<value optimized out>) at /home/mick/trunk/qpid/cpp/src/qpid/broker/SessionState.cpp:409
#6  0x00007f6bb726d670 in invokeCallback (this=<value optimized out>, msg=<value optimized out>)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/AsyncCompletion.h:117
#7  finishCompleter (this=<value optimized out>, msg=<value optimized out>)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/AsyncCompletion.h:158
#8  enqueueComplete (this=<value optimized out>, msg=<value optimized out>)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/PersistableMessage.h:76
#9  qpid::broker::NullMessageStore::enqueue (this=<value optimized out>, msg=<value optimized out>)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/NullMessageStore.cpp:97
#10 0x00007f6bb71f4578 in qpid::broker::Queue::enqueue (this=0x7f6b4801ef90, ctxt=0x7f6b6821bdf0, msg=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/Queue.cpp:910
#11 0x00007f6bb71f46db in qpid::broker::Queue::TxPublish::prepare (this=0x7f6b48435c70, 
    ctxt=<value optimized out>) at /home/mick/trunk/qpid/cpp/src/qpid/broker/Queue.cpp:159
#12 0x00007f6bb72c8b3d in qpid::broker::TxBuffer::prepare (this=0x7f6b68549120, ctxt=0x7f6b6821bdf0)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/TxBuffer.cpp:42
#13 0x00007f6bb72c9dbe in qpid::broker::TxBuffer::startCommit (this=0x7f6b68549120, 
    store=<value optimized out>) at /home/mick/trunk/qpid/cpp/src/qpid/broker/TxBuffer.cpp:73
#14 0x00007f6bb7298c74 in qpid::broker::SemanticState::commit (this=0x7f6b6c567fb8, store=0x2460440)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/SemanticState.cpp:198
#15 0x00007f6bb6c5886e in invoke<qpid::framing::AMQP_ServerOperations::TxHandler> (this=0x7f6b8bffd4a0, 
    body=<value optimized out>) at /home/mick/trunk/qpid/cpp/build/src/qpid/framing/TxCommitBody.h:53
#16 qpid::framing::AMQP_ServerOperations::TxHandler::Invoker::visit (this=0x7f6b8bffd4a0, 
    body=<value optimized out>) at /home/mick/trunk/qpid/cpp/build/src/qpid/framing/ServerInvoker.cpp:582
#17 0x00007f6bb6c5cc41 in qpid::framing::AMQP_ServerOperations::Invoker::visit (this=0x7f6b8bffd670, body=...)
    at /home/mick/trunk/qpid/cpp/build/src/qpid/framing/ServerInvoker.cpp:278
#18 0x00007f6bb72b504c in invoke<qpid::broker::SessionAdapter> (this=<value optimized out>, 
    method=0x7f6b68130790) at /home/mick/trunk/qpid/cpp/src/qpid/framing/Invoker.h:67
#19 qpid::broker::SessionState::handleCommand (this=<value optimized out>, method=0x7f6b68130790)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/SessionState.cpp:198
#20 0x00007f6bb72b6235 in qpid::broker::SessionState::handleIn (this=0x7f6b6c567df0, frame=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/SessionState.cpp:295
#21 0x00007f6bb6cd5291 in qpid::amqp_0_10::SessionHandler::handleIn (this=0x7f6b6c4e2120, f=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/amqp_0_10/SessionHandler.cpp:93
#22 0x00007f6bb722692b in operator() (this=0x7f6b500ab840, frame=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/framing/Handler.h:39
#23 qpid::broker::ConnectionHandler::handle (this=0x7f6b500ab840, frame=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/ConnectionHandler.cpp:94
#24 0x00007f6bb7221ba8 in qpid::broker::amqp_0_10::Connection::received (this=0x7f6b500ab660, frame=...)
    at /home/mick/trunk/qpid/cpp/src/qpid/broker/amqp_0_10/Connection.cpp:198
#25 0x00007f6bb71aea4d in qpid::amqp_0_10::Connection::decode (this=0x7f6b5005d770, 
    buffer=<value optimized out>, size=<value optimized out>)"
Bug,QPID-6021,12735090,[AMQP 1.0] Improve performance,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,C++ Client,,,,,,Performance is poorer when using AMQP 1.0  (as compared to using AMQP 0-10). This is a JIRA to highlight a few changes to improve things in the next release cycle.
Bug,QPID-6358,12772151,session detach not detected by fetching receiver,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"If a session is detached while a receiver is fetching with infinite timeout, the receiver is not notified of the fact. This is a regression, I believe caused by the fix for https://issues.apache.org/jira/browse/QPID-4786"
Bug,QPID-6298,12765472,[C++Messaging] Server example never frees session senders,,chug,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"The examples/messaging/server example creates a sender to a reply-to address for each message it receives. Later, in the sender destructor, the underlying pn_link_free() function is not called. "
Bug,QPID-6187,12750435,Disable SSL v3 for Windows SChannel,cliffjansen,cliffjansen,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"Using same fix as in https://issues.apache.org/jira/browse/PROTON-719

Windows advisory:

https://technet.microsoft.com/en-us/library/security/3009008.aspx

See especially part 3: ""Disable SSL 3.0 in Windows"", but note that a similar registry setting exists for CLIENT.

Schannel works differently from openssl: SChannel can override default protocols (in registry), but cannot override ""enabled"" protocols (also in registry). A user or global administrator can force AMQP 1.0 SChannel connections to succeed during protocol negotiations over SSLv3 despite Proton's best efforts.

Possible solutions on Windows:

1. always fail after the fact if an SSLv3 connection has actually been established

2. succeed for SSLV3 if registry allows it, but log a warning

3. succeed for SSLV3 only if registry allows it and env variable PROTON_SSLV3_UNSAFE=override_by_user

Since SSLv3 is not considered secure, and there are no known legacy AMQP 1.0 that are unable to provide TLS1.0 or above, #1 seems to provide the greatest security without known inconvenience.

"
Bug,QPID-6160,12748712,CLONE - [CPP Broker] [CPP Client] Disable SSLv3 support,kgiusti,kgiusti,Closed,Fixed,2015-03-19 12:23,C++,C++ Broker,C++ Client,,,,,,"SSLv3 is vulnerable to CVE-2014-3566, and will not fixed. 

Wherever a seure connection is established we should ensure that SSLv3 is not in the supported protocols."
Bug,QPID-5973,12732768,HA cluster state may get stuck in recovering,aconway,aconway,Closed,Fixed,2015-03-19 12:23,C++,C++ Clustering,,,,,,,"HA brokers can become stuck in ""recovering"" or ""catchup"" state when running transactional clients with multiple failovers.

To reproduce, in one window run:

    while qpid-txtest2 -b 20.0.20.200 --total-messages 1000 --connection-options '{reconnect:true}' --tx-count 1000; do true; done

In another window run (ha script attached):

    while ha wait -a; do sleep .5; ha kill;  done

After some time one or more brokers willl become stuck in catchup or recovering state."
Bug,QPID-6324,12768161,adjust when default timeout is applied,gsim,gsim,Closed,Fixed,2015-03-19 12:23,C++,C++ Client,,,,,,,"At present a default non-zero timeout is applied even if auto-delete is explicitly on, which is not intuitive. A default, non-zero timeout is not set when the link is explicitly marked unreliable even though unreliable is the default and if implicitly unreliable the timeout is applied. This is on the 0-10 codepath only."
Bug,QPID-6321,12768157,Can't build against latest 0.9,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,C++ Client,,,,,,Change to pn_delivery_tag_t breaks build.
Bug,QPID-6329,12768943,TypeError on qpid.auto_delete_timeout assertion ,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Client,,,,,,,"Steps to Reproduce:
1. create a subscription with auto_delete_timeout defined in the link
# ./drain ""amq.direct;{link: {name: test_durable_subscription_timed_autodel-30, timeout: 30}}"" -f &
2. assert the subscription queue for qpid.auto_delete_timeout
# ./spout ""test_durable_subscription_timed_autodel-30;{assert: always, node: {x-declare: {arguments: {qpid.auto_delete_timeout: 30}}}}""
3. TypeError
Option qpid.auto_delete_timeout does not match for test_durable_subscription_timed_autodel-30, expected F8:int64(30), got F4:int32(30)

Actual results:
TypeError on qpid.auto_delete_timeout assertion

Expected results:
No TypeError on qpid.auto_delete_timeout assertion

Reported here: https://bugzilla.redhat.com/show_bug.cgi?id=1184124"
Bug,QPID-5033,12660978,[Windows C++ client] An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full,cliffjansen,scholzj,Closed,Fixed,2015-03-19 12:22,C++,C++ Client,,,,,,,"As discussed on the user mailing list (http://qpid.2158936.n2.nabble.com/Qpid-throwed-WSAENOBUFS-while-receiving-data-from-a-broker-td7592938.html), when receiving a large amounts of messages over SSL using a receiver prefetch, the clients fails with an exception ""An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full"". This exception seems to originate from the SslAsynchIO class, method sslDataIn.

Decreasing the capacity seems to improve the frequency with which the problem appears. However with 1MB messages, even capacity 1 doesn't seem to work. The problem seems to be quite easy to reproduce using following scenario:

1) Create a large queue on a broker (C++ / Linux)
2) Start feeding messages into the queue using C++/Linux program (in my case I used approximately 1kB messages)
3) Connect with a receiver (C++/Windows) using SSL and prefetch 1000 (no client authentication, I used username & password)
4) Wait few seconds to see the error in the receiver

The source code of the receiver as well as the full trace+ log are attached. Please let me know should you need some additional information."
Bug,QPID-5975,12732774,HA extra/missing messages when running qpid-txtest2 in a loop with failover. ,aconway,aconway,Closed,Fixed,2015-03-19 12:22,C++,C++ Clustering,,,,,,,"Running qpid-txtest2 in a loop against a 3 node cluster while killing primary brokers to force failover eventually results in the test failing due to extra or missing messages.

To reproduce:

In separate windows:
$ while ha stat; qpid-txtest2 -b 20.0.20.200 --total-messages 100 --connection-options '{reconnect:true}' --messages-per-tx 10 --tx-count 10; do true; done
$ while ha wait -a 2; do sleep .5; ha kill;  done # ha script  attached.

Results:

Eventually (up to 10 minutes) the test fails with a message like: 

The following ids were missing:
    'msg-100'
    'msg-51'
    'msg-52'
    'msg-53'

OR 

The following extra ids were encountered:
    'msg-1'
    'msg-1'
    'msg-10'


Expected result: 

Test runs forever, no failures."
Bug,QPID-6444,12781190,Build fails due to unused function warning,astitcher,astitcher,Closed,Fixed,2015-03-19 12:22,C++,C++ Broker,C++ Client,,,,,,"[0.32 RC fails to build with default instructions]

[59/254] Building CXX object src/CMake....dir/qpid/broker/amqp/Connection.cpp.o
FAILED: /usr/lib64/ccache/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -D_IN_QPID_BROKER -Damqp_EXPORTS -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -DNDEBUG -fPIC -I/home/andrew/Work/qpid/src-released/qpid/cpp/src -I/home/andrew/Work/qpid/src-released/qpid/cpp/src/../include -Isrc -Isrc/../include -I/usr/include/nss3 -I/usr/include/nspr4    -pthread -MMD -MT src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o -MF src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o.d -o src/CMakeFiles/amqp.dir/qpid/broker/amqp/Connection.cpp.o -c /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Connection.cpp
/home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/broker/amqp/Connection.cpp:457:13: error: ?쁲td::string qpid::broker::amqp::{anonymous}::convert(pn_delivery_tag_t)??defined but not used [-Werror=unused-function]
 std::string convert(pn_delivery_tag_t in)
             ^
cc1plus: all warnings being treated as errors
[107/254] Building CXX object src/CMak...pid/messaging/amqp/AddressHelper.cpp.o
FAILED: /usr/lib64/ccache/c++   -DXQ_EFFECTIVE_BOOLEAN_VALUE_HPP -Dqpidmessaging_EXPORTS -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -DNDEBUG -fPIC -I/home/andrew/Work/qpid/src-released/qpid/cpp/src -I/home/andrew/Work/qpid/src-released/qpid/cpp/src/../include -Isrc -Isrc/../include -I/usr/include/nss3 -I/usr/include/nspr4    -pthread -fno-visibility-inlines-hidden -fvisibility=hidden -MMD -MT src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o -MF src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o.d -o src/CMakeFiles/qpidmessaging.dir/qpid/messaging/amqp/AddressHelper.cpp.o -c /home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/messaging/amqp/AddressHelper.cpp
/home/andrew/Work/qpid/src-released/qpid/cpp/src/qpid/messaging/amqp/AddressHelper.cpp:141:6: error: ?쁞ool qpid::messaging::amqp::{anonymous}::contains(const List&, const string&)??defined but not used [-Werror=unused-function]
 bool contains(const Variant::List& list, const std::string& item)
      ^
cc1plus: all warnings being treated as errors
"
Bug,QPID-5966,12732276, HA mixing tx enqueue and non-tx dequeue leaves extra messages on backup,aconway,aconway,Closed,Fixed,2015-03-19 12:22,C++,C++ Clustering,,,,,,,"Description of problem:

With HA enabled, 2 or more node cluster. If a message is enqueued in a transaction, and then dequeued with no transaction, the message is left on the backup brokers.

Version-Release number of selected component (if applicable):

Up to trunk r1615992, 0.22-mrg f22fae4

How reproducible: 100%

Steps to Reproduce:

qpid-send -a 'q;{create:always}' -b 20.0.20.200 --content-string foo --tx 1
qpid-receive -a 'q;{create:always}' -b 20.0.20.200

Then on each node:
qpid-stat -q --ha-admin

Actual results:

Primary q is empty, backup q still has 1 message
Message is enqueued twice on backup and dequeued only once.

Expected results:

Primary and backup q empty, message enqueued and dequeued once on primary and backup

Additional info:

With a tx dequeue (add --tx 1 to qpid-receive) the message is removed completely on the backup so at first glance things appear OK. However qpid-stat shows it is enqueued and dequeued _twice_ which is incorrect.

Using the python client there is still a message left on the backup, but there is only 1 enqueue and no dequeue, rather than 2 enqueues and 1 dequeue."
Bug,QPID-6123,12744279,[C++ Messaging] Build fail - proton no longer exports pn_transport_error(),gsim,chug,Closed,Fixed,2015-03-19 12:22,C++,C++ Client,,,,,,,"Commit r1627444 changes the proton transport error interface. See http://svn.apache.org/viewvc/qpid/proton/trunk/proton-c/include/proton/transport.h?r1=1627444&r2=1627443&pathrev=1627444

The build failure is:
{noformat}
18>..\..\src\qpid\messaging\amqp\ConnectionContext.cpp(811) : 
  error C3861: 'pn_transport_error': identifier not found
{noformat}

Rafi explains on the mailing list:
{panel}
I removed it because a previous commit had changed it to just return NULL.
I figured it would be better to break things than to fail silently. If this
is a problem I can add easily it back and convert what is held in the
condition into the error, but using the condition would be preferrable as
it can contain the full range of AMQP error information whereas the error
will just have a string description.

--Rafael
{panel}
Which is fine but qpid won't build until we figure out how to deal with it.

Further, this change is a painful complication to the proton 0.7 to 0.8 transition. Possibly we can restore pn_transport_error() to keep returning the error string but mark it as deprecated.
"
Bug,QPID-6416,12777669,Mutex.h:116: void qpid::sys::Mutex::lock(): Assertion `0' failed. - during Messaging shutdown,chug,chug,Closed,Fixed,2015-03-03 18:54,C++,C++ Client,,,,,,,The C++ code uses Qpid Messaging and fails with the summary message about half the time.
Bug,QPID-5841,12723389,Allow SSL hostname verification to be disabled,gsim,gsim,Closed,Fixed,2015-01-29 19:47,C++,C++ Client,,,,,,,"sometimes the certficate doesn't match the address used to establish the connection, and it would be convenient to be able to disable the verification for those cases

"
Bug,QPID-5942,12730611,qpid HA cluster may end-up in joining state after HA primary is killed,aconway,aconway,Closed,Fixed,2014-12-01 20:35,C++,C++ Clustering,,,,,,,"See also: https://bugzilla.redhat.com/show_bug.cgi?id=1117823

Description of problem:

qpid HA cluster may end-up in joining state after HA primary is killed.

Test scenario.
Let's have 3 node qpid HA cluster, all three nodes are operational.
Then a sender is executed and sending to queue (pure transactional with durable messages and durable queue address).
During that process primary broker is killed multiple times.
After N'th primary broker kill cluster is no longer functional as qpid brokers are ending all in joining states:

[root@dhcp-lab-216 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining
[root@dhcp-x-216 ~]# clustat
Cluster Status for dtests_ha @ Wed Jul  9 14:38:44 2014
Member Status: Quorate

 Member Name                                   ID   Status
 ------ ----                                   ---- ------
 192.168.6.60                                      1 Online, Local, rgmanager
 192.168.6.61                                      2 Online, rgmanager
 192.168.6.62                                      3 Online, rgmanager

 Service Name                         Owner (Last)                         State         
 ------- ----                         ----- ------                         -----         
 service:qpidd_1                      192.168.6.60                         started       
 service:qpidd_2                      192.168.6.61                         started       
 service:qpidd_3                      192.168.6.62                         started       
 service:qpidd_primary                (192.168.6.62)                       stopped       


[root@dhcp-x-165 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining

[root@dhcp-x-218 ~]# qpid-ha status --all
192.168.6.60:5672 joining
192.168.6.61:5672 joining
192.168.6.62:5672 joining


I believe the key to hit the issue is to kill the newly promoted primary soon after it starts appearing in starting/started state in clustat.

My current understanding is that if we have 3 node cluster then applying any failures to single node at one time should be handled by HA. This is what the testing scenario does:
A    B    C (nodes)
pri  bck  bck
kill 
bck  pri  bck
     kill
bck  bck  pri
          kill
...
pri  bck  bck
kill
bck  bck  bck


It looks to me that there is short time when promoting new primary when kill causes (of such primary newbee) causes promotion procedure to stuck in all joining.

I haven't seen such behavior in past, either we are now more sensitive to such case (after -STOP case fixes) or the durability turned on rapidly raises the probability.


Version-Release number of selected component (if applicable):
# rpm -qa | grep qpid | sort
perl-qpid-0.22-13.el6.i686
perl-qpid-debuginfo-0.22-13.el6.i686
python-qpid-0.22-15.el6.noarch
python-qpid-proton-doc-0.5-9.el6.noarch
python-qpid-qmf-0.22-33.el6.i686
qpid-cpp-client-0.22-42.el6.i686
qpid-cpp-client-devel-0.22-42.el6.i686
qpid-cpp-client-devel-docs-0.22-42.el6.noarch
qpid-cpp-client-rdma-0.22-42.el6.i686
qpid-cpp-debuginfo-0.22-42.el6.i686
qpid-cpp-server-0.22-42.el6.i686
qpid-cpp-server-devel-0.22-42.el6.i686
qpid-cpp-server-ha-0.22-42.el6.i686
qpid-cpp-server-linearstore-0.22-42.el6.i686
qpid-cpp-server-rdma-0.22-42.el6.i686
qpid-cpp-server-xml-0.22-42.el6.i686
qpid-java-client-0.22-6.el6.noarch
qpid-java-common-0.22-6.el6.noarch
qpid-java-example-0.22-6.el6.noarch
qpid-jca-0.22-2.el6.noarch
qpid-jca-xarecovery-0.22-2.el6.noarch
qpid-jca-zip-0.22-2.el6.noarch
qpid-proton-c-0.7-2.el6.i686
qpid-proton-c-devel-0.7-2.el6.i686
qpid-proton-c-devel-doc-0.5-9.el6.noarch
qpid-proton-debuginfo-0.7-2.el6.i686
qpid-qmf-0.22-33.el6.i686
qpid-qmf-debuginfo-0.22-33.el6.i686
qpid-qmf-devel-0.22-33.el6.i686
qpid-snmpd-1.0.0-16.el6.i686
qpid-snmpd-debuginfo-1.0.0-16.el6.i686
qpid-tests-0.22-15.el6.noarch
qpid-tools-0.22-13.el6.noarch
ruby-qpid-qmf-0.22-33.el6.i686


How reproducible:
rarely, timing is the key

Steps to Reproduce:
1. have configured 3 node cluster
2. start the whole cluster up
3. execute transactional sender to durable queue address with durable messages and reconnect
4. repeatedly kill the primary broker once it is promoted


Actual results:
  After few kills cluster ends up not functional all in joining. Ability to bring qpid HA down by inserting single isolated failures to newly being promoted brokers.

Expected results:
  Qpid HA should be single failure at one time tolerant.

Additional info:
  Details on failure insertion:
    * kill -9 `pidof qpidd` is the failure action
    * Assuming the duration between failure insertion and primary is ready to serve named as T1
    * failure insertion period T2 > T1 i.e. there are no cummulative failures inserted while HA is getting through new primary promotion
      -> this fact (in my view) proves that there is real issue"
Bug,QPID-6069,12738917,Does not compile under C++11 on FreeBSD,astitcher,astitcher,Closed,Fixed,2014-09-26 21:40,C++,C++ Broker,C++ Client,,,,,,There are some small compile problems that have crept in over the 0.30 release cycle that prevent qpid from compiling with clang++ and libc++ under FreeBsd 10.
Bug,QPID-5737,12711558,[AMQP 1.0] client can hang if session window is moved after last message is sent,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"If the server to which a client is connected sets a session window and this gets exhausted, then the proton engine will stop emitting the transfers. If the window isn't moved until after the client stops trying to do any output (e.g. after sending is finished), then the moving of the window doesn't cause output to be triggered.

E.g. using latest dispatch router, send 1000 messages reliably through router to a single receiver. The sender often hangs on session.sync()."
Bug,QPID-5788,12716805,Delay initialization of NSS library until the creation of first SSL connection.,gsim,haripyla,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"There are two issues here:
===Issue 1===
When a qpid C++ client sets the SSL client environment variables programmatically prior(in program order) to opening a connection, qpid seems to ignore the environment variables. This issue was reported to the mailing list. Please find it at http://mail-archives.apache.org/mod_mbox/qpid-users/201405.mbox/%3C5374D926.3000501@vt.edu%3E 

A simple example to reproduce this issue:
===source=== 
#include <qpid/messaging/Connection.h>
#include <cstdlib>
#include <iostream>
#include <stdlib.h>

using namespace qpid::messaging;

int main()
{
    const char* url = ""localhost:5671"";
    std::string connectionOptions = ""{username:admin,password:admin,transport:ssl}"";

    setenv(""QPID_SSL_CERT_NAME"", ""QpidCppClient"", 1);
    setenv(""QPID_SSL_CERT_DB"", ""/tmp/test/client_db"", 1);
    setenv(""QPID_SSL_CERT_PASSWORD_FILE"", ""/tmp/test/qpid-client-pfile"", 1);

    Connection connection(url, connectionOptions);

    try
    {
        connection.open();
    }

    catch (const std::exception& e)
    {
        std::cout << e.what() << ""\n"";
        return (-1);
    }

    connection.close();
    return 0;
}
===compilation===
g++ -o test test.cpp -lqpidmessaging

===error message===
Unknown protocol: ssl (/builddir/build/BUILD/qpid-0.28-rc2/cpp/src/qpid/client/Connector.cpp:52)

Gordon responded to this issue at http://mail-archives.apache.org/mod_mbox/qpid-users/201405.mbox/%3C5379D276.3040609@redhat.com%3E

This method of initialization has another side-effect and leads to the following:
===Issue 2===
Due to this early initialization, the qid C++ precludes creating multiple processes which in turn can create connections to the broker. See below example. 

===example===
#include <qpid/messaging/Connection.h>
#include<cstdlib>
#include<iostream>
#include<stdlib.h>

using namespace qpid::messaging;

int foo()
{
     const char* url = ""localhost:5672"";
     std::string connectionOptions = 
""{username:test,password:test,transport:ssl}"";

     Connection connection(url, connectionOptions);

      try
      {
         connection.open();
      }

     catch (const std::exception& e)
     {
         std::cout << e.what() << ""\n"";
     }

     connection.close();
     return 0;
}

int main()
{
     int retval = -1;

     retval = fork();
     if (retval == 0)
         foo();
     else
         sleep(5);

     return 0;
}

===error message===
On C++ qpid broker:
May 26 20:50:00 qa1 qpidd[21500]: 2014-05-26 20:50:00 [System] error 
Error reading socket: Success(0)

On C++ qpid client:
2014-05-26 20:50:00 [Security] warning Connect failed: Failed: NSS error 
[-8023] 
(/builddir/build/BUILD/qpid-0.28-rc2/cpp/src/qpid/sys/ssl/SslSocket.cpp:156)
2014-05-26 20:50:00 [Client] warning Connection  closed

This issue has been reported at http://mail-archives.apache.org/mod_mbox/qpid-users/201405.mbox/%3C5383E31E.6020506@vt.edu%3E

and Gordon's response to it is at http://mail-archives.apache.org/mod_mbox/qpid-users/201405.mbox/%3C53845426.6090400@redhat.com%3E
"
Bug,QPID-5707,12708808,"'#' implies create for queue, but not topic/exchange",gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,only affects 0-10. on 1.0 the node is created for '#' regardless of type
Bug,QPID-5736,12711455,[AMQP 1.0] synchronous send not unblocked by settled message,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"...unless the message is also accepted. Should not block once message has been settled however, regardless of final state."
Bug,QPID-5887,12726671,transaction should always be aborted on failover,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"At present, if a commit is the first operation after a failover, it will be aborted. However if any other operation (e.g. a send or accept) is done after the failover, but before the commit, then the subsequent commit will succeed.

This hides the failover from the client which is the wrong thing to do for a transactional session.

The client should always abort the transaction on a failed session, and not try to failover transparently. This is what would happen if the commit failed due to some internal error on the broker (e.g. no space on disk or whatever). "
Bug,QPID-5720,12710149,HA exception raised by the store for durable transactions,aconway,aconway,Closed,Fixed,2014-09-26 15:43,C++,C++ Clustering,,,,,,,"Description of problem:
While playing with the new cluster implementation, I came across the following problem. When the qpid-txtest tool is executed with ""--durable yes --transfer yes"" options (that is, the journal is used on the brokers and messages are transferred from one queue to another), the journal on the broker raises an exception:

[root@mrg-qe-11 ~]# /usr/libexec/qpid/tests/qpid-txtest --init yes --transfer yes --check yes --durable yes --broker 192.168.101.251
Transfering from tx-test-1 to tx-test-2
Transfering from tx-test-2 to tx-test-1
Drained 9 messages from tx-test-1
2014-04-15 07:53:16 [Client] warning Broker closed connection: 320, Queue tx-test-2: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0xb) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268)
Queue tx-test-2: async_dequeue() failed: jexception 0x0b02 wmgr::dequeue_check() threw JERR_MAP_LOCKED: Record ID locked by a pending transaction. (drid=0xb) (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/linearstore/MessageStoreImpl.cpp:1268)

Version-Release number of selected component (if applicable):
qpid-cpp-0.22-37.el6.x86_64

How reproducible:
100%

Steps to Reproduce:
1. Configure and start HA cluster.
2. Execute qpid-txtest tool with ""--durable yes --transfer yes"" options.
3.

Actual results:
journal exception is raised.

Expected results:
No exception.
"
Bug,QPID-5814,12721071,default to utf9 for strings in Variant::parse(),gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,There is really little reason to treat them as binary by default in that context. If need that can always be overridden manually.
Bug,QPID-5886,12726451,C++  Broker OutgoingMessage change exposes Completion handle export issue on Windows,chug,chug,Closed,Fixed,2014-09-26 15:43,C++,C++ Broker,C++ Client,,,,,,"Windows builds have been failing mysteriously for me for a few weeks[1]. I found the issues/ QPID-5828 r1604952 changed OutgoingMessage such that the Completion object now needs to access Handle<CompletionImpl>::isValid().

Simply instantiating the Handle superclass (r1525706 for example) didn't work. On windows the classes won't export from a .h file but need to come from .cpp files. Review is coming up shortly.

[1] Why some builds work and some don't is unsolved."
Bug,QPID-5883,12726039,Error message for certain authentication failures is not clear,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"E.g. when specifying PLAIN but not specifying username and password, or when trying to choose an unsupported mechanism."
Bug,QPID-5719,12710114,HA becomes unresponsive once any of the brokers are SIGSTOPed,aconway,aconway,Closed,Fixed,2014-09-26 15:43,C++,C++ Clustering,,,,,,,"See also: https://bugzilla.redhat.com/show_bug.cgi?id=1086638

Description of problem:

qpid HA becomes unresponsive once any of the brokers are SIGSTOPed.

There are three different cases:
a] stopped ALL brokers
b] stopped the primary
c] stopped a backup

In any of above listed cases following observations were made:

a-c]    RHCS clustat is just fine and report everything is just ok
a-c]    qpid-ha (status --all) hangs
a,b,c*] any other clients are indefinitely blocked
        a-b] cases directly at the beginning
        c] case at the end, client able to recover after minute or so,
           due to connection timeout

In fact this defect also proves that qpid-ha can be out of sync when compared to clustat as tracked by BZ.

The expectations are:
 * a] quorum lost HA down (same as kill -9 to all nodes)
      no clients able to communicate
 * b] promotion of new primary, there has to be mechanism to get rid of stopped process
      clients should be able to communicate after recovery
 * c] unresponsive backup should get restarted
      clients should be able to communicate after duration when backup is detected as unresponsive

 * Generally better integration Qpid HA environment <-> RHCS is needed
   aka SIGSTOP detection
 * Heartbeat primary <-> backups probably needed
"
Bug,QPID-6012,12734753,HA fix ACL notice log message about accounting for TX queues.,aconway,aconway,Closed,Fixed,2014-09-26 15:42,C++,C++ Clustering,,,,,,,"HA module creates temporary TX queues but does not go thru the  ACL accounting code. This causes N+1 notice log messages from ACL module for every N transactions. Its an old bug but was exposed by recent changes to ACL logic. The fix is trivial & low risk, there are no functional changes, but without the fix the log files are extremely cluttered with notice level (highest below warn) scary looking log messages.

Steps to Reproduce:

Start a HA cluster with >1 member

qpid-send --tx 1 -a 'qq;{create:always}' -b localhost:6000

Actual results:

Primary broker log contains
2014-08-15 11:19:27 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:3ba46af9-e37c-40f1-ae7f-1bdd8fdf19ea' not found in queue owner map
2014-08-15 11:19:27 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:2e2de2d4-d7b0-48b5-8fac-7f2680916106' not found in queue owner map
2014-08-15 11:19:27 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:230050dd-28cf-4f09-a096-7df7ab404c7f' not found in queue owner map
2014-08-15 11:19:34 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:a899c2fb-6be3-4e34-a9a5-16ab2f22d625' not found in queue owner map
2014-08-15 11:19:34 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:c2a0d1b0-e355-4c76-a0b9-d7dcdb0f7479' not found in queue owner map
2014-08-15 11:19:34 [Security] notice ACL resource counter: Queue 'qpid.ha-tx:b9ecb26c-94cb-453b-9e18-da377d7d6587' not found in queue owner map


Expected results:

No ACL related messages

Additional info:
[reply] [??  Private Comment 1"
Bug,QPID-5865,12724737,The client and broker heartbeat code can get confused when the system time changes,astitcher,astitcher,Closed,Fixed,2014-09-26 15:42,C++,C++ Broker,C++ Client,,,,,,"The underlying timekeeping code in C++ qpid currently uses CLOCK_REALTIME which is related to wallclock time and can go backwards and skip time forwards (either due to NTP or administrator action).

This is not ideal because it can cause false timeouts to occur based on the system time rather than elapsed time.

It would be better for most timing to be based on CLOCK_MONOTONIC which is steadily increasing time based on the system uptime. That will avoid problems due to the system time changing."
Bug,QPID-5711,12709264,HA cannot promote primary if SASL security is enabled.,aconway,aconway,Closed,Fixed,2014-09-26 15:42,C++,C++ Clustering,,,,,,,"Reported on qpid-user list:

  Yes, I have the cyrus packages installed on the nodes.

# rpm -qa | grep cyrus
cyrus-sasl-plain-2.1.23-13.el6_3.1.x86_64
cyrus-sasl-lib-2.1.23-13.el6_3.1.x86_64
cyrus-sasl-md5-2.1.23-13.el6_3.1.x86_64
cyrus-sasl-gssapi-2.1.23-13.el6_3.1.x86_64
cyrus-sasl-devel-2.1.23-13.el6_3.1.x86_64
cyrus-sasl-2.1.23-13.el6_3.1.x86_64

To narrow down, I've simplified the configuration without HA, see below

===configuration===
i) version 0.26 (built from source)

ii) /etc/qpid/qpidd.conf
acl-file=/etc/qpid/qpidd.acl
auth=yes
realm=QPID
no-data-dir=yes
sasl-config=/etc/sasl2/
log-to-stderr=no
log-enable=debug+
log-to-syslog=yes

# /etc/init.d/qpidd start
Starting Qpid AMQP daemon:                                 [  OK ]

# qpid-config queues -a test/test@192.168.10.211:5672 --sasl-mechanism=PLAIN
Queue Name                                Attributes
=================================================================
5b1b0c2e-bc6f-431b-b955-83ce5680d4ac:0.0  auto-del excl

and things work as expected. However when I enable HA and when the 
brokers try to communicate among themselves
I get the following error.

===error===
Promoting qpid daemon to cluster primary: Error in sasl_client_start 
(-4) SASL(-4): no mechanism available: No worthy mechs found

See also: https://bugzilla.redhat.com/show_bug.cgi?id=1089353

"
Bug,QPID-5845,12723593,"[AMQP 1.0] auto delete delay specified in pollicy is overridden by link, even when not explicit",gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"The setting inherited from topic policy gets clobbered by the value retrieved from the links terminus timeout, whether or not a value was actually requested by the client.

The topic policy value, if specified, should actually override anything in the link."
Bug,QPID-5858,12724165,Session::checkError() throws exceptions of wrong type,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,Only those inherting from qpid::types::Exception should be thrown. The qpid::Exception hierarchy from the old qpid::client code should be caught and wrapped as these are no longer even exposed.
Bug,QPID-5560,12695597,HA tests do not use AMQP 1.0,aconway,aconway,Closed,Fixed,2014-09-26 15:42,C++,C++ Clustering,,,,,,,"The HA tests in ha_tests.py do not use AMQP 1.0, they only use AMQP 0-10.

HA replication itself currently only uses AMQP 0-10, this is intended and will not be fixed in the short term.  However clients using AMQP 1.0 should be able to interact with HA brokers via the automatic broker translation between 1.0 and 0-10. This is the aspect that needs to be tested in ha_tests.py

We need to:
- Modify the HA tests to use AMQP 1.0 by default if it is enabled by the build (make it configurable to use 0-10 or 1.0)
- Make any necessary changes to python swigged client and C++ clients to use AMQP 1.0 for the HA tests.

"
Bug,QPID-5908,12728513,[AMQP 1.0] annotations clobber application properties,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"Rather than merging the annotations in with the application properties, the current code is replacing them. The workaround is to use the 'nest_annotations' connection option, which when set to true will result in the annotations being presented as a nested map."
Bug,QPID-5985,12733201,nextReceiver() with IMMEDIATE duration always returns null,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"A call to nextReceiver() with IMMEDIATE duration always returns null even if there are already incoming messages available.

This was caused by the fix to QPID-4786."
Bug,QPID-5882,12725782,[AMQP 1.0] Authentication failures not handled correctly,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"An exception is thrown on the IO thread, which is then caught in the IO layer and the resulting error on closing is less intelligible and doesn't produce a specific exception type for application calls."
Bug,QPID-5366,12680333, qpid segfaults in qpid::ha::BrokerReplicator::disconnected,aconway,aconway,Closed,Fixed,2014-08-19 19:02,C++,C++ Clustering,,,,,,,"Relocating the qpidd-primary service while the cluster is under load was causing sporadic core dumps in BrokerReplicator::disconnected. For details see:

https://bugzilla.redhat.com/show_bug.cgi?id=1030608"
Bug,QPID-6015,12734824,HA Python QMF console raises exception due to HA subscriptions.,aconway,aconway,Closed,Fixed,2014-08-19 15:39,C++,C++ Clustering,,,,,,,"A python qmf console that queries subscriptions can crash when used with a HA cluster. 

To reproduce:

1. Start a 3 node HA cluster
2. qpid-send -b 20.0.20.200 -m 1000 -a 'qq;{create:always}'
3. Kill the primary, let the cluster fail over.
4. qpid-stat -u -b 20.0.20.200

Result:
Failed: IndexError - pop from empty list

Expected result:
No error.

See also: https://bugzilla.redhat.com/show_bug.cgi?id=1117708"
Bug,QPID-5586,12697786,qpid::messaging::Session::nextReceiver needs to be able to throw a distinct exception if the session is closed,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"If a qpid messaging connection or (I think) a session using the 0-10 protocol is closed in one thread whilst another thread is in Session::nextReceiver(...) then qpid::ClosedException will be thrown.

This is definitely wrong! (There is no way to catch this exception using only the messaging library).

Using the 1.0 protocol a viable exception is thrown (qpid::messaging::SessionError) but there is no way to tell that the session has been closed rather than a more general error.

It seems that there needs to be a new qpid::messaging exception to cover the case that you were waiting for a receiver and the whole session has gone away. Certainly you need to know that you can't refer to the session any more.

It cannot be sufficient to assert that you must keep sessions around until all the nextReceiver() calls using them are finished with the current API as there is no way to preempt those calls externally. So a service loop waiting to for a receiver to process will be stuck waiting until the session closes. Even if you poll by using timeouts there is no way on return to tell that the session you were just listening on is dead."
Bug,QPID-5513,12691101,HA backup fails if number of replicated queues exceeds number of channels.,aconway,aconway,Closed,Fixed,2014-06-03 15:35,C++,C++ Clustering,,,,,,,"HA uses a single link and a session per queue to replicate queue data. That means the number of replicated queues is limited by the number of channels, which is 32k in current Qpid.

To reproduce:
- create a 2 node cluster.
- declare 32769 queues

Actual Result:
- no error observed by the client declaring the queues or in the primary log.
- backup broker exits with a critical error saying ""not enough channels""

In the short term it is not straightforward to remove the limit, however the error reporting needs to be fixed:

Desired result:
- client declaring the queues receives a ""resource-limit-exceeded"" exception with appropriate message.
- primary logs an error indicating we exceeded the replicated queue limit
- primary and backup broker continue to function normally."
Bug,QPID-5378,12681793,[AMQP 1.0] zero capacity receiver does not reissue credit on reconnect,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"If you have a receiver with zero capacity blocked on a fetch when a reconnect is triggered, then on establishing a new connection the link is recreated correctly, but the credit required is not reissued."
Bug,QPID-5476,12688860,ABI check script isn't robust enough,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Build,,,,,,,"The check-abi script has robustness issues in particular:
* It is vulnerable to failing due to different sort orders for different executables, if not everything respects the current locale's sort order.
* It uses non portable command lines for sed and mktemp."
Bug,QPID-5379,12681934,[AMQP 1.0] Sasl layer with encryption is broken,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,E.g. if using DIGEST-MD5 with default ssf. The client will print an error and core dump after the authentication completes.
Bug,QPID-5623,12699892,[C++ Messaging Client - amqp1.0] throws qpid::Exception instead of qpid::types::Exception,chug,chug,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"Running various client invalid URL tests gets different results on amqp 0-10 vs 1.0.

Both versions get into Url::parse and throw Url::Invalid();

Under 0-10 (which works as expected) has
{noformat}
void ConnectionImpl::open()
{
    qpid::sys::AbsTime start = qpid::sys::now();
    qpid::sys::ScopedLock<qpid::sys::Semaphore> l(semaphore);
    try {
        if (!connection.isOpen()) connect(start);
    }
    catch (const types::Exception&) { throw; }
    catch (const qpid::Exception& e) { throw messaging::ConnectionError(e.what()); }
}
{noformat}
where the Url throw is caught as a qpid::Exception and rethrown as a messaging::ConnectionError.

Under amqp1.0 the Url::Invalid  bleeds up to the .NET client interface and is not handled correctly.

Maybe there are two things to fix:

1. Make the amqp1.0 client send messaging:: exceptions only.
2. Beef up the .NET binding to catch various other exceptions and relay them into the .NET client when possible.

As is the .NET clients see an exception of InteropServices::SEHUnhandledException which offers no hint of what went wrong.
"
Bug,QPID-5529,12692493,[AMQP 1.0] invalid property type not handled correctly,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"E.g. the following will hang waiting for completion of deliveries on closing the connection:
 spout --connection-options ""{  protocol : 'amqp1.0' }""  --property ""x-amqp-group-sequence=test""  amq.direct 

Any error on encoding message leaves an invalid delivery record in buffer, which as it was never sent, never settles causing the hang on close (or sync)."
Bug,QPID-5395,12682891,[AMQP 1.0] direct proton tracing into qpids own logging,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,At present protons tracing is entirely distinct from qpidcpp's logging (whether qpidd or qpid:messaging). This means you can't direct the tracing to a file or to syslog. Traces from concurrent connections often get interleaved making them very hard to read.
Bug,QPID-5544,12693599,HA memory leak in backup broker after shutdown.,aconway,aconway,Closed,Fixed,2014-06-03 15:35,C++,C++ Clustering,,,,,,,"Valgrind shows memory leaks in backup broker after taking these steps:

1. Start primary broker
2. Create a queue
3. Start backup broker with valgrind
4. Wait to see ""Joining established cluster"" message from backup
5. Shut down backup broker

Valgrind will reprort memory leaks. 

For more detail see: https://bugzilla.redhat.com/show_bug.cgi?id=1004411"
Bug,QPID-5356,12679892,Windows can provide an unspecified client certificate in SSL negotiation,cliffjansen,cliffjansen,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"By default, the SChannel package from Microsoft will attempt to guess an appropriate client certificate during SSL/TLS negotiation if a client certificate is requested by the server and none is supplied by the client in its credentials structure.  This behavior can be changed to only work with an explicitly specified certificate (if any) by the client.

By doing so, the behavior of clients is made more consistent across platforms and this eliminates unexpected false positives in testing.
"
Bug,QPID-5524,12692200,Missing ssl-cert-name connection argument processing in AMQP 1.0. cpp client,cliffjansen,cliffjansen,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"The ssl-cert-name connection option should work, including overriding the value set in the QPID_SSL_CERT_NAME environment variable for AMQP 1.0 connections.  This would match the AMQP 0-10 behavior."
Bug,QPID-5446,12686950,[AMQP 1.0] 'group sequence id' field is exposed via incorrect property name,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,Should be 'x-amqp-group-sequence' rather than 'x-amqp-qroup-sequence' (i.e. change the 'q' to a 'g')
Bug,QPID-5384,12682381,[AMQP 1.0] can't assert on autodelete property,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,this is a result of it actually being communicated as a lifetime-policy (at least in the case of queues)
Bug,QPID-5584,12697111,[AMQP 1.0] LinkError thrown when NotFound is expected,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,E.g. when creating a sender or receiver for a non-existent node.
Bug,QPID-5427,12685124,It is possible to mask critical logging messages,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Broker,C++ Client,,,,,,"As far as I understand it the entire point of log messages at the ""critical"" level is that they cannot be turned off at all. That is what critical means - the user *must* be informed of the confition being logged.

Unfortunately for a little while now it has been possible to turn all log levels off by specifying ""--log-disable trace+"" or using ""--log-enable !trace+"".
"
Bug,QPID-5568,12696261,HA C++ qpid::messaging AMQP 1.0 client failover logging is not clear.,aconway,aconway,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,"The qpid::messaging AMQP 1.0 protocol logging does give clear information
about reconnection during failover. It does not log all reconnect attempts.

see also 
https://bugzilla.redhat.com/show_bug.cgi?id=1050856
https://reviews.apache.org/r/17856/"
Bug,QPID-5435,12685646,[AMQP 1.0] modify qpid-send to use get-/set- ContentObject() for strings as well as maps,gsim,gsim,Closed,Fixed,2014-06-03 15:35,C++,C++ Client,,,,,,,At present e.g. --content-string xyz will be sent as a Data section (i.e. binary) as the test utility sets the actual message bytes. It would be preferable to send it as utf8 data (i.e. an AmqpValue section of type string).
Bug,QPID-5658,12706289,C++ code not compiling with libc++,astitcher,astitcher,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,FreeBSD 10 now uses a new compiler/library chain as default. The new C++ standard library has some small differences than the GNU C++ standard library.
Bug,QPID-5434,12685645,[AMQP 1.0] timestamps sent with incorrect typecode,gsim,gsim,Closed,Fixed,2014-06-03 15:34,C++,C++ Client,,,,,,,"E.g. setting values for x-amqp-creation-time and x-amqp-absolute-expiry-time  causes the appropriate fields of the Properties section to be set, but using a typecode of long rather than timestamp."
Bug,QPID-5541,12693366,HA incorrect options for expected-backups in qpid-ha tool.,aconway,aconway,Closed,Fixed,2014-06-03 15:34,C++,C++ Tools,,,,,,,"The qpid-ha tool offers options to set and query the ""expected backup count"" on a HA broker. There is no such count, these options are part of some idea that was never finished and should be removed.

See also: https://bugzilla.redhat.com/show_bug.cgi?id=1061754 "
Bug,QPID-5659,12706291,C++ not compiling (correctly) as C++11,astitcher,astitcher,Closed,Fixed,2014-06-03 15:34,C++,C++ Broker,C++ Client,,,,,,"In order to avoid a compile bug with libc++ and boost you have to compile qpid as C++11 under FreeBSD 10.

The current qpid code needs some small adjustments to compile correctly as C++11"
Bug,QPID-2631,12465581,Race in qpid::client::Bounds causes (rare) deadlock,gsim,gsim,Closed,Fixed,2014-04-08 10:47,C++,C++ Client,,,,,,,"There is a race condition in the use of Bounds in SessionImpl::sendFrame. This function sends the frame first, then calls
Bounds::expand(). But it's possible the network thread calls Bounds::reduce() between sending the frame and calling expand. If the Bounds::current value is 0
that reduce() is lost. If enough reduce() calls are lost in this way eventually we will deadlock.

In investigating this it also became clear that the connection frames weren't correctly accounted for (i.e. the bounds are never expended for connection frames, though they are included in the byte count passed in on reduce()). Though this shouldn't actually cause any problem it is logically incorrect, unintuitive and could mask problems that are hard to diagnose."
Bug,QPID-5197,12671376,Remove obsolete --cluster-durable/persistLastNode options,aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,Java Tools,,,,,,The cluster-durable feature aka persist-last-node has been removed with the old cluster plugin. This clean up removes references to it from the code.
Bug,QPID-5132,12668138,HA crash in test_tx_join_leave caused by double delete of queue. ,aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Clustering,,,,,,,"Double-delete of transaction queue leads to crash in test test_tx_join_leave.
Sporadic crash, about once per 20 test runs.


"
Bug,QPID-5232,12673855,[AMQP 1.0] receiver links from exchanges should be unreliable by default,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,and also use autodelete queues by default.
Bug,QPID-5146,12669621,[AMQP 1.0] capabilities not handled correctly,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,If there is more than one capability it should be sent as an array of symbols. Need to be able to read capabilities as either an array or a single symbol.
Bug,QPID-5256,12675512,Calling Message::getContentSize() throws InvalidConversion,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,Happens if message was populated via get-/set- ContentObject() and then getContent() or getContentSize() is called.
Bug,QPID-5098,12665481,[AMQP 1.0] Connection::close() doesn't handle failed sessions or links properly,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"E.g. if a createReceiver()/createSender() call fails with an error, a subsequent call to Connection::close() will also fail."
Bug,QPID-5230,12673724,explicitly release message is not marked as redelivered on subsequent delivery,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"This is over 0-10. The set-redelivered flag is not set for messages that are fetched then explicitly released by the application. It probably should be.

(Unaccepted messages automatically released on end of session are marked redelivered)."
Bug,QPID-5253,12675257,[AMQP 1.0] delivery-count is incorrect for browsed message that has never been previously delivered,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"This is essentially the same as QPID-5227 , but since the wording and fix for that focused only on 0-10 I've raised a new issue for 1.0."
Bug,QPID-4948,12654736,[AMQP 1.0] browsing queues not supported,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,Requires means to set and read the distribution-mode of the receiver link in proton engine.
Bug,QPID-5168,12670263,[AMQP 1.0] make handling of reply-to less sensitive to different schemes,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,The client/server example won't work against ActiveMQ as the qpid::messaging client attempts to parse the reply-to which is not in the 'expected' format. Likewise the reply-to address on messages sent through proton messenger are misinterpreted (though in that case the client can't really use them to send a reply).
Bug,QPID-5286,12677080,[AMQP 1.0] Receiver::get() doesn't replenish credit,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"Receiver::fetch() does, but for consistency with 0-10 get() should too."
Bug,QPID-5421,12684480,HA replication error in stand-alone replication.,aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Clustering,,,,,,,"When using standalone replication between two brokers, there will be replication errors if messages are put onto the primary queue before replication is set up.

To reproduce:
Create queue ""q"" on brokers P and B.
Put messages 1,2,3 on P.q
Start replication from P.q to B.q
Put messages 4,5,6 o P.q
Fetch and acknowledged one message from P.q
Fetch all messages from B.q. Instead of the expected messages [1,2,3,4,5], q has [0,1,3,4,5]"
Bug,QPID-5156,12670147,[AMQP 1.0] assert should check node properties,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"Especially important for dynamic nodes, but would be nice to support existing assert behaviour also. "
Bug,QPID-5354,12679719,[AMQP 1.0] durable node property not signalled if specified on its own,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"When requesting creation of the node on demand when attaching, if the only thing specified for the node in the address string is that it is durable, that fact will not be communicated via the node-properties sent with the attach.

E.g. 'q; {,create:always,node:{durable:True}}' will not result in a durable queue being created (however if some other property is specified in addition, or if the durable property is specified through a nested properties map, then it will be).

"
Bug,QPID-5328,12678539,browse mode should imply unreliable delivery over 0-10,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"At present if browse is specified, the accept-mode will still default to explicit accept. Since the qpid::messaging client will never try to acquire the message, there is no value to this and it potentially forces applications to call acknowledge for no (externally) apparent reason."
Bug,QPID-5130,12668073,[AMQP 1.0] x-declare for node ignores the exchange type,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"E.g. myxml;{create:always:node:{type:topic,properties:{exchange-type:xml}}}

the exchange type should be xml, but this is lost in translating to node properties.

(Note that the exchange can be created correctly by specifying the properties directly, e.g. myxml;{create:always:node:{type:topic,properties:{exchange-type:xml}}})"
Bug,QPID-5086,12664638,rollback can stall message delivery,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"The rollback implementation does a message-stop, releases all messages including those still in prefetch buffer, then rollsback the txn, then reissues credit.

However it does not send completions for the released messages, which means that though credit is reissued, the window is not moved forward and the messages aren't redelivered.

Only happens for non-zero prefetch that has been fully used at the point of rollback."
Bug,QPID-5114,12666985,WinSDK should deliver qpid-send and qpid-receive executables,chug,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Build,,,,,,,"In QPID-5017 several new files were handled by simple deletion. Two new files, qpid-send.exe and qpid-receive.exe, actually have value for WinSDK consumers as they are reliable diagnostics. They provide benchmark data that WinSDK users need."
Bug,QPID-5287,12677156,.NET binding does not set Assembly version number,chug,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Build,,,,,,,"The build scheme sets the File and Product version numbers. A stock trunk build will set the File Properties version numbers to 0.22.0.1. Overrides can set these to any desired release values, for instance 1.2.0.100.

However, in file AssemblyInfo.cpp the Assembly version number is set to
[assembly:AssemblyVersionAttribute(""1.0.*"")];

The net effect is that the Assembly version number is autogenerated and not a predictable value. 

This issue tracks creating a cmake template AssemblyInfo.cpp file and using configure_file to generate the source with the desired version number in it."
Bug,QPID-5430,12685413,HA primary broker does not go active if there are no replicated queues.,aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Clustering,,,,,,,"To reproduce:

1. Start a 3 broker cluster, do not create any replicated queues
2. Promote a broker to primary, wait for it to be ""active"".
3. Kill the primary, promote another broker to primary

Expected result: The new primary broker becomes ""active""

Actual result: The new primary remains ""recovering"""
Bug,QPID-5363,12680012,C++ HelloWorld messaging client crash closing AMQP 1.0 connection on Windows,,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"HelloWorld connects, send all messages, and then crashes with an access violation during connection::close(). Gordon and I tracked the issue down to a double free of TcpTransport aio objects, with the __vftable containing all 0xdddddddd pointers indicating that the object was already deleted.

Without the proposed fix, a locked 'closed' flag, the code crashes about 10% of the time. With the fix it proceeds indefinitely."
Bug,QPID-5051,12662488,swigged ppython tests fail on RHEL5,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,Python Test Suite,,,,,,"There are two errors, one due to enumerate() being older and not taking a start parameter, the other due to a failure to catch a specific exception type."
Bug,QPID-4670,12639169,[AMQP 1.0] dynamic flag on source/target is not handled correctly,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,Due to proton engine bug: https://issues.apache.org/jira/browse/PROTON-277
Bug,QPID-5341,12679261,Allow use of proton 0.6,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,which is now in rc1 and assuming no significant changes should work fine when released
Bug,QPID-5002,12658535,durable link should not create autodelete subscription queue by default,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"If you specify a link to be durable, by default the queue for the 0-10 path will be declared as autodelete (unless you also specify the link to be reliable).

This isn't really meeting expectations, since restarting the broker will cause the queue to be deleted.

If reliability is not specified and the link is durable, reliable should be implied. The subscription queue should only be autodelete if the link is neither reliable nor durable."
Bug,QPID-5122,12667629,Error compling on ARM platforms: cast from 'const char*' to 'const size_t* {aka const unsigned int*}' increases required alignment of target type [-Werror=cast-align],gsim,mcpierce,Closed,Fixed,2014-02-19 11:30,C++,C++ Build,,,,,,,"When compiling the 0.24 build on ARM with the fix from QPID-4670 the following error occurs:

/builddir/build/BUILD/qpid-0.24/cpp/src/qpid/broker/amqp/Outgoing.cpp:95:58: error: cast from 'const char*' to 'const size_t* {aka const unsigned int*}' increases required alignment of target type [-Werror=cast-align]
     size_t i = *reinterpret_cast<const size_t*>(tag.bytes);
                                                          ^
cc1plus: all warnings being treated as errors
make[2]: Leaving directory `/builddir/build/BUILD/qpid-0.24/cpp'
make[2]: *** [src/CMakeFiles/amqp.dir/qpid/broker/amqp/Outgoing.o] Error 1
/usr/bin/cmake -E cmake_progress_report /builddir/build/BUILD/qpid-0.24/cpp/CMakeFiles 
make[1]: *** [src/CMakeFiles/amqp.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs...."
Bug,QPID-5289,12677384,[AMQP 1.0] error descriptions are not given in exceptions by client,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"E.g. if attempting to transfer to a queue that would exceed max depth, the exception thrown is a connection-exception and simply says 'Connection closed by peer'.

There are two parts to this, one is that this should not be a connection exception but a link exception in 1.0. The second is that the error text sent by the broker should be included in the exception."
Bug,QPID-5110,12666705,[AMQP 1.0] make handling of incorrectly typed properties more robust,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"If a property is sent in the wrong type (e.g. as long instead of ulong), subsequent properties get handled incorrectly. Would be nicer to simply skip (or even by lenient and accept) the incorrect types, but handle all others correctly."
Bug,QPID-5229,12673720,[AMQP 1.0] release and reject not implemented,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,Can't explicitly release and can't reject messages over AMQP 1.0.
Bug,QPID-5349,12679442,C++ windows packaging does not install qpid-proton.dll library,,chug,Closed,Fixed,2014-02-19 11:30,C++,C++ Build,,,,,,,"Installation of Qpid on windows neglects qpid-proton and qpid-protond dll files. These were included in install/bin before and are clear dependents of qpidmessaging.dll.

A script that should produce the installation is here:

{code}
cd qpid
subst Q: .
Q:
mkdir install
mkdir build
cd build
set QPID_BUILD_ROOT=%CD%

:: run cmake
cmake -G ""Visual Studio 9 2008"" ^
  -DCMAKE_INSTALL_PREFIX=""Q:/install"" ^
  -DBOOST_ROOT=""%MY_BOOST%"" ^
  -DPROTON_ROOT=""P:/install"" ^
  -DBUILD_DOCS=""No"" ^
  ../cpp

:: build/install qpid
devenv   qpid-cpp.sln /build ""Debug|Win32""          /project INSTALL
devenv   qpid-cpp.sln /build ""RelWithDebInfo|Win32"" /project INSTALL
{code}"
Bug,QPID-5142,12669276,Don't want to pick up swigged client in python tests unless explicitly requested,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,Python Test Suite,,,,,,This will prevent installed versions of that being a proble and generally gives more control.
Bug,QPID-5431,12685449,Qpid c++ client hangs / crashes during reception failover in HA environment (mutual recursion) ,aconway,aconway,Closed,Fixed,2014-02-19 11:30,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=1039630

C++ client using AMQP 1.0 sometimes gets into an infinite recursion during failover."
Bug,QPID-5083,12664355,[AMQP 1.0] if sasl implementation is not available client (and interlinking) will fail,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,E.g. if on fedora you build without cyrus-sasl-devel.
Bug,QPID-5198,12671379,wrong exception is thrown if protocol is not recognised,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"Throws qpid::Exception, should throw some subtype of qpid::types::Exception, probably qpid::messaging::MessagingException."
Bug,QPID-5147,12669624,[AMQP 1.0] improve failure handling,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"A couple of different error conditions are still not handled:

(1) connecting to an unknown address
(2) the session ended by peer while waiting for link to attach"
Bug,QPID-5141,12669248,Message::getContentObject() returns void for 0-10 unless content is a map or a list,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,"This means code that wants to work with either 0-10 or 1.0, and handle any type of content, needs protocol specific checks (e.g. in 0-10 needs to check content-type, but not for 1.0).

It would be preferable to have getContentObject() always return an object with the best possible representation of the data regardless of the protocol used.

(This is the case for 1.0, and drain has even been modified with that assumption, but doesn't yet hold for 0-10)."
Bug,QPID-5071,12663629,The CMake build system does not rebuild when the Swig descriptors change,mcpierce,mcpierce,Closed,Fixed,2014-02-19 11:29,C++,C++ Build,,,,,,,"When the descriptor files change, the CMake build environment doesn't rebuild dependencies, such as the language bindings."
Bug,QPID-2926,12479147,Simple example code does not link under Windows,chug,chug,Closed,Fixed,2013-09-23 21:18,C++,C++ Client,,,,,,,"Using one of the existing examples that has a line such as
   ""connection.close();""
change to
   ""if (connection) connection.close();""
causes error:

Error 2 error LNK2019: unresolved external symbol ""__declspec(dllimport)public: __thiscall qpid::messaging::Handle<class
qpid::messaging::ConnectionImpl>::operator bool(void)const ""(__imp_??B?$Handle@VConnectionImpl@messaging@qpid@@@messaging@qpid@@QBE_NXZ)
referenced in function __catch$_main$0 client.obj messaging_clien

The missing routine undecorates to:
""public: __thiscall qpid::messaging::Handle<class qpid::messaging::ConnectionImpl>::operator bool(void)const ""

I think the problem is that the messaging Connection class has a template Handle class in its interface, and then this interface is exported by a DLL. At DLL-compile time the DLL source code never instantiates the Handle class template and thus has no actual instance of Handle to export in the DLL. On a Linux build the instances of Handle are created on the client host system and are not imported from a library - but this is purely a guess. See also http://www.codeproject.com/kb/cpp/templatesourceorg.aspx

--------------
Possible fixes

1. Add a separate compilation unit to Windows builds that creates actual instances of Handle<>. Then export these in the DLL to satisfy the link.
This may work but it does not sound easy to support in the long run.

2. Define the function definitions in Connection proper and not let the work fall into class Handle. In Connection.cpp adding
    QPID_MESSAGING_EXTERN operator bool() const {
        return qpid::messaging::Handle<ConnectionImpl>::operator bool();
    }
solves the issue. This same pattern applies to several functions in each of Connection, Receiver, Sender, and Session.
This would probably work in Linux, too, but could be conditionaled to only be active in Windows.

If anyone has some other ideas I'd love to hear them. Also, is having a template class in a Messaging library interface a good idea?"
Bug,QPID-4953,12654948,client example doesn't work with 0-10,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"Instead it exits with a queue not found message for the temporary queue. This is a result of change to the exmaple to simply specify '#' as a shorthand for a temp queue, which was introduced with AMQP 1.0 support. However this shorthand is not recognised by the 0-10 codepath (which expects a 'create: always' clause)."
Bug,QPID-3828,12542242,When sending large messages loss of connection is not detected even with heartbeats enabled,astitcher,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"E.g run qpid-send --broker <remote-broker> --connection-options {heartbeat:8} --messages 0 --content-size 1600 --report-every 1000 --address amq.topic

then after some time pull the network cable (you have to do this, a kill -STOP on the broker is *not* sufficient). The test will continue sending messages then eventually hang (when buffers are full). If you reconnect the cable, the connection will fail but if you don't, it will not.

If you reduce the size e.g. to 100 bytes , the connection fails as expected after two heartbeat intervals (16 secs in this case)."
Bug,QPID-4707,12640993,[AMQP 1.0] provide means of setting more fields in a 1.0 formatted message,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"To begin with, the various x-amqp-xxxx properties that are set on receiving a message should be recognised when sending a message also."
Bug,QPID-4764,12643931,Locking may lead to deadlock for concurrent receiver,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"The lock ordering leaves open the possibility of a deadlock if one thread is fetching on a receiver, another is accepting messages received by it and a third is closing the receiver.

Thread 1 holds SessionImpl's lock and is blocked on IncomingMessage's lock.  Thread 2 holds IncomingMessage's lock and is blocked on ReceiverImpl's lock.  Thread 3 holds the ReceiverImpl's lock and is blocked on SessionImpl's lock. 

I have been unable to reproduce this myself, but an actual incidence has been reported: https://bugzilla.redhat.com/show_bug.cgi?id=703891"
Bug,QPID-4792,12645458,Windows UUID processing mingles GUID values,cliffjansen,cliffjansen,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"RFC 4122 defines a UUID.  A GUID is the same as a UUID in string form, but differs in binary layout.  Microsoft operates with GUIDs but confusingly labels them as UUIDs in their documentation and include files.

i.e. rpcdce.h:  typedef GUID UUID;

The binary form matters since it is used over the wire.  Mapping a GUID to a UUID (or vice versa) without the layout conversion results in structures with mangled RFC version info and different string representations on Windows and non-Windows systems.

Proton currently only calls Microsoft APIs to obtain the string representation of the UUID (which will match the GUID), so it is unaffected.
"
Bug,QPID-4772,12644199,Message sent by python producer can't be read with java consumer,jross,eallen,Closed,Fixed,2013-09-08 13:37,C++,C++ Tools,,,,,,,The java consumer app assumes messages without an explicit content_type are text/plain. The python spout app needs to set the content_type to text/plain unless a map is provided.
Bug,QPID-4805,12645773,qpid-config default journal parameters override qpidd.conf,jross,jross,Closed,Fixed,2013-09-08 13:37,C++,C++ Tools,,,,,,,"From Leonid:
""""""
The user can set default journal parameters (number of files and a size of each file) in qpidd config file. These are the options 'num-jfiles' and 'jfile-size-pgs', which are properly documented. The broker is supposed to use these parameters while creating a new durable queue in case that no journal parameters were provided by the client's application.
The problem is that qpid-config tool sends values fileCount = 8, fileSize = 24 to the broker if called without ""--file-count"" and ""--file-size"" parameters.
Imagine the situation where a user sets some default 'num-jfiles' and 'jfile-size-pgs' values in qpidd config file and then creates a durable queue using qpid-config tool: 'qpid-config add queue test --durable'. The resulting queue's journal will have parameters fileCount = 8, fileSize = 24, which will differ from the ones set by the user in config file.
"""""""
Bug,QPID-4780,12644874, HA broker deadlock after loss of primary broker,aconway,aconway,Closed,Fixed,2013-09-08 13:37,C++,C++ Clustering,,,,,,,"Description of problem:
While fencing nodes in a cluster, occasionally encounter an issue where a previously backup broker becomes deadlocked while deleting auto-delete queues.  Only noticed the issue because 'qpid-ha promote' hangs attempting to promote a backup to primary.

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
Rare (race condition)
see also: https://bugzilla.redhat.com/show_bug.cgi?id=889552

Steps to Reproduce:
1. Start HA-enabled brokers
2. Create tens-of-thousands of auto-delete queues
3. Fence / power-cycle the node hosting the primary broker
  
Actual results:
Occasionally the backup broker deadlocks

Expected results:
The backup broker does not deadlock

Additional info:"
Bug,QPID-4985,12657239,[AMQP 1.0] sending message with priority=4 causes buffer overflow in client,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,E.g qpid-send --conection-options {protocol:amqp1.0} --priority 1 --address amq.fanout
Bug,QPID-4965,12655311,[AMQP 1.0] assert should check filters in use,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"The attach from the broker (or peer more generally) will include the filters actually in use. If the assert option has been specified, these should be checked."
Bug,QPID-4737,12642036,"Fix cmake ""make package""",aconway,aconway,Closed,Fixed,2013-09-08 13:37,C++,C++ Build,,,,,,,"""make package"" attempts to install files with absolute paths to the final install location, rather than the temporary install dir.

"
Bug,QPID-5017,12659858,WinSDK build leaves release executables stranded in \bin directory,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Build,,,,,,,"Several new[1] files have been added to C++ install
* qmf-gen
* qpidt
* qpid-ping
* qpid-send 
* qpid-receive
* qpid-topic-listener
* qpid-topic-publisher
* sender
* receiver

But these files are not properly disposed in the WinSDK build process. WinSDK separates the debug and release variants into separate subdirectories bin\Debug and bin\Release. The files listed above are installed twice to \bin with the Release variants overwriting the Debug variants. The final SDK is left with only the Release variants sitting in the wrong directory.

These files should be moved into bin\Debug after the debug build and moved again into bin\Release after the release build.

[1] 2012-10-22"
Bug,QPID-4888,12649349,[AMQP 1.0] link naming is not handled correctly,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"The client does not let the name of the link be controlled, but always defaults it to the name of the node (which doesn't meet uniqueness criteria).

The broker uses the link-, source- and target- names as the key to the managment objects and uses the link- and source- name for subscriptions queues when the source refers to an exchange. The link name is only guaranteed to be unique within the scope of a clients container id."
Bug,QPID-5062,12662652,[C++ client] EXTERNAL authentication using SSL certificates doesn't work with AMQP 1.0,gsim,scholzj,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"A C++ based client using the qpid.messaging API with AMQP 1.0 seems to be unable to connect to the broker and authenticate with the SASL EXTERNAL authentication / SSL Client Certificates. The client side log is following:

2013-08-08 20:07:01 [Messaging] debug Driver started
2013-08-08 20:07:01 [Messaging] debug localhost:10000 Connecting ...
2013-08-08 20:07:01 [System] info Connecting: 127.0.0.1:10000
2013-08-08 20:07:01 [Security] debug Failed to connect: Connection refused
2013-08-08 20:07:01 [Messaging] debug localhost:10000 Failed to connect
Exception: Could not connect to amqp:ssl:localhost:10000 (/home/jakub/qpid/qpid-0.24-rc1/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:117)
2013-08-08 20:07:01 [Messaging] debug Driver stopped
[jakub@localhost Messaging-Sandbox]$ ./ReqRespClient 
2013-08-08 20:07:50 [Messaging] debug Driver started
2013-08-08 20:07:50 [Messaging] debug localhost:10000 Connecting ...
2013-08-08 20:07:50 [System] info Connecting: 127.0.0.1:10000
2013-08-08 20:07:50 [Messaging] debug localhost:10000 Connected
2013-08-08 20:07:50 [Messaging] debug wakeupDriver()
2013-08-08 20:07:50 [Messaging] debug localhost:10000 Waiting to be authenticated...
2013-08-08 20:07:50 [Security] trace localhost:10000 Sasl::canEncode(): 1 || 0
2013-08-08 20:07:50 [Security] trace localhost:10000 Sasl::canEncode(): 1 || 0
2013-08-08 20:07:50 [Protocol] debug localhost:10000 writing protocol header: 1-0
2013-08-08 20:07:50 [Security] trace localhost:10000 Sasl::encode(65535): 8
2013-08-08 20:07:50 [Security] trace localhost:10000 Sasl::canEncode(): 0 || 0
2013-08-08 20:07:50 [Protocol] debug localhost:10000 read protocol header: 1-0
2013-08-08 20:07:50 [Security] trace Reading SASL frame of size 30
2013-08-08 20:07:50 [Security] trace Reading SASL-MECHANISMS
2013-08-08 20:07:50 [Protocol] debug localhost:10000 Received SASL-MECHANISMS(EXTERNAL)
2013-08-08 20:07:50 [Security] debug CyrusSasl::start(EXTERNAL )
2013-08-08 20:07:50 [Security] debug min_ssf: 0, max_ssf: 256
2013-08-08 20:07:50 [System] debug Exception constructed: Sasl error: SASL(-4): no mechanism available:  (/home/jakub/qpid/qpid-0.24-rc1/cpp/src/qpid/SaslFactory.cpp:309)
2013-08-08 20:07:50 [System] error Caught exception in state: 3 with event: 1: internal-error: Sasl error: SASL(-4): no mechanism available:  (/home/jakub/qpid/qpid-0.24-rc1/cpp/src/qpid/SaslFactory.cpp:309)
2013-08-08 20:07:55 [Security] debug [127.0.0.1:34905-localhost:10000] SslTransport closing...
2013-08-08 20:07:55 [Security] debug [127.0.0.1:34905-localhost:10000] Socket closed
Exception: Disconnected
2013-08-08 20:07:55 [Messaging] debug Driver stopped

The broker log mentions that the connection is being closed because no protocol was received (max-negotiate-timeout expired):

2013-08-08 20:07:50 [Network] info Set TCP_NODELAY on connection to 127.0.0.1:34905
2013-08-08 20:07:50 [Broker] info Using AMQP 1.0 (with SASL layer)
2013-08-08 20:07:50 [Model] trace Mgmt create connection. id:qpid.127.0.0.1:10000-127.0.0.1:34905
2013-08-08 20:07:50 [Security] info SASL: Mechanism list: EXTERNAL
2013-08-08 20:07:55 [System] error Connection qpid.127.0.0.1:10000-127.0.0.1:34905 No protocol received closing
2013-08-08 20:07:55 [Security] info qpid.127.0.0.1:10000-127.0.0.1:34905 Connection closed prior to authentication completing
2013-08-08 20:07:55 [Security] info qpid.127.0.0.1:10000-127.0.0.1:34905 Connection closed prior to authentication completing
2013-08-08 20:07:55 [Model] debug Delete connection. user: rhost:qpid.127.0.0.1:10000-127.0.0.1:34905
2013-08-08 20:08:03 [Model] trace Mgmt delete connection. id:qpid.127.0.0.1:10000-127.0.0.1:34905 Statistics: {bytesFromClient:0, bytesToClient:0, closing:False, framesFromClient:0, framesToClient:0, msgsFromClient:0, msgsToClient:0}

With AMQP 0.10 it seems to work fine.
"
Bug,QPID-4966,12655313,[AMQP 1.0] timeout to fetch()/get() not honoured,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,Instead waits forever
Bug,QPID-4701,12640761,Exception types lost in qpidmessaging  when compiling with cmake and gcc 4.1.2 (e.g. RHEL5),gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"Exceptions are thrown simply as std::exception rather than the specific types defined. This appears to be a result of the visibility flag support in the version of gcc (cmake turns that on, autotools does not).

(See also QPID-4484)"
Bug,QPID-4786,12645238,Delayed response for concurrent fetches,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"Where a session has two concurrent fetch() (or indeed get()) operations in progress, one of them may be delayed up to the timeout even if there is in fact a message much earlier than that.

This is due to the design whereby the threads pop off the next message from a session queue, and put it into a received buffer if its not one they are interested in. The wrong thread can get the message, and the other thread remains waiting for another one before re-checking the received buffer (which now has a message that matches its interest)."
Bug,QPID-4885,12649322,C++ examples install to the wrong location,mcpierce,mcpierce,Closed,Fixed,2013-09-08 13:37,C++,C++ Build,,,,,,,"The files all install to /usr[/local]/share/examples, but should install to /usr[/local]/share/qpid/examples"
Bug,QPID-5034,12661132,WinSDK README contains stale web site URL,chug,chug,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,The web site has been reorganized and the page has moved.
Bug,QPID-4806,12645775,qpid-config traceback in case of ACL denial,jross,jross,Closed,Fixed,2013-09-08 13:37,C++,C++ Tools,,,,,,,"[Text from Leonid]

The latest version of qpid-config tool shows an ugly traceback in case that the request was denied by ACL rule:

[root@lzhaldyb-rhel63x ~]# qpid-config add exchange topic new -b user/password@localhost:5672 
Failed: UnauthorizedAccess: unauthorized-access: ACL denied queue create request from user@QPID (qpid/broker/Broker.cpp:1106)(403)
Traceback (most recent call last):
  File ""/usr/bin/qpid-config"", line 772, in <module>
    sys.exit(main())
  File ""/usr/bin/qpid-config"", line 755, in main
    bm.Disconnect()
  File ""/usr/bin/qpid-config"", line 376, in Disconnect
    self.conn.close()
  File ""<string>"", line 6, in close
  File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 316, in close
    ssn.close(timeout=timeout)
  File ""<string>"", line 6, in close
  File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 739, in close
    self.sync(timeout=timeout)
  File ""<string>"", line 6, in sync
  File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 731, in sync
    if not self._ewait(lambda: not self.outgoing and not self.acked, timeout=timeout):
  File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 567, in _ewait
    self.check_error()
  File ""/usr/lib/python2.6/site-packages/qpid/messaging/endpoints.py"", line 556, in check_error
    raise self.error
qpid.messaging.exceptions.UnauthorizedAccess: unauthorized-access: ACL denied queue create request from user@QPID (qpid/broker/Broker.cpp:1106)(403)"
Bug,QPID-4889,12649363,Swig descriptors are installed twice,mcpierce,mcpierce,Closed,Fixed,2013-09-08 13:37,C++,C++ Build,,,,,,,"The following swig descriptor files are installed:

mcpierce@mcpierce-laptop:x86_64 (master) $ rpm -ql qpid-cpp-client-devel | grep ""\.i""
/usr/include/qmf/qmf2.i
/usr/include/qmf/qmfengine.i
/usr/include/qpid/qpid.i
/usr/include/qpid/swig_perl_typemaps.i
/usr/include/qpid/swig_python_typemaps.i
/usr/include/qpid/swig_ruby_typemaps.i
/usr/share/qpid/qpid/qpid.i
/usr/share/qpid/qpid/swig_perl_typemaps.i
/usr/share/qpid/qpid/swig_python_typemaps.i
/usr/share/qpid/qpid/swig_ruby_typemaps.i

As can be seen, the files installed to /usr/share/qpid are not needed since tehy're already provided under /usr/include/qpid."
Bug,QPID-4702,12640762,cmake build of ssl support does not work on certain platforms,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,This is a result of the order of libraries and object files passed to the linker. The libraries must follow the .o files that require them or they will be ignored (assumed not needed).
Bug,QPID-4976,12656034,[AMQP 1.0] support standard lifetime policies,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Broker,C++ Client,,,,,,"I.e. delete-on-close, delete-on-no-links, delete-on-no-messages and delete-on-no-links-or-messages"
Bug,QPID-4839,12647558,HA Sporadic failure of ha_tests.test_join_ready_cluster,aconway,aconway,Closed,Fixed,2013-09-08 13:37,C++,C++ Clustering,,,,,,,"Test fails sporadically with:

Error during test:  Traceback (most recent call last):
    File ""/home/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/cpp-vpath/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/tests/ha_tests.py"", line 1173, in test_join_ready_cluster
      self.assertRaises(Exception, cluster[0].promote)
    File ""/usr/lib64/python2.6/unittest.py"", line 341, in failUnlessRaises
      raise self.failureException, ""%s not raised"" % excName
  AssertionError: Exception not raised
"
Bug,QPID-3171,12502912, RDMA client can segfault if no SASL mech specified.,mgoulish2,mgoulish2,Closed,Fixed,2013-08-21 11:02,C++,C++ Client,,,,,,,"Using the following scripts to start the broker and to run a perftest client ( using RDMA ) I get a client segv about 3% of the time.

broker start script:

#! /bin/bash

export LD_LIBRARY_PATH=$TRUNK/qpid/cpp/src/.libs

QPID_SRC=$TRUNK/qpid/cpp/src
QPIDD=${QPID_SRC}/.libs/qpidd

echo $QPIDD

rm -rf /tmp/mick
mkdir /tmp/mick

$QPIDD                                        \
  --no-module-dir                             \
  --load-module ${QPID_SRC}/.libs/rdma.so     \
  --data-dir /tmp/mick/data_1                 \
  --auth=yes                                  \
  --mgmt-enable=yes                           \
  --port 5813                                 \
  --log-enable info+                          \
  --log-to-file /tmp/mick/qpidd_1.log         \
  --log-source yes                            \
  --sasl-config=${QPID_SRC}/tests/sasl_config \
  -d

echo ""started broker from $QPIDD""



client run script:

#! /bin/bash

rm core.*

count=0
while [ $count -lt 10000 ]
do
  echo ""===========================================""
  echo ""TEST $count""
  echo ""===========================================""
  core_files=`ls -l core.* | wc -l`
  echo ""core files:  ${core_files}""

  if [ ${core_files} -gt 0 ]; then
    echo ""core files found!""
    exit 1
  else
    echo ""no core files found.""
  fi
  ./qpid-perftest --username zig --password zig --protocol rdma --broker 20.0.40.14 --port 5813 --qt 4 --count 10  
  count=$(( $count + 1 ))
done


"
Bug,QPID-3188,12503446,CyrusSasl ctor logic change for callback storage,mgoulish2,mgoulish2,Closed,Fixed,2013-08-20 20:41,C++,C++ Broker,C++ Client,,,,,,"The logic that stores callbacks in the CyrusSasl ctor should be changed to make the c++ client behave similarly to other language clients.

If there is no username, then do nothing with either NAME or PASSWD callbacks.
If there is a name but no passwd, then explicitly store an empty PASSWD callback."
Bug,QPID-3620,12531589,time conversions fail on solaris,cliffjansen,cliffjansen,Closed,Fixed,2013-08-20 20:33,C++,C++ Broker,C++ Client,,,,,,"Condition::wait(Mutex&, const AbsTime& absoluteTime) fails for far future time during cast/truncation from 64 bit int to posix timespec.tv_sec.  The time is actually in the past and the wait times out instantly."
Bug,QPID-4085,12595633,HA fails long running failover test,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"Running the following loop for a long time (up to 1.5 hours) the test eventually fails:

{noformat}
cd tests; source ./test_env.sh;
ha_tests.py $*
while ha_tests.py *LongTests* -DDURATION=3; do date; done; exit 1
{noformat}

3 types of failure observed:
- timeout waiting for the primary broker to become 'active'
- timeout waiting for a backup broker to become 'ready'
- missing messages"
Bug,QPID-2452,12459447,Inconsistent handling on strings between C++ and Python messaging APIs,gsim,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,Python Client,,,,,,"Description of problem:

This bug is in reference to the new messaging APIs.

The handling of strings is different between the C++ and Python messaging APIs.
 The Python API assumes strings on-the-wire are UTF-8 encoded.  The C++ API
apparently uses raw, unencoded octet arrays.

If a binary string of octets (with some octets > 0x7F), is encoded by a C++
client and received by a Python client, the Python client will throw an
exception.

Version-Release number of selected component (if applicable):

SVN revision 924529 and prior.

How reproducible:

100%

Steps to Reproduce:
1. Use the C++ API (qpid::messaging) to produce a map-message (using
MapContent).  One of the map entries should have a string value and should
contain a sequence such as ""!E\xf9\xf5\xdf\x89d\x011\xc0\xc8$7H\x99T""
2. Use the python client to receive the message.

Actual results:

The Python client will throw an exception when it tries to UTF8-decode the
string.

Expected results:

Either Python should use raw-octet encoding or C++ should use UTF8.  I expect
the string seen by the Python receiver to be identical to that sent by the C++
producer.
"
Bug,QPID-4130,12598386,"Remove use of intrusive_ptr::reset in ha/Primary.cpp, not supported by older boost versions.",aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"Remove use of intrusive_ptr::reset in ha/Primary.cpp, not supported by older boost versions."
Bug,QPID-2271,12443299,Building C++ examples on Windows doesn't need explicit refs to Boost libs,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"When building the C++ examples on Windows, it's best to not explicitly refer to the Boost libraries. The Boost headers will implicitly link in whatever is needed to satisfy the references."
Bug,QPID-306,12360788,AMQP 0-9 unbind,gsim,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,Implement new Queue::unbind and Exchange::unbind methods from 0-9.
Bug,QPID-2151,12438337,Doxygen-generated C++ client docs show inconsistent #include strategy,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"The doxygen-generated user docs for the C++ client are inconsistent about documenting the way to #include headers. The start page examples show things like:

#include <qpid/client/Connection.h>

but the page for the qpid::client::Connection class shows what to include to use the class as:

#include <Connection.h>

My opinion is that the former method should be used (<qpid/client/Connection.h>)"
Bug,QPID-4156,12599517,HA close window for clients to connect before HA broker is initialized,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"A HA backup broker in a cluster rejects client connections. This was previously done in a ConnectionObserver registered during Plugin::initialize. However that left a window before the observer was registered when clients could connect. This showed up as a sporadic failure of the failover test. This patch moves the creation of the observer to Plugin::earlyInitialize, which is guaranteed to be called  before the broker starts listening for clients."
Bug,QPID-1369,12406640,Inconsistent reference to ConnectionSettings,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"In the C++ client code there are a few places where ConnectionSettings is forward-referenced ala

class ConnectionSettings;

However, ConnectionSettings is a struct. This difference causes Microsoft C++ to issue a warning that ConnectionSettings was first seen as a struct, then a class. Changing the forward reference from class to struct resolves this.
"
Bug,QPID-3256,12506820,Application which uses Qpid (in my case Excel) hangs on shutdown,cliffjansen,eugenesm,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"Hi All

I encountered with strange behavior on shutdown when using qpid 0-8 and 0-10. 

When I use qpid in standalone console-application everything is ok. But when I use qpid in DLL which is loaded into Excel (as RTD module), Excel hangs on shutdown. 

I found out that in standalone application on shutdown I have next stack:

	qpidclientd.dll!qpid::client::`anonymous namespace'::IOThread::~IOThread()  Line 138	C++
 	qpidclientd.dll!`qpid::client::`anonymous namespace'::theIO'::`2'::`dynamic atexit destructor for 'io''()  + 0xd bytes	C++
 	qpidclientd.dll!_CRT_INIT(void * hDllHandle=0x60080000, unsigned long dwReason=0, void * lpreserved=0x00000001)  Line 449	C
 	qpidclientd.dll!__DllMainCRTStartup(void * hDllHandle=0x60080000, unsigned long dwReason=0, void * lpreserved=0x00000001)  Line 560 + 0x11 bytes	C
 	qpidclientd.dll!_DllMainCRTStartup(void * hDllHandle=0x60080000, unsigned long dwReason=0, void * lpreserved=0x00000001)  Line 510 + 0x11 bytes	C
 	ntdll.dll!77b79960() 	
 	[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]	
 	ntdll.dll!77b9a516() 	
 	ntdll.dll!77b9a3b8() 	
 	kernel32.dll!77657363() 	
 	msvcr90d.dll!__crtExitProcess(int status=0)  Line 732	C
 	msvcr90d.dll!doexit(int code=0, int quick=0, int retcaller=0)  Line 644 + 0x9 bytes	C
 	msvcr90d.dll!exit(int code=0)  Line 412 + 0xd bytes	C
 	Test.exe!__tmainCRTStartup()  Line 599	C
 	Test.exe!mainCRTStartup()  Line 403	C
 	kernel32.dll!77653677() 	
 	ntdll.dll!77b79f02() 	
 	ntdll.dll!77b79ed5() 	

And in this state all threads of application have been already terminated. The only thread is:

1	>	21720	Main Thread	Main Thread	qpid::client::`anonymous namespace'::IOThread::~IOThread	Normal	0

so code from file ConnectionImpl.cpp works well:

~IOThread() {
        std::vector<Thread> threads;
        {
            ScopedLock<Mutex> l(threadLock);
            if (poller_)
                poller_->shutdown();
            t.swap(threads);
        }
        for (std::vector<Thread>::iterator i = threads.begin(); i != threads.end(); ++i) {
            i->join();
        }
    }


BUT in Excel I get stack:

qpidclientd.dll!qpid::client::`anonymous namespace'::IOThread::~IOThread()  Line 130	C++
 	qpidclientd.dll!`qpid::client::`anonymous namespace'::theIO'::`2'::`dynamic atexit destructor for 'io''()  + 0xd bytes	C++
 	qpidclientd.dll!_CRT_INIT(void * hDllHandle=0x07700000, unsigned long dwReason=0, void * lpreserved=0x00000000)  Line 449	C
 	qpidclientd.dll!__DllMainCRTStartup(void * hDllHandle=0x07700000, unsigned long dwReason=0, void * lpreserved=0x00000000)  Line 560 + 0x11 bytes	C
 	qpidclientd.dll!_DllMainCRTStartup(void * hDllHandle=0x07700000, unsigned long dwReason=0, void * lpreserved=0x00000000)  Line 510 + 0x11 bytes	C
 	ntdll.dll!77b79960() 	
 	[Frames below may be incorrect and/or missing, no symbols loaded for ntdll.dll]	
 	ntdll.dll!77ba1525() 	
 	ntdll.dll!77b81231() 	
 	KernelBase.dll!77281da7() 	
 	ole32.dll!75bb9562() 	
 	ole32.dll!75bb9593() 	
 	ole32.dll!75bb95a7() 	
 	ole32.dll!75bb98bf() 	
 	ole32.dll!75bb9805() 	
 	ole32.dll!75bb9a8c() 	
 	EXCEL.EXE!2f3811e9() 	
 	EXCEL.EXE!2f6933e8() 	
 	EXCEL.EXE!2f32a5af() 	
 	EXCEL.EXE!2f34894a() 	
 	EXCEL.EXE!2f670001() 	
 	MSO.DLL!65bc6ed5() 	
 	MSO.DLL!65c26a34() 	
 	MSO.DLL!65c30305() 	
 	MSO.DLL!65bc910c() 	
 	MSO.DLL!65c4f420() 	
 	MSO.DLL!65bbf161() 	
 	comctl32.dll!7233463d() 	
 	user32.dll!762971be() 	
 	user32.dll!76297d31() 	
 	user32.dll!76297dfa() 	
 	EXCEL.EXE!2f324572() 	
 	EXCEL.EXE!2f324534() 	
 	EXCEL.EXE!2f324441() 	
 	MSO.DLL!65b78116() 	
 	MSO.DLL!65ba1fd0() 	
 	EXCEL.EXE!2f30424b() 	
 	msvcr90.dll!749936c5() 	
 	msvcr90.dll!749938b3() 	
 	msvcr90.dll!749938c5() 	
 	msvcr90.dll!749ac40c() 	
 	msvcr90.dll!749b028d() 	
 	msvcr90.dll!749b04f3() 	
 	EXCEL.EXE!2f303f0a() 	
 	kernel32.dll!77653677() 	
 	ntdll.dll!77b79f02() 	
 	ntdll.dll!77b79ed5() 	

And threads:

0	 	24016	Worker Thread	_threadstartex	_threadstartex	Normal	0
0	>	22928	Main Thread	Main Thread	qpid::client::`anonymous namespace'::IOThread::~IOThread	Normal	0
0	 	20224	RPC Thread	RPC Callback Thread	77b5fd21	Normal	0
0	 	16492	Worker Thread	Win32 Thread	77b61ed6	Normal	0
0	 	19948	Worker Thread	Win32 Thread	77b600ed	Normal	0
0	 	20524	Worker Thread	Win32 Thread	77b61ed6	Normal	0
0	 	20532	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	21500	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	21848	Worker Thread	Win32 Thread	77b61ed6	Normal	0
0	 	22152	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	22164	Worker Thread	Win32 Thread	77b5f8e9	Normal	0
0	 	22300	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	22360	Worker Thread	Win32 Thread	77b61ed6	Normal	0
0	 	23316	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	23556	Worker Thread	Win32 Thread	77b5f8e9	Normal	0
0	 	23700	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	23912	Worker Thread	Win32 Thread	77b5f8e9	Normal	0
0	 	24276	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	24308	Worker Thread	Win32 Thread	77b5f861	Normal	0
0	 	24424	Worker Thread	Win32 Thread	77b600ed	Normal	0
0	 	24452	Worker Thread	Win32 Thread	77b5f8e9	Normal	0
0	 	24520	Worker Thread	Win32 Thread	77b61ed6	Normal	0

As result this code (below) hangs application(Excel):

~IOThread() {
        std::vector<Thread> threads;
        {
            ScopedLock<Mutex> l(threadLock);
            if (poller_)
                poller_->shutdown();
            t.swap(threads);
        }
        for (std::vector<Thread>::iterator i = threads.begin(); i != threads.end(); ++i) 
        {

            i->join();-- APPLICATION HANGS HERE !!!!

        }
    }

I suppose it occurs because of qpid tries to wait of thread completing from _DllMainCRTStartup which is called with PROCESS_DETACH.
To work around it I modified function IOThread::sub():

   void sub() {
		std::vector<Thread> threads;
		{
                  ScopedLock<Mutex> l(threadLock);
		  --connections; 
		
		  if (connections == 0){
			if (poller_){
				poller_->shutdown();
				poller_.reset();

				t.swap(threads);
			}
		  }
               }
	       for (std::vector<Thread>::iterator i = threads.begin(); i != threads.end(); ++i) {
		 i->join();
	     }
         }

But I don't think it is a good solution.
Could you help me to solve this problem?
Thanks
"
Bug,QPID-1718,12416250, SubscriptionManager::get() closes dispatch queue unexpectedly,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"If SubscriptionManager::get() is invoked with no subscriptions in place, the
dispatch queue is closed and a subsequent SubscriptionManager::run() returns
without dispatching."
Bug,QPID-3759,12538341,Heartbeat timeout in Windows does not lead to timely reconnect,cliffjansen,chug,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"Reported by Wolf Wolfswinkel on Qpid users http://qpid.2158936.n2.nabble.com/Heartbeats-in-C-broker-on-Windows-td7118702.html 22-Dec-2011

The simplest test case is in attached main.cpp. Establish a good network connection to the broker and then start the program. It creates a connection, sends two messages, and then pauses for 15 seconds. During the pause disconnect the network connection to the broker for at least two heartbeat timeouts (12 seconds).

After the heartbeat timeout the timer task fires and a debug trace shows:
 Traffic timeout,  TCPConnector::abort, TCPConnector::eof, TCPConnector::close

But the connection is not actually closed until something happens on the network to wake up the thread waiting in Poller::run().

The timer event appears unable to interrupt the IO thread waiting for the completion port."
Bug,QPID-3896,12546245,Broker crash when using auto delete queues in a cluster,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"I can get the broker to crash with a simple configuration involving multiple 'auto delete' queues.

The following client pseudo code can cause the crash:

    loc_sess = [ ];
    # create couple of sessions
    for i in range(in_loops):
      queue_durability = False;
      if (i % 2 == 1):
        queue_durability = True;
      # create new local session[s]
      lsess = self.connection.session(loc_sess_name % i);
      # delete the queue (if needed)
      self.cleanup(in_queue=loc_q_name % i);
      # declare auto-delete queue[s]
      lsess.queue_declare(queue=loc_q_name % i, 
                          auto_delete=True,
                          arguments={""qpid.auto_delete_timeout"" : q_timeout},
                          durable=queue_durability);
      
      # check that queue[s] is still available
      result = lsess.queue_query(queue=loc_q_name % i);
      self.assertEqual(loc_q_name % i, result.queue);
    
      # bind queue to exchange amf.fanout
      lsess.exchange_bind(exchange=e_name,
                          queue=loc_q_name % i,
                          binding_key=f_name);

      # append the session to list
      loc_sess.append(lsess);
    
    # send messages to the queues via amq.fanout
    dp = sess.delivery_properties(routing_key=f_name);
    msg_cnt = random.randint(*MSG_CNT_RR);
    print ""setup: in_loops:%d, msg_cnt:%d"" % (in_loops, msg_cnt);
    for j in range(msg_cnt):
      sess.message_transfer(destination=e_name,
                            message=qpid.datatypes.Message(dp, msg_layout % j));
    
    # check that queues contain correct message count via QMF
    self.startQmf();
    for i in range(in_loops):
      sq = self.qmf_session.getObjects(_class=""queue"", name=loc_q_name % i)[0];
      self.assertEqual (sq.msgDepth, msg_cnt);

    # receive one (first) message from the queues
    for i in range(in_loops):
      loc_sess[i].message_subscribe(destination=""dlq"", queue=loc_q_name % i);
      loc_sess[i].message_flow(destination=""dlq"", value=0xFFFFFFFFL,
                               unit=loc_sess[i].credit_unit.message)
      loc_sess[i].message_flow(destination=""dlq"", value=0xFFFFFFFFL,
                               unit=loc_sess[i].credit_unit.byte)
      dlq = loc_sess[i].incoming(""dlq"");

      msg=dlq.get(timeout=1);
      self.assertEqual(msg_layout % 0, msg.body);
      

    # check that queues are present at this point (subscription still alive atm)
    for i in range(in_loops):
      # browse sessions
      result = loc_sess[i].queue_query(queue=loc_q_name % i);
      self.assertEqual(loc_q_name % i, result.queue);
    
      loc_sess[i].close();

    # check that queues are still available (after local sessions JUST closed)
    for i in range(in_loops):
      # browse sessions
      result = sess.queue_query(queue=loc_q_name % i);
      self.assertEqual(loc_q_name % i, result.queue);

    print ""sleeping - waiting for queue auto timeout""
    time.sleep(q_timeout+AD_TIMEOUT_TOL);
    
    # check whether queue has been deleted (expected to be deleted)
    for i in range(in_loops):
      result = sess.queue_query(queue=loc_q_name % i);
      self.assert_(not result.queue);

Analysis:

The ClusterTimer is unable to handle storing two timer tasks that have the same name.  The Queue code creates a timer task for each auto delete queue.  These tasks all have the same name ""DelayedAutoDeletion"".  This causes ClusterTimer::add() to throw an exception as it thinks there are duplicate timer tasks.

   "
Bug,QPID-424,12365147,C++: Fix memory leaks,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"We need to get to a clean slate on memory leaks, right now valgrind is reporting quite a few.

The current batch of leaks are being suppressed in cpp/test/.vg-supp so that we can make --enable-valgrind the default and catch/fix new leaks quickly going forward. Valgrind errors are equivalent to a test failure, you should not commit with errors.

The supressed leaks also need to be addressed either fix the leak or prove that it's a problem outside qpid's control. 
In the later case the supression description should explain why the leak can safely be ignored."
Bug,QPID-3084,12499640,Cluster may hang during update if asynchronous completion is pending.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"During an update of a newly joined broker, io processing requests are held off.  Asynchronous command completion requires io processing in order to complete asynchronous operations.  If any async commands are pending completion during the update, they may not complete and cause the cluster to hang.  This may be cause by store or during queue flow control. "
Bug,QPID-2048,12432949,Client can hang on close() if broker is simultaenously killed,aconway,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"There is a race between ConnectionHandler::close() and ConnectionHandler::failed(). If the closing thread is 'between' checking for OPEN state and setting to CLOSING state (lines 149 and 150 as of r803787) when the failing thread sets the state to FAILED (line 181 as of r803787), then the FAILED state will be overwritten and the closing thread will hang.

E.g., from a run of ais_check with store loaded:

Thread 1 (Thread 0xb7fb3720 (LWP 11644)):
#0  0x00975410 in __kernel_vsyscall ()
#1  0x0032d595 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
#2  0x00a53b3d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x001b973e in qpid::client::StateManager::waitFor ()
#4  0x00166e52 in qpid::client::ConnectionHandler::close ()
#5  0x0016f2fb in qpid::client::ConnectionImpl::close ()
#6  0x0015dde4 in qpid::client::Connection::close ()
#7  0x0808d5da in ClusterFixture::killWithSilencer ()
#8  0x0806dab4 in testConnectionKnownHosts ()
#9  0x0807cacc in boost::unit_test::ut_detail::callback0_impl_t<boost::unit_test::ut_detail::unused, void (*)()>::invoke ()
#10 0x007ad48d in ?? () from /usr/lib/libboost_unit_test_framework.so.2
#11 0x0079df35 in boost::execution_monitor::catch_signals ()
#12 0x0079e2c6 in boost::execution_monitor::execute ()
#13 0x007ad599 in boost::unit_test::unit_test_monitor_t::execute_and_translate
#14 0x007a1194 in boost::unit_test::framework_impl::visit ()
#15 0x007b3ef7 in boost::unit_test::traverse_test_tree ()
#16 0x007b46a0 in boost::unit_test::traverse_test_tree ()
#17 0x007b44d8 in boost::unit_test::traverse_test_tree ()
#18 0x007b46d5 in boost::unit_test::traverse_test_tree ()
#19 0x007b44d8 in boost::unit_test::traverse_test_tree ()
#20 0x007b46d5 in boost::unit_test::traverse_test_tree ()
#21 0x007a0169 in boost::unit_test::framework::run ()
#22 0x007ad249 in main () from /usr/lib/libboost_unit_test_framework.so.2
#23 0x0098be8c in __libc_start_main () from /lib/libc.so.6
#24 0x080568b1 in _start ()"
Bug,QPID-3206,12504157,Variant converts from negative number in string format to unsigned integer without error,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"E.g. 
  uint16_t i = 0;
  qpid::types::Variant v = ""-5"";
  i = v;

The above results in an exception in older versions of gcc (e.g. 4.1.2) but sets i to 65531 on later versions (e.g. 4.4.4). This is a result of a fix to the gcc std library to be compliant with specification which requires stringstream to accept negative values even for unsigned ints (which is the behaviour of scanf).

See e.g:
http://boost.2283326.n4.nabble.com/conversion-lexical-cast-doesn-t-throw-td2593967.html
http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/97475b21515462c9/ce369a327fa39243#ce369a327fa39243"
Bug,QPID-3475,12521627,Clustered brokers ignore authentication settings when joining a cluster,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"When a broker joins a cluster, it should authenticate using the options --cluster-username, --cluster-password and --cluster-mechanism.
The broker is ignoring the settings and successfully joins the cluster even if an invalid user or password are supplied.

See https://bugzilla.redhat.com/show_bug.cgi?id=730017"
Bug,QPID-2318,12444609,qpid-tool does not seem to issue session acknowledgements ,tross,rgodfrey,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"Running with qpid-tool against either the Java (after the QMF patch) or the C++ Broker it seems like no matter how many messages the broker sends the qpid-tool client, the client never acknowledges these incoming commands at the session level

While the subscriber is acting in ""no-ack"" mode, this still seems to cause a build up in memory usage of the C++ broker (possibly because it is buffering unacknowledged frames

Simply running a couple of qpid-tool instances against an otherwise idle qpid-broker, the amount of memory being used by the broker has gradually increased from 4Mb to 200Mb over the last two days"
Bug,QPID-2131,12437474,qpid-stat produces error when using clustering and authentication,nsantos,xeop-nollarm,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"When a broker is running as a member of a cluster and it has authentication enabled then running qpid-stat with a valid broker address of form username/password@host:port leads to the following error:
Failed: TypeError - int argument required
 
This is caused by a call to addBroker in method display of the BrokerManager class. As first argument the variable ""host"" is specified here which does not contain username and password, only hostname and port number.
Therefore authentication fails and the mentioned error message is displayed.
 
For us the following fix works:
We replaced this code
            for host in hostList:
                b = self.qmf.addBroker(host, _connTimeout)
by this
            authString = _host.split(""@"")
            if len(authString[0]) > 0:
                authString[0] = authString[0] + ""@""
            for host in hostList:
                b = self.qmf.addBroker(authString[0] + host, _connTimeout) 


The error has also been reported as service request no 1959240 at Red Hat's support system."
Bug,QPID-3030,12497357,C++ buffer encoding allows overflow on write.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The framing Buffer::put{Short,Medium,Long}String() or Buffer::putRawData() do not validate the length of the written data, and may allow overflow of the buffer."
Bug,QPID-2395,12455619,fd leak in Connection,shuston,detzi,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"Hi,
with the following code we are able to reproduce a fd leak:

#include <qpid/client/Connection.h>

int main(int argc, char** argv)
{
    while (1) {
        qpid::client::Connection connection;
        connection.open(""localhost"", 5672);
//        connection.close();
    }
}

When closing the connection explicitely as shown in the comment the fd leak no longer occurs. It seems that the destructor of Connection lacks closing the connection.


Regards,
Daniel"
Bug,QPID-4452,12617159,issuing and handling of producer credit not implemented,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,Prevents proper stress testing.
Bug,QPID-4374,12612051,HA throughput issues during longevity testing,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,See https://bugzilla.redhat.com/show_bug.cgi?id=867030
Bug,QPID-1951,12428805,Need wrappers for Posix types declared in Windows portability layer,astitcher,pmackinn,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"Currently, these are declared in qpid/sys/windows/IntegerTypes.h

typedef int              pid_t;
typedef int              ssize_t;

However, these declarations can conflict with other client software C++ headers that have their own Windows declarations of these types.
"
Bug,QPID-1780,12421598,Remove boost dependencies from C++ client API,gsim,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"Currently there is a dependency on Boost headers being present when building a Qpid client application. I believe that Qpid client programmers should not have to be exposed to Boost just for building Qpid applications. It's a Bad Idea to impose a requirement such as this on all users - Boost is a supporting artifact of the implementation and shouldn't be a requirement for users.

More pointedly, it could cause version skew on Windows installed kits. Unlike on RHEL, Windows doesn't offer Boost packages as part of the vendor-supplied OS kit. So, Windows users needing Boost must get their kit somewhere else. This makes it impossible to predict what version of Boost will (or won't) be on a user's system. To take care of this, the Windows installable kit is currently including the needed Boost DLLs that the kit is built against within the install. This removes the need to have Boost installed by the user prior to installing/using Qpid and isolates Qpid's binaries from whatever Boost version is present if there is one. This is a Good Thing except that when trying to build a client app (such as the Qpid examples) Boost ends up getting pulled in from the client API at build time. This is bad because the user now needs to go install Boost. If it's not the same version that the installed kit was built against, there's a chance that object sizes, methods, etc. will differ between what Qpid was built with and what the user installed.

The case that brought this up immediately is that qpid/SessionId.h derives from boost::totally_ordered1<SessionId>. Since qpid/client/Session_Base_0_10.h defines a method which returns a SessionId by value, it needs to pull in SessionId.h which yields a compile error if Boost is not available.
"
Bug,QPID-3103,12500189,qpid-config doesn't handle null arguments for queues/exchanges,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,E.g. when running against java broker this results in failures: Failed: TypeError: argument of type 'NoneType' is not iterable
Bug,QPID-1819,12423045,Large messages cause hangs and crashes when using digest-md5 and security layer (ssf 128),gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"crash ends with:

2009-apr-15 17:43:44 trace guest@QPID.6411302a-229c-4eb1-b097-fc8a613a3233: sent cmd 0: content (65495 bytes) cccccccccccccccc...
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[BEbe; channel=2; {SessionFlushBody: completed=1; }]
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[Bbe; channel=2; {MessageTransferBody: destination=message_queue; accept-mode=0; acquire-mode=0; }]
2009-apr-15 17:43:44 trace SENT [127.0.0.1:56532]: Frame[be; channel=2; header (47 bytes); properties={{MessageProperties: content-length=65495; }{DeliveryProperties: exchange=amq.direct; routing-key=routing_key; }}]
qpidd: qpid/amqp_0_10/Connection.cpp:93: virtual size_t qpid::amqp_0_10::Connection::encode(const char*, size_t): Assertion `workQueue.empty() || workQueue.front().encodedSize() <= size' failed.


pstack for hung client:

Thread 2 (Thread 0xb7f77b90 (LWP 16187)):
#0  0x0069a416 in __kernel_vsyscall ()
#1  0x00ce1b3b in write () from /lib/libc.so.6
#2  0x0024fd80 in qpid::sys::Socket::write () from /usr/lib/libqpidcommon.so.0
#3  0x00255eb4 in qpid::sys::posix::AsynchIO::writeable ()
#4  0x00259152 in
boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,
boost::_mfi::mf1<void, qpid::sys::posix::AsynchIO,
qpid::sys::DispatchHandle&>,
boost::_bi::list2<boost::_bi::value<qpid::sys::posix::AsynchIO*>,
boost::arg<1> (*)()> >, void, qpid::sys::DispatchHandle&>::invoke ()
#5  0x002b77d3 in boost::function1<void, qpid::sys::DispatchHandle&,
std::allocator<boost::function_base> >::operator() () from
/usr/lib/libqpidcommon.so.0
#6  0x002b5b78 in qpid::sys::DispatchHandle::processEvent ()
#7  0x00267ef6 in qpid::sys::Poller::run () from /usr/lib/libqpidcommon.so.0
#8  0x002b53c4 in qpid::sys::Dispatcher::run ()
#9  0x00e8b3d2 in qpid::client::TCPConnector::run ()
#10 0x0025dba1 in ?? () from /usr/lib/libqpidcommon.so.0
#11 0x00dbc51f in start_thread () from /lib/libpthread.so.0
#12 0x00cf204e in clone () from /lib/libc.so.6
Thread 1 (Thread 0xb7f78720 (LWP 16186)):
#0  0x0069a416 in __kernel_vsyscall ()
#1  0x00dc0105 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libpthread.so.0
#2  0x00d00e9d in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x00e70f4d in qpid::client::Bounds::expand ()
#4  0x00eb4642 in qpid::client::SessionImpl::sendFrame ()
#5  0x00eb479c in qpid::client::SessionImpl::handleOut ()
#6  0x00eb7488 in qpid::client::SessionImpl::sendContent ()
#7  0x00eb7db2 in qpid::client::SessionImpl::sendCommand ()
#8  0x00eb7f07 in qpid::client::SessionImpl::send ()
#9  0x00e68afe in qpid::client::no_keyword::Session_0_10::messageTransfer ()
#10 0x0804cf4f in main ()

"
Bug,QPID-4158,12599521,HA transition to CATCHUP status too early.,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"Previously we set status to CATCHUP when the BrokerReplicators bridge was initialized. This is too early, it's possible for an aborted attempt to connect to another backup to get as far as bridge init. This patch waits till we receive the first actual message from the primary before updating status to CATCHUP."
Bug,QPID-2940,12479786,message-accept records are not cleaned up unless getUnsettledAcks() is called,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,The messaging client holds records for all message-accepts issued pending completion of those by the broker. However those records are only cleaned up (i.e. confirmed records removed from the list) when the application calls getUnsettledAcks(). This should be done automatically.
Bug,QPID-3411,12518506,Can't turn off x-reconnect-on-limit-exceeded,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,The messaging API in c++ supports treating a resource limit exception by reconnecting after a backoff period. However that could be previously turned off by the x-reconnect-on-limit-exceeded option. Unfortunately I accidentally removed that option in the refactoring of r1078075 and it needs to be restored.
Bug,QPID-3425,12519003,Using create mode (e.g. for x-bindings) with standard exchanges does not work,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"E.g. use the following with spout (where my-queue already exists):

  amq.direct;{create: always, node:{type: topic, x-bindings:[{exchange:'amq.direct', queue: 'my-queue', key: 'key' }]}}

results in:

  Create failed for exchange amq.direct; not-allowed: not-allowed: Exchange names beginning with ""amq."" or ""qpid."" are reserved. (exchange=""amq.direct"")
"
Bug,QPID-4667,12639127,Selective message acknowledgement does not work over AMQP 1.0,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,I.e using Session::acknowledge(Message&) or Session::acknowledgeUpTo(Message&) rather than simply Session::acknowledge().
Bug,QPID-3412,12518574,Python and C++ clients use link name option differently,gsim,solttom,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"I have a following address string
""response/response.hey_Joe; { create: never, link: { name: 'response.hey_Joe', durable: false, x-declare: { auto-delete: true, exclusive: true, arguments: { 'qpid.max_count': 1000, 'qpid.max_size': 1000000, 'qpid.policy_type': ring } } } }""

When using python client everything works as expected, but with C++ client address ""response/response.hey_Joe"" is incorrectly translated to ""response_response.hey_Joe""."
Bug,QPID-3330,12512256,Address strings unable to have empty strings as option values,gsim,afoglia,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"The Address object can not be constructed from option maps that have empty strings as values, because of parser errors. (e.g. Address(""inbound; { key: '' }"").)

The issue is in AddressParser::readString.  Going into it, current points to the delimiter.  The readChar call moves current up to one past the delimiter.  Then definition of start as current++ moves it one further, which is past the closing delimiter of an empty string."
Bug,QPID-4330,12608323,windows clients hang or fault on exit (static destructors),cliffjansen,cliffjansen,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Windows clients occasionally fail to terminate cleanly after exit() or return from main().  I have examined a large number of stack traces, mostly gibberish presumably from rogue memory writes some time in the past.  Two refreshingly clear traces showed failure when direct or indirect threading calls were made from inside a static destructor: ~IOThread and ~WinSockSetup.

If a DLL (shared object) is winding up due to the library being unloaded (FreeLibrary), the DLL code has an obligation to clean up resources that could leak, and since the process hasn't exited, existing threads live on and threading primitives are trustworthy.   In this case the Windows library may (and should) follow the Linux clean up logic in its static destructors.

If the DLL is winding up due to exit() (or return from main()), it is undefined how quickly other threads will be forcefully terminated.  Locks may be held indefinitely or falsely released (changed in the Vista time frame).  In this case, any fancy footwork is dangerous.  The best course of action is to let the OS clean up things it would anyway, i.e. do nothing if possible.
"
Bug,QPID-3069,12498968,C++ cmake build assumes presence of dotnet binding source,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"The cpp/src/CMakeLists.txt file refers to the cpp/bindings/qpid/dotnet directory, which is not necessarily available if the cpp sources are downloaded in the cpp release package. It should check availability of the directory like it does with WCF."
Bug,QPID-4144,12599142,HA broker deadlocks on broeker::QueueRegistry lock and ha::Primary lock,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Running tests repeatedly, the broker deadlocked with the attached stack trace.

The problem call sequences are:
1. QueueRegistry::destroy takes QueuerRegistry lock > ConfigurationObserver::queueDestroy > ha::Primary::queueDestroy takes Primary lock.
2. ConnectionObserver::opened cals Primary::opened lock> RemoteBackup>getQueues().eachQueue

This patch breaks the deadlock at both ends: QueueRegistry no longer holds the lock across the observer call and Primary does not hold the lock across eachQueue."
Bug,QPID-3225,12505172,Can't control exclusivity for subscription queues via exclusive entry in link options,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. drain -f 'amq.topic; {link: {name: 'my-subscription' ,x-declare: { auto-delete: true, exclusive: false } }

Then queue thus created is exclusive inspite of the flag in the address."
Bug,QPID-1613,12413080,Unsubscribing and resubscribing with LocalQueue causes exception,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"If you subscribe, unsubscribe the resubscribe to a queue using a LocalQueue (not a MessageListener), an exception is thrown with the message ""Queue already exists for ...."". This is due to the way LocalQueues are handled, by registering a demux rule which is not removed when the subscription is cancelled."
Bug,QPID-3007,12496032,"Inconsistent management messages in a cluster, test fails sporadically",aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Management messages on different members of a cluster can be different, which can cause a cluster member to fail with an invalid-arg error.

The cluster_tests.py test_management and test_management_qmf2 exercise management code and collects detailed trace logging. The logs are compared for consistency.

The test is disabled as it does not pass. To enable the test remove these lines from cpp/src/tests/cluster_test_logs.py:91

    # FIXME aconway 2011-01-19: disable when called from unit tests                                                                                                                     
    # Causing sporadic failures, see https://issues.apache.org/jira/browse/QPID-3007                                                                                                    
    if __name__ != ""__main__"": return

When enabled the test fails, all inconsistencies shown by this test need to be resolved."
Bug,QPID-3321,12511462,C++ client memory usage increases when acknowledging messages unless client explicitly calls session.sync() every so often,gsim,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Create a C++ client that receives lots and lots of messages.  Call session.acknowledge(message) on each message.  If you don't call session.sync() periodically, the client application's memory usage will increase over time.  Most of the memory allocated appears to be coming from qpid::client::amqp0_10::AcceptTracker::accept(qpid::framing::SequenceNumber id, qpid::client::AsyncSession& session).  It looks like the broker doesn't send completions for the message acknowledgements, or if it does, not very frequently."
Bug,QPID-2698,12467926,Certain amqp 0-10 message properties are not exposed through messaging apis message class,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,Python Client,,,,,,"In particular app-id and content-encoding, also for incoming messages routing-key."
Bug,QPID-4223,12603233,[New HA] Completion isn't sent when queue that has acquired but unacknowledged messages is deleted,aconway,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"When testing the new HA in 0.18 (from the svn branch, revision 1370693), I've run into a problem where I can't run qpid-cpp-benchmark after I shut down one of the backups.  Here's the scenario:

Start 3 brokers (in my test on 3 different hosts) using the following command line:

qpidd --auth no --load-module ha.so --ha-cluster yes --ha-brokers-url <insert url here> --ha-replicate all

Promote 1 of the brokers to primary.  Run qpid-cpp-benchmark with the default options.  The test should succeed and provide results.  Next, quit 1 of the 2 backups.  Finally, run qpid-cpp-benchmark again.  This time, it hangs.  Looking at the output of ""qpid-stat -q,"" I see there are some unacked messages that have been delivered to the running qpid-receive process."
Bug,QPID-4393,12613196,"HA BrokerReplicator should call queue->bind, not exchange->bind",aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"In BrokerReplicator, there are a few places that it calls exchange->bind().  We're seeing some incorrect behavior during failover testing (e.g. an exchange shows that it has 5 bindings when there is really only 1) and we think we've narrowed it down to this.  Instead of calling exchange->bind(), it should call queue->bind().  If you look at qpid::broker::Broker::createObject(), you'll see that this method calls queue->bind() to bind a queue to an exchange.

(Note that exchange->unbind() appears to be the correct operation for removing a binding, so this shouldn't need to be changed.)"
Bug,QPID-4556,12630133,QueueOptions::setSizePolicy() can cause exception,gsim,brad.hoekstra,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Calling QueueOptions::setSizePolicy() with maxSize > 2GB causes an exception in the C++ broken, which then generates an exception in the C++ client library.

This appears to be because the value is set as an int32 in the FieldTable. The fix appears to be fairly simple:

{noformat} 
Index: 0.20/cpp/src/qpid/client/QueueOptions.cpp
===================================================================
--- 0.20/cpp/src/qpid/client/QueueOptions.cpp	(revision 27169)
+++ 0.20/cpp/src/qpid/client/QueueOptions.cpp	(revision 27170)
@@ -49,8 +49,8 @@
 	
 void QueueOptions::setSizePolicy(QueueSizePolicy sp, uint64_t maxSize, uint32_t maxCount)
 {
-    if (maxCount) setInt(strMaxCountKey, maxCount);
-    if (maxSize) setInt(strMaxSizeKey, maxSize);
+    if (maxCount) setUInt64(strMaxCountKey, maxCount);
+    if (maxSize) setUInt64(strMaxSizeKey, maxSize);
     if (maxSize || maxCount){
         switch (sp)
         {
{noformat} "
Bug,QPID-3832,12542340,Qpid 0.14 broke transport connection setting,gsim,pcolby,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"The transport connection setting was broken in r1156262.

Consider the following test code:
{code}
#include <qpid/messaging/Connection.h>

int main(int argc, char *argv[]) {
    qpid::types::Variant::Map options;
    options[""transport"" ] = ""ssl"";
    qpid::messaging::Connection connection(""localhost:5671"", options);
    connection.open();
    return 0;
}
{code}

Using Qpid 0.12 client libraries, the above code would use SSL.  But with Qpid 0.14, the code will *not* use SSL.

The change in behaviour is a result of code changes to the {{ConnectionImpl::tryConnect}} function in {{cpp/src/qpid/client/amqp0_10/ConnectionImpl.cpp}} in r1156262

Prior to that revision, the {{SimpleUrlParser}} was used, and {{settings}} passed to a {{Connection::open}} overload directly.  This worked fine.

Post that revision, the code looks like this:
{code}
Url url(*i);
if (url.getUser().size()) settings.username = url.getUser();
if (url.getPass().size()) settings.password = url.getPass();
QPID_LOG(debug, *i << "" "" << settings.protocol);
QPID_LOG(debug, url);
connection.open(url, settings);
{code}
(I added the {{QPID_LOG}} calls).

The {{QPID_LOG}} calls produce output like:
{code}
localhost:5671 ssl
amqp:tcp:localhost:5671
{code}

The problem is that the {{Url}} constructor is defaulting the protocol to TCP (via {{UrlParser::protocolAddr}}).  Then, when the {{Connection::open}} overload is called, the {{Url}} object's defaulted-but-now-explicit {{protocol}} value (TCP) is used in preference to the {{settings.protocol}} value (SSL).

I think the correct solution here, thought it would be non-trivial, would be to pass {{settings}} (or at least {{settings.protocol}}) to the {{Url}} constructor as an optional default protocol.  Then the {{Url}} class should use that default protocol instead of TCP when the address string does not include an explicit protocol.

Another option would be to provide some sort of {{Url::protocolWasDefaulted}} flag so that the {{ConnectionImpl::tryConnect}} function could override from {{settings}} when appropriate - this would be less code change, but the above solution would be more elegant IMO.

Note, the obvious workaround is to always use explicit protocols in URLs.  That is, always use ""ssl:hostname"" instead of ""hostname""."
Bug,QPID-3947,12550900,long subject causes encode errors in a loop,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Steps to Reproduce:
1. ./spout
'amq.direct/AReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectAReallyLongSubjectARea'


Actual results:
spout cycles with output:
2012-04-13 16:30:48 error Caught exception in state: 3 with event: 2: Could not
encode string of 256 bytes as uint8_t string. (qpid/framing/Buffer.cpp:255)

The problem is that any bounds checking on str8 fields is done only on encode, so application threads are not correctly notified.
"
Bug,QPID-2640,12466070,options string for connection does not work for some types,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. qpid_receive --connection-options '{heartbeat:1}' -a amq.direct
Failure: invalid conversion: Cannot convert from int32 to uint16 (../../cpp/src/qpid/types/Variant.cpp:238) "
Bug,QPID-3355,12513854,Client aborts when replaying sender after connection recovery,,dillaman,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"There is a race condition between qpid::client::SessionImpl::waitForCompletion and qpid::client::SessionImpl::~SessionImpl.  If one thread is waiting for a
completion and another thread causes the destructor for the session to be invoked, the destructor can abort the client if waitForCompletion is still holding the state mutex.  The reason this occurs is because waitForCompletion is not holding a Waiter::ScopedWait, so the destructor completes while the
mutex is still being held.  This was discovered when testing connection loss and recovery."
Bug,QPID-4257,12605103,"Windows+SSL: Client hang on broker close, broker memory leak",,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Windows clients hang when broker dies via SSL connection - fetch never returns even w/ IMMEDIATE timeout.
Windows broker memory grows linearly with SSL connection count, leak per connection, until broker exhausts memory and crashes."
Bug,QPID-3141,12501336,qpid-config ignores --queue-max-size of 0,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,meaning that you can't override a default queue limit to set an unlimited size on a queue
Bug,QPID-4674,12639580,[AMQP 1.0] receiver not notified when link is detached by peer,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. when fetching a message, if the link underlying the receiver is detached by the peer, the application thread will not be notified and will hang."
Bug,QPID-243,12359738,Inconsistent use of paths in #includes,astitcher,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"
1. With the new release, I have to specify -I${QPID_REL}/include/qpidc,
-I${QPID_REL/include/qpidc/framing and -I${QPID_REL/include/qpidc/sys when
I build which is really naff.

This is because things like Connector.h do a #include
<framing/InputHandler.h>, but then ""framing/InputHandler.h"" only #include
<AMQFrame.h> and AMQFrame.h is located in the framing sub-directory.

"
Bug,QPID-2408,12456448,C++ ClientSessionTest.cpp r910289 breaks Windows build,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,Use of usleep() is not portable; use qpid::sys::usleep() instead.
Bug,QPID-1789,12422100,out of scope sessions incorrectly treated as detached,,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,ConnectionImpl treats sessions that have been allowed to go out of scope (and thus have had their implementations deleted) as being detached. The session is not explicitly detached in this case however and the server will believe it to be attached. This would for example prevent reusing that channel for a new session.
Bug,QPID-2252,12442809,Python tests incorrectly reporting fail on Windows,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Some tests, particularly python_tests, report failures when they don't fail."
Bug,QPID-3606,12531014,Qpid.pc pkgconfig file isn't sufficient to compile programs using qpid API,,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"The pkg-config file currently supplied with qpid only has -lqpidmessing in its LDFLAGS and omits -lqpidtypes.

This used to work in many Linux versions because libqpidmessaging has a dependency on libqpidtypes itself so the library is pulled in. However newer versions of ld require that the link line is complete for the applications direct needs and won't use transitive needs to fulfil needed symbols.

The fix is simply to add -lqpidtypes as well"
Bug,QPID-4008,12556323,tcpNoDelay connection setting causes fatal exception on Windows,cliffjansen,cliffjansen,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"For example ""qpid-perftest --tcp-nodelay"" terminates abnormally when opening its first connection.

The Windows implementation of Socket::setTcpNoDelay lacks a check for INVALID_SOCKET and so fails before the connection is open.  It should set ""nodelay=true"" and return to set the option correctly later from Socket::createSocket.  This is the logic in the Linux implementation.
"
Bug,QPID-2090,12435246,C++ client doesn't build with Boost 1.40,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Boost 1.40 moved the state_saver.hpp to the serialization component. Along with this, the state_saver class moved to the boost::serialization namespace. These changes in Boost cause qpid/client/Dispatcher.cpp to fail compilation."
Bug,QPID-4478,12617845,AMQP 1.0: flow is occasionally not sent when setting capacity,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,This is due to not waking up the driver thread to handle the IO.
Bug,QPID-2407,12456346,C++ SSL session can get bad buffer management,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Thanks to Cliff Jansen for alerting me to this problem.

It's possible for an SSL-negotiated session on Windows to end up with odd errors or an exception. One session I caught in the debugger ended with a ENOBUFS errors on a network receive; the buffer involved ended up having a data-start greater than the length of the buffer, and the calculated receive length for the operation was a negative value.

Can be reproduced using perftest on Windows; I ran against a Linux broker, but similar results can probably happen in either direction depending on the traffic pattern."
Bug,QPID-3185,12503299,Wrong help text for qpid-config,tross,jonathan.robie,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"Help text for qpid-config is wrong for  --max-queue-size, --max-queue-count.

This is fixed in 1087706:

http://svn.apache.org/viewvc?rev=1087706&view=rev "
Bug,QPID-4159,12599531,HA missing messages in failover test.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Running this test: 

 ha_tests.py *.test_failover_send_receive -DDURATION=2

in a loop eventually fails with something like:

  AssertionError: test8 missing message 17529>17454

The test should run indefinitely with no missing messages."
Bug,QPID-3963,12551622,A federated broker may not reconnect to a remote cluster on link failure.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"When a broker is federated with a cluster, the cluster informs the broker of the failover addresses that are valid for the cluster.  Should a cluster member fail, the broker will reconnect to another member of that cluster.

However, the federated broker only queries the cluster for these failover addresses when it first connects to the cluster.  Should the cluster topology change, the federated broker's list of available failover addresses will become out-of-date.  This can prevent the broker from correctly re-connecting on failure of a cluster member.

Example:
Given cluster with members C1 and C2, and a separate broker B, federate B to connect to C1.   On connecting to C1, B learns the addresses of C2 as an alternate failover address.  Now shutdown C1.  B will reconnect to C2, and learn that C2 is the only member of the cluster (ie. no failover addresses).   After B connects, restart C1 and let it join the cluster.  Then shutdown C2.   Since B does not know that C1 has become available again, B will not attempt to re-connect to it.  Instead, it tries to reconnect to C2 indefinately.

The expected behavior would be to have B reconnect to C1."
Bug,QPID-3399,12518075,Qpidd possible memory leaks,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Clustered brokers memory use grows excessively.

See https://bugzilla.redhat.com/show_bug.cgi?id=726379 for details."
Bug,QPID-3372,12515413,Asserting on arguments does not work for exchanges; incorrectly throws exception,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. test-4;{assert:always, create:always, node:{durable:True, type:topic, x-declare:{arguments:{qpid.msg_sequence:True}, auto-delete:False, type:headers}}} results in error Option qpid.msg_sequence does not match for test-4, expected F1:boolean(1), got F1:boolean(1)"
Bug,QPID-2728,12468955,Windows icon/version additions broke nightly builds,tross,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Recent additions to include version and icon resources in the Windows builds result in build errors. I don't know why I'm getting different errors on different builds, but here's what I see:

64-bit build:
One of these for each library:
1>.\windows\resources\qpidtypes-resource.rc(20) : fatal error RC1015: cannot open include file 'version-resource.h'.

See: http://www.riverace.com/CDash-1.4.2/viewBuildError.php?buildid=735 for all messages

32-bit build (configure error):
CMake Error in src/CMakeLists.txt:
  Cannot find source file ""qmf-resource.rc"".  Tried extensions .c .C .c++ .cc
  .cpp .cxx .m .M .mm .h .hh .h++ .hm .hpp .hxx .in .txx

"
Bug,QPID-3159,12501977,qmfgen -2 crashes,tross,asalkeld,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"I have:

cat schema-1.xml
<schema package=""org.foobar"">
<class name=""apple"">
   <method name=""rott""   desc=""rott"">
     <arg name=""speed""   dir=""I"" type=""uint32""/>
     <arg name=""review""  dir=""O""  type=""sstr""/>
   </method>
</class>
</schema>

Then I run ""qmf-gen -2 schema-1.xml""
Traceback (most recent call last):
  File ""/usr/bin/qmf-gen"", line 80, in <module>
    gen.makeV2PackageFile(""V2Package.cpp"", package, vars=vargs)
  File ""/usr/lib/python2.7/site-packages/qmfgen/generate.py"", line 467, in makeV2PackageFile
    stream = template.expand (schema)
  File ""/usr/lib/python2.7/site-packages/qmfgen/generate.py"", line 100, in expand
    self.expandLine (line, stream, object)
  File ""/usr/lib/python2.7/site-packages/qmfgen/generate.py"", line 88, in
    expandLine
    self.handler.substHandler (object, stream, tagObject, tagName)
  File ""/usr/lib/python2.7/site-packages/qmfgen/generate.py"", line 392, in
    substHandler
    eval (call)
  File ""<string>"", line 1, in <module>
  File ""/usr/lib/python2.7/site-packages/qmfgen/schema.py"", line
    1734, in genV2ClassDefines
    if stat.unit:
  UnboundLocalError: local variable 'stat' referenced before assignment
"
Bug,QPID-3508,12524831,Subscription queue not unbound or deleted on Receiver::close(),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,By default subscription queues are only deleted (and thus fully unbound) when the session is closed. This means that they still collect messages after a receiver is closed which is incorrect. 
Bug,QPID-2817,12472075,Connection::close() may hang if broker is suspended,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"This simulates the case where the physical connection is lost somehow, but the socket isn't disconnected. The client will wait indefinitely (or until TCP times out) for the close-ok response. Normally heartbeats fix this issue, but they are turned off on close before the client waits for the brokers response."
Bug,QPID-4148,12599295,HA Not setting initial queues for new RemoteBackups,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Fix bug introduced by r1362584: ""QPID-4144 HA broker deadlocks on broker::QueueRegistry lock and ha::Primary lock""
Stopped setting initial queues on new (i.e. not expected) RemoteBackups.
"
Bug,QPID-2153,12438370,channel collision renders pre-existing session unusable on client,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"There are 2^16 channels available on each connection. Each session in use
requires one of these channels to be assigned. If more than 2^16 sessions are
created and deleted, the channel allocated to new sessions 'wraps around' and
can result in a collision with that allocated to a pre-existing session
resulting in a session-busy exception. This exception renders the pre-existing
session unusable on the client side (though the broker still assumes it is
attached).

Though there is a check for in-use sessions, the channel is set on the new session regardless of that check and when that session is then destroyed (as it will be if the exception is thrown) it will request the session on that channel to be erase (on the invalid assumption that it refers to itself)."
Bug,QPID-1952,12428877,C++: client request memory leak on windows,shuston,drennalls,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"I'm experiencing a memory leak when using the client library on Windows (0.5 release) when sending a single request. From what debugging I've done so far it looks like the The AsynchIO object used by the TCPConnector is not being deleted.  When the connection is being closed aio->queueForDeletion() is called from TCPConnector::closeInternal().. However in AsynchIO::queueForDeletion() aio.opsInProgress > 0 so the 'delete this' branch is not done. There are no more queueForDeletion() calls made on the aio object (after opsInProgress is 0) and so it never gets deleted. The ConnectionImpl object involved is not cleaned up either, the shared_ptr to it has a non-zero ref count but I'm guessing it's related to the AsynchIO object not being cleaned up.

There used to be some code in AsynchIO::completion() that seems like it would do the necessary delete (see below). It was removed with code changes in https://issues.apache.org/jira/browse/QPID-1550 because 'It fixed a memory corruption on the broker side by deleting too early' (from Steve H.)

-    // Lock released; ok to delete if all is done.
-    if (opsInProgress == 0 && queuedDelete)
-        delete this;

"
Bug,QPID-2511,12462169,ConnectionImpl instance may be deleted before IO threads are finished with the underllying DispatchHandle,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"this means that the callbacks can be made on dangling pointers, causing segfaults. (A simple test is to run a client against a broker with auth turned on that fails authentication, e.g. qpidd -d; perftest --username blah --password blah --mechanism PLAIN)."
Bug,QPID-4484,12618255,C++ qpidmessaging compile error on RHEL 5 gcc 4.1.2,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Building C++ qpidmessaging on RHEL 5 with updated gcc 4.1.2 produces an error:

cc1plus: warnings being treated as errors
/qpidbuilds/trunk/qpid/cpp/src/../include/qpid/RangeSet.h: In instantiation of ?쁰pid::RangeSet<qpid::framing::SequenceNumber>??
/qpidbuilds/trunk/qpid/cpp/src/../include/qpid/framing/SequenceSet.h:32:   instantiated from here
/qpidbuilds/trunk/qpid/cpp/src/../include/qpid/RangeSet.h:193: warning: lowering visibility of ?쁲td::ostream& qpid::operator<<(std::ostream&, const qpid::RangeSet<U>&) [with U = U, T = qpid::framing::SequenceNumber]??to match its type
make[2]: *** [src/CMakeFiles/qpidmessaging.dir/qpid/messaging/ProtocolRegistry.o] Error 1

The way to silence this warning is to add -Wno-attributes along with -fvisibility=hidden. "
Bug,QPID-3001,12495762,Add const declaration to Connection::isOpen(),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Rationale being that it is a read only operation. Need to avoid breaking ABI, so adding a const alternative alongside the existing non-const method is probably best."
Bug,QPID-2982,12493793,Inconsistent management messages in a cluster with federation routes,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Management messages on different members of a cluster can be different, which can cause a cluster member to fail with an invalid-arg error.

The cluster_tests.py has a test_management test which exercises management code and collects detailed trace logging. The logs are compared for consistency.

Currently this test fails. All inconsistencies revealed by the test need to be corrected."
Bug,QPID-3215,12504667,cached exchange reference can cause cluster inconsistencies if exchange is deleted/recreated,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,,,,,,"Description of problem:

SemanticState::route() uses a simple cache variable to avoid looking up the
exchange for every message. However if the exchange in question is deleted,
even if then recreated, this can cause inconsistencies in a cluster.

Version-Release number of selected component (if applicable):

1.3

How reproducible:

100% (Quite a contrived example though)

Steps to Reproduce:
1. start one cluster node
2. create an exchange, a queue and a binding between them

  qpid-config add exchange topic x
  qpid-config add queue q
  qpid-config bind x q k

3. start a session and send a message to the exchange with the relevant key
(leave session running)

  qpid-send --content-stdin --address x/k

then enter a few lines to send some messages

4. start a new cluster node
5. delete and recreate the exchange, this time add in a different binding

  qpid-config del exchange x
  qpid-config add exchange topic x
  qpid-config add queue q2
  qpid-config bind x q2 k  

6. send some more messages on the session from 3. with same exchange and key
(i.e. type in some more messages if using qpid-send as suggested)

  now have an inconsistency where the second node has some messages in q2 and
some (though fewer than first node) in q1, whereas for first node all the
messages are in q1

7. qpid-receive --address 'q2; {mode: browse}' --broker localhost:5673
--capacity 1 (assuming second node is 5673)

Actual results:

First node shutsdown with inconsistent error

Expected results:

No inconsistency, should be able to run the command in 7 against q or q2 on
either node and see the same results.
"
Bug,QPID-2403,12456050,Consistent management names for connections in a cluster.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Clustering,QMF,,,,,"Management objects representing connections in a broker are named for the remote end of the socket ip:port. In a cluster, a broker has normal connections and ""shadow"" connections representing a connection on another broker. The shadow connections are named ""[shadow]ip:port"" Management tools use this convention to ignore shadow connections and display only the local connections to a broker.

This is inconsistent with other management objects which are named identically in all brokers, and the problem is compounded because connections are containers for other objects (sessions, consumers) so inconsistency in the connection name makes the names of all the children inconsistent.

Commit r907123 fixed this by making the connection names consistent and adding a ""shadow"" property to the qmf Connection object. However this broke the Java builds. This JIRA is to discuss what the correct solution should be that works for both brokers."
Bug,QPID-1869,12425997,Segfault in connector when poller initialisation fails due to lack of available file handles,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"A seg fault occurs in the client library when reopening a connection after
reports of lack of available file handles looking something like:

#0  qpid::client::TCPConnector::closeInternal (this=0x9d1b140)
    at qpid/client/Connector.cpp:227
227             aio->queueForDeletion();
(gdb) bt
#0  qpid::client::TCPConnector::closeInternal (this=0x9d1b140)
    at qpid/client/Connector.cpp:227
#1  0x00a6dc3d in qpid::client::TCPConnector::close (this=0x9d1b140)
    at qpid/client/Connector.cpp:240
#2  0x00a627e4 in ~ConnectionImpl (this=0x9d1abe0)
    at qpid/client/ConnectionImpl.cpp:92
#3  0x00a56fc8 in boost::detail::sp_counted_impl_p<qpid::client::ConnectionImpl>::dispose (this=0x9d1b058) at /usr/include/boost/checked_delete.hpp:34
#4  0x00a5590e in qpid::client::Connection::open (this=0xbfb3ec64,
    settings=@0xbfb3ec24)


If when opening a connection there is only one file handle remaining, the
socket for the connection is created, but the fds required for the poller's
readable pipe are not available. Initialisation of the connectors Poller object
fails and the AsynchIO object is left uninitialised. However the closed flag
has already been set to false so when the associated connector is then deleted
(e.g. on reopening the connection), it tries to shutdown the AsynchIO object
which has not been initialised and there is a segfault.  "
Bug,QPID-3202,12504070,"Clustered broker shuts down with ""unknown connection"" error",aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Brokers in a cluster shut down with an ""unknown connection"" error when running the management test:
{noformat}
  make check TESTS=run_cluster_tests CLUSTER_TESTS=*.test_management*
{noformat}
The unknown connection error is an assertion recently introduced in r1091097, the bug has probably been there for a while."
Bug,QPID-2402,12456036,qpid::messaging.Message::setTTL() unit ambiguity can cause unexpectected behavior,gsim,kbonin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid::messaging.Message::setTTL( boost::uint64_t ttl ) - does not declare its units.

The currently exposed time types are AbsTime and Duration, which seems to imply they should be used for encapsulating time.

When a Duration object is passed to setTTL, the inline operator int64_t() returns the member variable nanoseconds.

When this value is propagated to the broker, it is interpreted around  /cpp/src/qpid/broker/Message # 353 to be in millisecond units.

I would recommend:
- document Message.setTTL units clearly - pick ms or ns
  - if ms, then overload setTTL to take a Duration object so we can use without error by converting in setTTL
  - if ns, then somewhere downstream (OutgoingMessage#351 ?) the ns needs to get converted to ms

"
Bug,QPID-4360,12610590, Non-ready HA broker can be incorrectly promoted,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Description of problem:
rgmanager can promote a non-ready backup HA broker to primary when other backup brokers are available in the ready state.  This can result in loss of messages and broker configuration.  Additionally, this can cause the previously ready backups to throw exceptions when connecting to the new primary:

Sep 20 10:17:18 itcm12 qpidd[10871]: 2012-09-20 10:17:18 [HA] critical Backup queue Queue1: Replication failed: Invalid position move, preceeds messages
Sep 20 10:17:18 itcm12 qpidd[10871]: 2012-09-20 10:17:18 [Protocol] error Unexpected exception: Invalid position move, preceeds messages
Sep 20 10:17:18 itcm12 qpidd[10871]: 2012-09-20 10:17:18 [Broker] error Connection 10.3.100.12:43837-10.3.100.105:9006 closed by error: Invalid position move, preceeds messages(501)

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
100%

Steps to Reproduce:
1. Start a primary and backup broker
2. Inject messages into the primary and ensure messages replicate to backup
3. Restart the primary broker and manually re-promote to primary
  
Actual results:
Restarted broker becomes primary

Expected results:
Restarted broker refuses to become primary since at least one ready backup was discovered within some timeout"
Bug,QPID-3087,12499757,Bad handling of invalid queue arguments,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Tools,,,,,,"Passing bad arguments to queue-declare (e.g. max-count=3.14 or max-size='foo') currently results in those arguments being ignored, but being reported from queue-query or via qmf as they were originally specified. There is a further problem with qpid-config in these cases where it fails due to attempts to convert these values to integers and therefore does not list all queues."
Bug,QPID-783,12388231,Messages get lost between credit allocation and ,,jonathan.robie,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,JMS AMQP 0-x,Python Client,Ruby Client,,,,"As I understand it, a client should receive all messages sent after it subscribes and allocates credit.

Currently, the C++ client sometimes loses messages sent between the time credit is allocated and the time that dispatcher.listen() is called. I believe this is wrong behavior. This bug has been observed in Listener.cpp for both fanout and direct. We suspect this problem exists also in at least the Python client.

Correct behavior, as I understand it, is to queue all messages sent after credit is allocated.

Jonathan"
Bug,QPID-4095,12596290,Boost 1.50.0 has removed filesystem version 2 from the library,astitcher,davin,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,C++ Clustering,,,,,The build fails when building against boost 1.50.0 because version 0.16 and earlier require boost filesystem version 2 which has been removed from boost version 1.50.0.
Bug,QPID-4145,12599167,HA Minor fixes to recovery,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"- Demote timed-out backups from ready to catch-up.
- Don't cancel connected backups on timeout, only disconnected ones.
- Don't allow promotion of a catch-up broker.
- Minor logging improvement.
"
Bug,QPID-3563,12529467,Unprotected access to accept tracking state can cause crash,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Crash with the following backtrace reported:

Thread 1 (Thread 0x5512d940 (LWP 4479)):
#0  min<qpid::framing::SequenceNumber> (this=0x2aaaac009b38, r=...) at /usr/include/c++/4.1.2/bits/stl_algobase.h:189
#1  touching (this=0x2aaaac009b38, r=...) at ../include/qpid/RangeSet.h:71
#2  qpid::RangeSet<qpid::framing::SequenceNumber>::addRange (this=0x2aaaac009b38, r=...) at ../include/qpid/RangeSet.h:229
#3  0x00000038ca3e350a in operator+= (this=0x2aaaac009b38, s=<value optimized out>) at ../include/qpid/RangeSet.h:150
#4  operator+= (this=0x2aaaac009b38, s=<value optimized out>) at ../include/qpid/RangeSet.h:149
#5  qpid::framing::SequenceSet::add (this=0x2aaaac009b38, s=<value optimized out>) at qpid/framing/SequenceSet.cpp:69
#6  0x00000038cd242bf8 in qpid::client::amqp0_10::AcceptTracker::delivered (this=0x2aaaac009b38, destination=""RRAA+b+APP5.AppQueue"", id=...) at qpid/client/amqp0_10/AcceptTracker.cpp:58
#7  0x00000038cd26014d in qpid::client::amqp0_10::IncomingMessages::retrieve (this=0x2aaaac009aa0, command=..., message=<value optimized out>) at qpid/client/amqp0_10/IncomingMessages.cpp:279
#8  0x00000038cd2601bb in qpid::client::amqp0_10::IncomingMessages::MessageTransfer::retrieve (this=<value optimized out>, message=0xfbfede0926f3eaeb)
    at qpid/client/amqp0_10/IncomingMessages.cpp:292
#9  0x00000038cd26a14a in qpid::client::amqp0_10::SessionImpl::accept (this=<value optimized out>, receiver=0x2aaaac00ae10, message=0x2aaab4008210, transfer=...)
    at qpid/client/amqp0_10/SessionImpl.cpp:304
#10 0x00000038cd270407 in operator() (function_obj_ptr=<value optimized out>, a0=...) at /usr/include/boost/bind/mem_fn_template.hpp:353
#11 operator()<bool, boost::_mfi::mf3<bool, qpid::client::amqp0_10::SessionImpl, qpid::client::amqp0_10::ReceiverImpl*, qpid::messaging::Message*, qpid::client::amqp0_10::IncomingMessages::MessageTransfer&>, boost::_bi::list1<qpid::client::amqp0_10::IncomingMessages::MessageTransfer&> > (function_obj_ptr=<value optimized out>, a0=...) at /usr/include/boost/bind.hpp:403
#12 operator()<qpid::client::amqp0_10::IncomingMessages::MessageTransfer> (function_obj_ptr=<value optimized out>, a0=...) at /usr/include/boost/bind/bind_template.hpp:32
#13 boost::detail::function::function_obj_invoker1<boost::_bi::bind_t<bool, boost::_mfi::mf3<bool, qpid::client::amqp0_10::SessionImpl, qpid::client::amqp0_10::ReceiverImpl*, qpid::messaging::Message*, qpid::client::amqp0_10::IncomingMessages::MessageTransfer&>, boost::_bi::list4<boost::_bi::value<qpid::client::amqp0_10::SessionImpl*>, boost::_bi::value<qpid::client::amqp0_10::ReceiverImpl*>, boost::_bi::value<qpid::messaging::Message*>, boost::arg<1> > >, bool, qpid::client::amqp0_10::IncomingMessages::MessageTransfer&>::invoke (function_obj_ptr=<value optimized out>, a0=...)
    at /usr/include/boost/function/function_template.hpp:119
#14 0x00000038cd278d3f in boost::function1<bool, qpid::client::amqp0_10::IncomingMessages::MessageTransfer&, std::allocator<boost::function_base> >::operator() (this=0x20fe, a0=...)
    at /usr/include/boost/function/function_template.hpp:576
#15 0x00000038cd2703bd in qpid::client::amqp0_10::(anonymous namespace)::IncomingMessageHandler::accept (this=<value optimized out>, transfer=...) at qpid/client/amqp0_10/SessionImpl.cpp:279
#16 0x00000038cd261bed in qpid::client::amqp0_10::IncomingMessages::get (this=0x2aaaac009aa0, handler=..., timeout=<value optimized out>) at qpid/client/amqp0_10/IncomingMessages.cpp:121
#17 0x00000038cd269f8e in qpid::client::amqp0_10::SessionImpl::getIncoming (this=<value optimized out>, handler=..., timeout=<value optimized out>) at qpid/client/amqp0_10/SessionImpl.cpp:324
#18 0x00000038cd26aef8 in qpid::client::amqp0_10::SessionImpl::get (this=0x2aaaac009a50, receiver=<value optimized out>, message=<value optimized out>, timeout=...)
    at qpid/client/amqp0_10/SessionImpl.cpp:330
#19 0x00000038cd26757d in qpid::client::amqp0_10::ReceiverImpl::getImpl (this=0x2aaaac00ae10, message=..., timeout=...) at qpid/client/amqp0_10/ReceiverImpl.cpp:158
#20 0x00000038cd269399 in operator() (this=0x2aaaac009a50, f=...) at qpid/client/amqp0_10/ReceiverImpl.h:107
#21 qpid::client::amqp0_10::SessionImpl::execute<qpid::client::amqp0_10::ReceiverImpl::Get> (this=0x2aaaac009a50, f=...) at qpid/client/amqp0_10/SessionImpl.h:99
#22 0x00000038cd2675dc in qpid::client::amqp0_10::ReceiverImpl::get (this=0x2aaaac00ae10, message=<value optimized out>, timeout=...) at qpid/client/amqp0_10/ReceiverImpl.cpp:64
#23 0x00000038cd23f7fd in qpid::messaging::Receiver::get (this=<value optimized out>, message=..., timeout=...) at qpid/messaging/Receiver.cpp:36

Jason Dillaman observes that 'IncomingMessages::retrieve() can call AcceptTracker::delivered() while not
holding a lock'."
Bug,QPID-1785,12421994,Race condition in closing session due to exception,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"If a Session object goes out of scope, the ConnectionImpl will throw a
FramingErrorException for any frames received on the correspodning channel. 

This is in itself incorrect as the broker may not have ever been sent a detach.
However it only causes a real problem when a session is closed due to an
exception. In this case the client receives an execution.exception command
followed by a session.detach control. If the session goes out of scope between
the processing of these two, the handling of the detach causes a
FramingErrorException which causes the client to close the connection thus
destroying all other active sessions.  "
Bug,QPID-1667,12414957,Second form of qpid::client::SubscriptionManager::setFlowControl is infinitely recursive,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"    void setFlowControl(const std::string& name, uint32_t messages,  uint32_t bytes, bool window=true) {
        setFlowControl(name, messages, bytes, window);
    }
"
Bug,QPID-2130,12437316,List/Map Content/View changes in r821000 not reflected in CMakeLists.txt,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Change in cpp/src/Makefile.am for qpidclient in r821000 ""define content- and view- classes separately from message class"" were not reflected in CMakeLists.txt, causing CMake-based builds to fail.

I'm testing the fixes now."
Bug,QPID-1478,12408907,qpid::client::Bounds::reduce incorrectly asserts there is only one waiter,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"This is incorrect because there may be multiple threads sending commands on the connection and any or all of them could be blocked. It also needs to notify all, not just one."
Bug,QPID-4552,12629600,C++ Messaging examples don't build,mcpierce,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Changes made for QPID-4372 2013-01-18 r1435129 remove messaging examples from the build pool. The usual spout, drain, client, server, hello_world don't get built.

Reverting the change brings them back so possibly they are too aggressive."
Bug,QPID-2061,12433517,More dll symbol exports for Windows needed in 0.6,cliffjansen,cliffjansen,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,I propose this Jira to serve as a place to attach patches that solely add dll export syntax sugar for Windows applications during the 0.6 timeframe.
Bug,QPID-4428,12615230,HA add UUID tag to avoid using an out of date queue.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Here's the scenario: we have a cluster with primary A and backups B and C. There is a queue Q that is replicated to both. Now A dies and B takes over as primary. Before C has connected to B, a client destroys Q and creates a new queue with the same name, Q. When C does connect it sees a queue named Q and mistakenly assumes it is the same queue as it's own Q - so it has an incorrect replica of Q. The same scenario applies to exchanges.

The fix is to tag queues and exchanges with a UUID, so backups can identify that the queue has changed even if the name is the same."
Bug,QPID-3190,12503505,qpid-tool does not allow numeric strings to be passed as strings,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"E.g. if you use the echo method on broker and want to send a body containing the string '1234' you cannot do so. If you quote the string the quotes get included in the argument, of you don't quote it gets converted to an integer and you get a type conversion error back."
Bug,QPID-4447,12616955,C++ Client can hang during connect if heartbeat disconnect fires,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,There is a race condition since r1357827 which can hang a c++ client if heartbeat disconnect fires on the client which can cause a TimerTask to be cancelled during a Timer callback (as part of a Connection delete) which leads to a deadlock as noted in the comments for that checkin.
Bug,QPID-4128,12598256,HA should not use amq.failover for replication links,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"HA replication links should  not use the amq.failover exchange to get updates reconnect targets. amq.failover provides the client failover list, HA manages a separate failover list for brokers. Replication links should be using the broker list, and not allow it to be overwritten by amq.failover updates.

Review requested for 0.18, 2 line fix."
Bug,QPID-2497,12461683,messaging api silently ignores unrecognised/invalid address options,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,should throw error to avoid confusing users
Bug,QPID-3544,12526856,ACL denials while replicating exclusive queues to a newly joined node,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"(from https://bugzilla.redhat.com/show_bug.cgi?id=689408)
Consider the following scenario:

A user 'acluser' has access to:
* create queues with name user.foo.*
* bind to the exchange user.exchanges

When one creates a receiver that logs in as acluser and creates an exclusive
queue, any node that joins the existing broker in the cluster (and using the
same acl file) will not be able to replicate the exclusive queue.

The cluster-username is defined such that it has all privileges and is hence
not limited by ACL.

Version-Release number of selected component (if applicable):
qpid-cpp-server-0.7.946106-28.el5

How reproducible:
Always

Steps to Reproduce:
1. Create ACL for a user as above
2. Create exchange user.exchanges
3. Create exclusive queue user.foo.me as acluser
4. Start the second broker

Actual results:
Second broker fails to start. following error is seen in the logs:

Feb 11 20:00:26 dell-pe1950-2 qpidd[1028]: 2011-02-11 20:00:26 info ACL Deny
id:acluser@QPID action:bind ObjectType:exchange Name:qpid.cluster-update
Feb 11 20:00:26 dell-pe1950-2 qpidd[1028]: 2011-02-11 20:00:26 error Execution
exception: unauthorized-access: ACL denied exchange bind request from
acluser@QPID (qpid/broker/SessionAdapter.cpp:182)

Expected results:

Replication should succeed.

Additional info:

It looks like the update for session scope objects like exclusive queues are
being done with the session owning user and not with the cluster-username. This
seems to be the problem, since the session owning user in this case does not
have the right privileges to bind to qpid.cluster-update.

One could simply write an ACL rule allowing all users access to
qpid.cluster-update but that may not be the best way to fix this since only the
replication process should have this kind of access."
Bug,QPID-1733,12416847,Examples on Windows fail auth if run against Windows broker launched with defaults,shuston,pmackinn,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"For example, <snip>\qpid\cpp\examples\qmf-console>printevents.exe
2009-mar-13 10:54:47 warning Broker closed connection: 320, connection-forced: Unsupported mechanism 

Tracing from the Windows broker:

<snip>
2009-mar-13 11:13:47 info No message store configured, persistence is disabled.
2009-mar-13 11:13:47 info SASL enabled
2009-mar-13 11:13:47 notice Listening on TCP port 5672
2009-mar-13 11:13:47 notice Broker running
2009-mar-13 11:13:59 debug RECV [127.0.0.1:4094] INIT(0-10)
2009-mar-13 11:13:59 info SASL: Mechanism list: ANONYMOUS PLAIN
2009-mar-13 11:13:59 trace SENT 127.0.0.1:4094 INIT(0-10)
2009-mar-13 11:13:59 trace SENT [127.0.0.1:4094]: Frame[BEbe; channel=0; {ConnectionStartBody: server-properties={qpid.federation_tag:V2:36:str16(3cb5c19b-865d-4ebf-9d1a-9d7fb862ac35)}; mechanisms=str16{V2:9:str16(ANONYMOUS), V2:5:str16(PLAIN)}; locales=str16{V2:5:str16(en_US)}; }]
2009-mar-13 11:13:59 trace RECV [127.0.0.1:4094]: Frame[BEbe; channel=0; {ConnectionStartOkBody: client-properties={qpid.client_pid:F4:int32(672),qpid.client_ppid:F4:int32(0),qpid.client_process:V2:0:str16(),qpid.session_flow:F4:int32(1)};mechanism=; response=xxxxxx; locale=en_US; }]
2009-mar-13 11:13:59 info SASL: Starting authentication with mechanism:
2009-mar-13 11:13:59 debug Exception constructed: Unsupported mechanism
2009-mar-13 11:13:59 trace SENT [127.0.0.1:4094]: Frame[BEbe; channel=0; {ConnectionCloseBody: reply-code=320; reply-text=connection-forced: Unsupported mechanism; }]
2009-mar-13 11:13:59 debug DISCONNECTED [127.0.0.1:4094]
2009-mar-13 11:13:59 info Delete AsynchIO queued; ops in progress

Workaround is to launch broker with ""--auth no"""
Bug,QPID-2406,12456343,Consistent approach to durations in qpid::messaging api,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,in particular no direct use of qpid::sys::Time.h
Bug,QPID-2387,12455212,"qpidd does not replicate management agent lists, causes brokers to exit. ",aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"The broker's  ManagementAgent keeps a list of agents connected to the broker. This list is not replicated to new members joining a cluster. This causes inconsistencies in messages to clients suscribed for management events which causes brokers to exit the cluster.

See: https://bugzilla.redhat.com/show_bug.cgi?id=560692"
Bug,QPID-1137,12398234,[C++] It is required to call Connection::close even if it fails to connect to the broker using Connection::open,gsim,danushka,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"I found this flaw when I was using Qpid/C++ to implement AMQP transport for Axis2/C. 

There I wanted to make the Axis2/C AMQP transport receiver such that it checks for the availability of the Qpid broker and waits in a loop until the broker is up.For this I used a class level Connection object. But with that implementation, when the broker comes up after some time, the Connection object still fails to establish the connection and gives the ""Connection refused ... "" error. [Socket.cpp:158]. As a remedy for this I had to call Connection::close inside the exception handler. 

I dont think this is acceptable unless there is a really solid reason behind it."
Bug,QPID-4559,12630378,qpid-config deletes queue which contains messages,tross,eallen,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"qpid-config tool deletes a queue even if it contains some messages. The ""force"" command line options are not honored. "
Bug,QPID-3457,12520287,qpid::Msg::str() method not exported,aconway,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Trunk r1161742 added a Msg::str() method to cpp/src/qpid/Msg.cpp - this method is not marked with an extern decorator, so it's not visible outside qpidcommon (where Msg.cpp is built) on Windows. This causes build errors on Windows, with unresolved external references to the method."
Bug,QPID-4138,12598745,HA sporadic failure in ha_tests,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Sporadic failure in ha_tests. 2 types of failure observed:

==== failure 1
ha_tests.LongTests.test_failover_send_receive ....................................... start
  Traceback (most recent call last):
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 884, in test_failover_send_receive
      brokers[(i+1)%3].wait_status(""ready"")
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 117, in wait_status
      assert retry(try_get_status, timeout=20), ""%s status != %r""%(self, status)
  AssertionError: Broker<003:cluster0-0.log qpidd-23 :58163> status != 'ready'
ha_tests.LongTests.test_failover_send_receive ....................................... fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpidha/opt/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 884, in test_failover_send_receive
      brokers[(i+1)%3].wait_status(""ready"")
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 117, in wait_status
      assert retry(try_get_status, timeout=20), ""%s status != %r""%(self, status)
  AssertionError: Broker<003:cluster0-0.log qpidd-23 :58163> status != 'ready'

==== failure 2

ha_tests.LongTests.test_failover_send_receive ........................................ start
  Traceback (most recent call last):
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 884, in test_failover_send_receive
      brokers[(i+1)%3].wait_status(""ready"")
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 117, in wait_status
      assert retry(try_get_status, timeout=20), ""%s status != %r""%(self, status)
  AssertionError: Broker<003:cluster0-0.log qpidd-23 :47682> status != 'ready'
ha_tests.LongTests.test_failover_send_receive ........................................ fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpidha/opt/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 884, in test_failover_send_receive
      brokers[(i+1)%3].wait_status(""ready"")
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 117, in wait_status
      assert retry(try_get_status, timeout=20), ""%s status != %r""%(self, status)
  AssertionError: Broker<003:cluster0-0.log qpidd-23 :47682> status != 'ready'

==== failure 3

ha_tests.ReplicationTests.test_send_receive ......................................... fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpidha/opt/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 382, in test_send_receive
      brokers[2].assert_browse_backup(""q"", expect, transform=sn)
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/ha_tests.py"", line 158, in assert_browse_backup
      assert_browse_retry(bs, queue, expected, **kwargs)
    File ""/home/aconway/qpidha/qpid/cpp/src/tests/brokertest.py"", line 466, in assert_browse_retry
      assert expect_contents == actual_contents, msg
  AssertionError: browse failed: [991L, 992L, 993L, 994L, 995L, 996L, 997L, 998L, 999L, 1000L] != [990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000]
"
Bug,QPID-1473,12408786,C++ build process must generate MaxMethodBodySize.h on build platform,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The release process generates needed C++ code from the various definitions, including MaxMethodBodySize.h, which is very important. However, the MaxMethodBodySize.h generated during release may not be appropriate for all targets. In particular, it is not compatible with what's generated on Windows and results in some static assertion failures that some method bodies are too big. (MAXMETHODBODYSIZE is 148 on Linux, 456 on Windows!)

The fix for this is to have the Windows Visual Studio solution include a project to build the MaxMethodBodySize.h file. I have a project ready and will commit it soon."
Bug,QPID-2612,12464739,Recent DLL qpidtypes breaks the build on Windows,gsim,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"At a minimum the project H files must change QPID_COMMON_EXTERN to QPID_TYPES_EXTERN to get the import/export straight.

However, there's a bigger problem with circular dependencies between qpidcommon and qpidtypes. The common has windows/sys and framing that types needs and vice versa. 

Linux avoids this problem by having the dependencies resolved at load time."
Bug,QPID-2428,12458068,qpid.subject should be set on outgoing messages if the address specifies a suject,rajith,rajith,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,JMS AMQP 0-x,Python Client,,,,,"If the address specifies a subject, then the out going message should set the ""qpid.subject"" property as an application property in the message properties."
Bug,QPID-1151,12399084,All qpid C++ libraries link against everything from AC_CHECK_LIB,aconway,farrellee,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"libqpidclient.so and libqpidcommon.so have dependencies on -lxqilla, -lxerces-c, -lsasl2 and -lcpg when they should not.

This is because AC_CHECK_LIB adds libraries it finds to LIBS, which is then used on all link lines. A solution is to not add anything to LIBS and instead conditionally add to the link lines of each individual library.

Attached patch is off r671877"
Bug,QPID-2288,12443624,address option for declaring queues with multiple bindings,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,Support binding option as special property of queues in address syntax in line with changes made to python client (see QPID-2287 of which this is a clone)
Bug,QPID-1494,12409515,Core on perf exit,astitcher,cctrieloff,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Perftest core on exit.

Stack trace indicates issue that needs to be resolved prior to release"
Bug,QPID-4379,12612739, HA does not properly handle expired messages,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Description of problem:
If a message expires in a queue before the HA replicator is able to browse the message, the message will be skipped and not replicated.  This results in the expired message's async completion never being finalized which can stall the original source of the expired message since it will never receive a completion.

Oct 18 10:56:02 itcm24 qpidd[48819]: 2012-10-18 10:56:02 [Broker] debug Browser skipping message from 'QueueXyz'

Version-Release number of selected component (if applicable):
Qpid 0.18

How reproducible:
Frequently

Steps to Reproduce:
1. It's a race condition between a message expiring in the queue and the HA browsing subscription being able to replicate it.
  
Actual results:
The expired message is skipped and its async completion is never finalized.

Expected results:
While it is not truly necessary for the HA replicating subscription to replicate an expired message, the async completion needs to be finished.

Additional info:

see also https://bugzilla.redhat.com/show_bug.cgi?id=868360"
Bug,QPID-3235,12505720,clustered qpidd broker fails ocassionly the cluster_tests.ShortTests.test_route_update,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=675921#c7

When the cluster tests are ran in the loop against the installed rpms, I can
reliably see that cluster_tests.ShortTests.test_route_update test case is
failing from time to time.

"
Bug,QPID-3492,12523355,String values in address are parsed as binary (and sent as vbin16/32 rather than str16),gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. when specifying arguments in x-bindings for a headers exchange, where this can cause problems."
Bug,QPID-1064,12396145,intermittent background thread stack trace when using qpid-config,rhs,rhs,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"Exception in thread Thread-3 (most likely raised during interpreter shutdown):
Traceback (most recent call last):
  File ""/usr/lib/python2.5/threading.py"", line 460, in __bootstrap
  File ""/usr/lib/python2.5/threading.py"", line 440, in run
  File ""/home/kpvdr/qpid/python/qpid/queue.py"", line 79, in run
  File ""/home/kpvdr/qpid/python/qpid/management.py"", line 143, in replyCb
  File ""/home/kpvdr/qpid/python/qpid/management.py"", line 331, in replyCb
  File ""/home/kpvdr/qpid/python/qpid/management.py"", line 154, in accept
  File ""/home/kpvdr/qpid/python/qpid/invoker.py"", line 25, in <lambda>
  File ""/home/kpvdr/qpid/python/qpid/session.py"", line 156, in invoke
  File ""/home/kpvdr/qpid/python/qpid/session.py"", line 164, in do_invoke
  File ""/home/kpvdr/qpid/python/qpid/invoker.py"", line 42, in __getattr__
  File ""/home/kpvdr/qpid/python/qpid/invoker.py"", line 35, in ERROR
<type 'exceptions.TypeError'>: 'NoneType' object is not callable
Unhandled exception in thread started by 
Error in sys.excepthook:

Original exception was:"
Bug,QPID-3102,12500187,messaging API produces messages with ttl=0 by default,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"whereas the c++ broker ignores this, the java broker treats it (not unreasonably) as expiring immediately"
Bug,QPID-1556,12411708,Broken link in qpid/cpp/RELEASE_NOTES,rhs,jpo,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"qpid subversion release: 731639

The current cpp RELEASE_NOTES file mentions the link  http://qpid.apache.org/docs/api/c++/html/index.html  as the source of the C++ client API documentation.  This link is broken.  The correct one appears to be  http://qpid.apache.org/docs/api/html/ .

"
Bug,QPID-4011,12556466,TestIsLocalHost unit_test fails with if machine name resolves to loopback address,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,C++ Clustering,,,,,The new SystemInfo::isLocalHost() code doesn't check correctly for interface addresses that resolve to the loopback address.
Bug,QPID-4477,12617802,Need to handle case where outcome is issued by peer before init has been sent,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,This is needed when connecting to a messenger listening on a socket as it assumes ANONYMOUS and issues positive outcome automatically.
Bug,QPID-3101,12500177,qpid-tool does not allow maps to be passed as arguments,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,Which would be useful e.g. when using the new Broker::create() method
Bug,QPID-2475,12460715,qpid/messaging/Session.h r928855 breaks Windows build - macro conflict,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"this change broke on Windows:

Index: C:/qpid/trunk/qpid/cpp/include/qpid/messaging/Session.h
===================================================================
--- C:/qpid/trunk/qpid/cpp/include/qpid/messaging/Session.h	(revision 928854)
+++ C:/qpid/trunk/qpid/cpp/include/qpid/messaging/Session.h	(revision 928855)
@@ -102,7 +102,7 @@
      * which case the passed in receiver reference will be set to the
      * receiver for that message or false if no message was available.
      */
-    QPID_CLIENT_EXTERN bool nextReceiver(Receiver&, Duration timeout=INFINITE_DURATION);
+    QPID_CLIENT_EXTERN bool nextReceiver(Receiver&, Duration timeout=Duration::INFINITE);
     /**
      * Returns the receiver for the next available message. If there
      * are no available messages at present the call will block for up
@@ -111,7 +111,7 @@
      *@exception Receiver::NoMessageAvailable if no message became available in
      * time.
      */
-    QPID_CLIENT_EXTERN Receiver nextReceiver(Duration timeout=INFINITE_DURATION);
+    QPID_CLIENT_EXTERN Receiver nextReceiver(Duration timeout=Duration::INFINITE);
     
     /**
      * Create a new sender through which messages can be sent to the

These errors occur during compile:

C:\qpid\trunk\qpid\cpp\include\qpid/messaging/Session.h(105) : error C2589: 'constant' : illegal token on right side of '::'
C:\qpid\trunk\qpid\cpp\include\qpid/messaging/Session.h(114) : error C2589: 'constant' : illegal token on right side of '::'

Because of this definition in the Windows SDK:

#define INFINITE            0xFFFFFFFF  // Infinite timeout


Can Duration::INFINITE, although a very good name, change to something like BOUNDLESS?"
Bug,QPID-1458,12408375,C++ common compile error in VC9 Release mode,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"When building C++ common library in Release mode, the following compile errors appear:

1>C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\xutility(419) : error C2664: 'qpid::InlineAllocator<BaseAllocator,Max>::InlineAllocator(const qpid::InlineAllocator<BaseAllocator,Max> &)' : cannot convert parameter 1 from 'qpid::InlineAllocator<BaseAllocator,Max>' to 'const qpid::InlineAllocator<BaseAllocator,Max> &'
1>        with
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        Reason: cannot convert from 'qpid::InlineAllocator<BaseAllocator,Max>' to 'const qpid::InlineAllocator<BaseAllocator,Max>'
1>        with
1>        [
1>            BaseAllocator=std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,
1>            Max=3
1>        ]
1>        and
1>        [
1>            BaseAllocator=std::allocator<std::_Aux_cont>,
1>            Max=3
1>        ]
1>        No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\xutility(417) : while compiling class template member function 'std::_Container_base_aux_alloc_real<_Alloc>::_Container_base_aux_alloc_real(_Alloc)'
1>        with
1>        [
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\vector(421) : see reference to class template instantiation 'std::_Container_base_aux_alloc_real<_Alloc>' being compiled
1>        with
1>        [
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\include\vector(439) : see reference to class template instantiation 'std::_Vector_val<_Ty,_Alloc>' being compiled
1>        with
1>        [
1>            _Ty=qpid::Range<qpid::framing::SequenceNumber>,
1>            _Alloc=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        .\qpid/InlineVector.h(42) : see reference to class template instantiation 'std::vector<_Ty,_Ax>' being compiled
1>        with
1>        [
1>            _Ty=qpid::Range<qpid::framing::SequenceNumber>,
1>            _Ax=qpid::InlineAllocator<std::allocator<qpid::Range<qpid::framing::SequenceNumber>>,3>
1>        ]
1>        .\qpid/RangeSet.h(168) : see reference to class template instantiation 'qpid::InlineVector<T,Max>' being compiled
1>        with
1>        [
1>            T=qpid::Range<qpid::framing::SequenceNumber>,
1>            Max=3
1>        ]
1>        c:\ace\exported\qpid\trunk\qpid\cpp\src\qpid\framing\SequenceSet.h(31) : see reference to class template instantiation 'qpid::RangeSet<T>' being compiled
1>        with
1>        [
1>            T=qpid::framing::SequenceNumber
1>        ]

This problem does not occur with VC8, nor with VC9 in Debug mode."
Bug,QPID-349,12362122,Use the empty string as the default for virtual host name.,gsim,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Current default is ""/"" - empty string seems a m ore intuitive and interoperable default."
Bug,QPID-3217,12504701,Exchanges with IVE option cause cluster inconsistencies in updatees,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Steps to Reproduce:
1. start a cluster node

2. create an exchange with the IVE option 
  qpid-config add exchange topic my-topic-exchange --ive

3. send a message to that exchange

  spout --content abc my-topic-exchange/my-key

4. start another node in the cluster
5. create a queue and bind it to the exchange created in 2. using the key with
which the message was sent in 3.

  qpid-config add queue my-queue
  qpid-config bind my-topic-exchange my-queue my-key

(queue is now inconsistent; on the first node it has a message, on the second
it has none)

6. run ./src/tests/qpid-receive --capacity 1 --address 'my-queue; {mode:
browse}' against the first node

Actual results:

second node shutsdown with something like:

2011-04-14 14:33:04 error Execution exception: invalid-argument:
anonymous.35276a61-4f3a-46a9-a070-e88c6c6ac01f: confirmed < (2+0) but only sent
< (1+0) (../../src/qpid/SessionState.cpp:154)
2011-04-14 14:33:04 critical cluster(192.168.0.3:9532 READY/error) local error
832 did not occur on member 192.168.0.3:9482: invalid-argument:
anonymous.35276a61-4f3a-46a9-a070-e88c6c6ac01f: confirmed < (2+0) but only sent
< (1+0) (../../src/qpid/SessionState.cpp:154)


Expected results:

no shutdown and the command in 6 can be repeated against wither node with the
same results

Additional info:

Root of the problem is that exchange with IVE holds extra state in the form of
the 'last message', and this is not transferred to new members."
Bug,QPID-241,12359734,C++ client cannot connect to Java broker.,kpvdr,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Date: Wed, 3 Jan 2007 18:20:31 +0000
From: ""Robert Greig"" <robert.j.greig@gmail.com>

A problem actually arose today when I gave the guys a new build with
the latest (trunk) of C++. When they try to connect ot a java broker -
either trunk or one from November they get:

pool-2-thread-1 2007-01-03 18:13:27,783 ERROR
[qpid.server.protocol.AMQProtocolSession] Received incorrect protocol
init
iation
org.apache.qpid.framing.AMQProtocolVersionException: Protocol version
0.0 not found in protocol version list.
        at org.apache.qpid.framing.ProtocolInitiation.checkVersion(ProtocolInitiation.java:175)
        at org.apache.qpid.server.protocol.AMQMinaProtocolSession.dataBlockReceived(AMQMinaProtocolSession.java:162)
        at org.apache.qpid.server.protocol.AMQPFastProtocolHandler.messageReceived(AMQPFastProtocolHandler.java:203)
        at org.apache.mina.common.support.AbstractIoFilterChain$2.messageReceived(AbstractIoFilterChain.java:189)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:502)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1000(AbstractIoFilterChain.java:52)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:7
77)
        at org.apache.qpid.pool.Event.process(Event.java:80)
        at org.apache.qpid.pool.PoolingFilter.fireEvent(PoolingFilter.java:71)
        at org.apache.qpid.pool.PoolingFilter.messageReceived(PoolingFilter.java:143)
        at org.apache.mina.filter.ReferenceCountingIoFilter.messageReceived(ReferenceCountingIoFilter.java:96)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:502)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1000(AbstractIoFilterChain.java:52)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:7
77)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:60)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:185)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:502)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1000(AbstractIoFilterChain.java:52)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:7
77)
        at org.apache.qpid.pool.Event.process(Event.java:80)
        at org.apache.qpid.pool.Job.processAll(Job.java:81)
        at org.apache.qpid.pool.Job.run(Job.java:103)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
        at java.lang.Thread.run(Thread.java:619)

Any ideas about that? In the meantime I'm going to try building an
older C++ client.

RG
"
Bug,QPID-3839,12542545,messages fetched through browsing receivers are never accepted,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"As the broker expects accepts (since in 0-10 that marks the point where the client will not ask to acquire it), the list of delivery records continues to grow."
Bug,QPID-3510,12524960,Holes in C++ client configuration,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Configuration of the C++ (and wrapped) clients suffers from the following limitations:

1) Logging cannot be configured from the client configuration file.  The log module is only configurable via environment variables.

2) Client configuration cannot be loaded from an alternative configuration file.  The configuration file defined in the build is the only file that can be loaded for any application using the C++ client libraries."
Bug,QPID-3478,12522290,Windows Visual Studio 2010 warning C4251 'needs to have dll interface' qpid::amqp_0_10::MapCodec::contentType,chug,chug,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"File cpp/include/qpid/amqp_0_10/Codecs.h has code to the effect of:

class QPID_COMMON_EXTERN MapCodec
{
  public:
    static const std::string contentType;
  private:
};

VS2010 warns that exporting a std::string from a DLL may have unexpected consequences.

One possible solution is from

http://www.eggheadcafe.com/software/aspnet/30952961/a-solution-to-warning-c4251--class-needs-to-have-dllinterface.aspx

2. You can define a wrapper class that has no inline functions and defines all the potentially compiler-generated functions (default ctor, copy ctor, dtor, and assignment operator) and dllexport that.

Other discussion of this issue:

http://stackoverflow.com/questions/2132747/warning-c4251-when-building-a-dll-that-exports-a-class-containing-an-atlcstring
"
Bug,QPID-3221,12504793,Fix bug in Cluster::timerDrop - calling wrong function,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Fix obvious bug in Cluster::timerDrop, it calls the wrong function.

On one occassion this has been seen to cause a cluster broker to go into an infinite loop sending itself timer-drop messages.
There's no know way to reproduce but by inspection of the code the problem and the fix are obvious and trivial."
Bug,QPID-3919,12548363,qpid-printevents can't connect to broker,mgoulish2,mgoulish2,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"When qpid-printevents tries to connect to vanilla broker, default port, we get this:

EXCEPTION in Broker._v1Cb: cannot concatenate 'str' and 'instance' objects
Traceback (most recent call last):
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 2789, in _v1Dispatch
    self._v1DispatchProtected(msg)
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 2844, in _v1DispatchProtected
    agent._handleQmfV1Message(opcode, seq, mp, ah, codec)
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 3648, in _handleQmfV1Message
    elif opcode == 'e': self._v1HandleEventInd(codec, seq)
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 3380, in _v1HandleEventInd
    self.unsolicitedContext.doEvent(event)
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 3770, in doEvent
    self.notifiable(qmf_event=data)
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 3107, in __call__
    self.session.console.event(self.broker, event)
  File ""/home/mick/trunk/qpid/tools/src/py/qpid-printevents"", line 33, in event
    print event
  File ""/home/mick/trunk/qpid/extras/qmf/src/py/qmf/console.py"", line 3951, in __repr__
    out += "" broker="" + self.broker.getUrl()
TypeError: cannot concatenate 'str' and 'instance' objects
"
Bug,QPID-2956,12480588,"cluster broker exits with ""error deliveryRecord no update message.""",aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=655141

Description of problem:

A broker joining a cluster has ""error deliveryRecord no update message"" which
leads to shutdown.

Version-Release number of selected component (if applicable):1036871

How reproducible: easy

Steps to Reproduce:

Apply attached patch to cluster_tests.py and do:
  make check TESTS=run_cluster_tests CLUSTER_TESTS=""*dr_no_message""

Actual results: broker exits with error

Expected results: no error

Additional info:"
Bug,QPID-4855,12647985,[AMQP 1.0] compilation error on older compilers,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"E.g. Description of problem:
[ 41%] Building CXX object src/CMakeFiles/amqpc.dir/qpid/messaging/amqp/ConnectionHandle.o
cd /builddir/build/BUILD/qpid-0.22/cpp/src && /usr/bin/c++   -Damqpc_EXPORTS -DHAVE_CONFIG_H -fvisibility-inlines-hidden -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -O2 -g -fPIC -I/builddir/build/BUILD/qpid-0.22/cpp/src -I/builddir/build/BUILD/qpid-0.22/cpp/src/../include   -pthread  -I/usr/usr/include -o CMakeFiles/amqpc.dir/qpid/messaging/amqp/ConnectionHandle.o -c /builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/ConnectionHandle.cpp
cc1plus: warnings being treated as errors
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory: In destructor 'std::auto_ptr<_Tp>::~auto_ptr() [with _Tp = qpid::Sasl]':
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/Sasl.h:42:   instantiated from 'std::auto_ptr<_Tp>::~auto_ptr() [with _Tp = qpid::messaging::amqp::Sasl]'
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:58:   instantiated from here
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: warning: possible problem detected in invocation of delete operator:
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: warning: invalid use of undefined type 'struct qpid::Sasl'
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/Sasl.h:29: warning: forward declaration of 'struct qpid::Sasl'
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined.
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory: In destructor 'std::auto_ptr<_Tp>::~auto_ptr() [with _Tp = qpid::sys::SecurityLayer]':
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/Sasl.h:42:   instantiated from 'std::auto_ptr<_Tp>::~auto_ptr() [with _Tp = qpid::messaging::amqp::Sasl]'
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/ConnectionContext.cpp:58:   instantiated from here
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: warning: possible problem detected in invocation of delete operator:
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: warning: invalid use of undefined type 'struct qpid::sys::SecurityLayer'
/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/messaging/amqp/Sasl.h:31: warning: forward declaration of 'struct qpid::sys::SecurityLayer'
/usr/lib/gcc/x86_64-redhat-linux/4.1.2/../../../../include/c++/4.1.2/memory:259: note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined.
make[2]: *** [src/CMakeFiles/amqpc.dir/qpid/messaging/amqp/ConnectionContext.o] Error 1
make[2]: *** Waiting for unfinished jobs...."
Bug,QPID-1957,12428997,FrameDecoder's append() function accesses out-of-range if appending 0 bytes,shuston,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"The append() function in qpid/framing/FrameDecoder.cpp tries to take the address of out-of-range bytes if appending 0 bytes. Although no bytes will actually be written, the [] operator throws an out of range exception in Visual Studio, which is correct since the address of an element that doesn't exist is being requested.

This fixes it:

Index: src/qpid/framing/FrameDecoder.cpp
===================================================================
--- src/qpid/framing/FrameDecoder.cpp   (revision 788779)
+++ src/qpid/framing/FrameDecoder.cpp   (working copy)
@@ -32,7 +32,8 @@
 /** Append up to n bytes from start of buf to end of bytes. */
 void append(std::vector<char>& bytes, Buffer& buffer, size_t n) {
     size_t oldSize = bytes.size();
-    n = std::min(n, size_t(buffer.available()));
+    if ((n = std::min(n, size_t(buffer.available()))) == 0)
+        return;
     bytes.resize(oldSize+n);
     char* p = &bytes[oldSize];
     buffer.getRawData(reinterpret_cast<uint8_t*>(p), n);
"
Bug,QPID-2384,12455072,Cluster recovers duplicate messages when using async store and --no-data-dir and --store-dir together,kpvdr,kpvdr,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"(copied from https://bugzilla.redhat.com/show_bug.cgi?id=560102)

When using a persistent store in cluster mode, if you say --no-data-dir, the wrong thing happens at init time, and the broker comes up in a confused state.

Version-Release number of selected component (if applicable): trunk

How reproducible: Always

Steps to Reproduce:
1.  Start two brokers with a stores, specify --store-dir, and --no-data-dir
2.  Create some objects
3.  Bounce and restart a broker

Actual results: Broker recovers objects from the store, when it shouldn't

Expected results: Should get statea from the peer."
Bug,QPID-4126,12598246,HA primary times out expected backups.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"After a failure, the newly-promoted primary broker guards messages for each of the backups that were connected at the time of the failure. It waits for them to reconnect to the new primary before becoming active.

This patch introduces a time-out so that if an expected backup fails to fail-over within the time limit, the primary will cancel the guards for that backup and carry on."
Bug,QPID-2058,12433403,"SessionImpl::send can't send ""fresh"" frames",gsim,cliffjansen,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"In 0.5, this method could be used to send a message, consisting of a
command and separate frame set (consisting of AMQHeaderBody and
AMQContentBody frames), or a complete frame set (with the initial
command in the frame set discarded):

  Future SessionImpl::send(const AMQBody& command, const FrameSet& content)

In 0.6, the frame set is re-routed to a MethodContentAdaptor which
either hits an exception (for a frame set without initial command),
or, for a ""complete"" frame set, converts the frames into a single
string to reconvert back to individual frames (presumably to adjust
for different frame sizes between connections).

Perhaps there is some other characteristic of the cluster related
frames (other than isCompleted()) that distinguishes them from a
""fresh"" set (e.g. hasExchange())?

Or possibly a separate command can be used for the cluster case whose
intension is to specifically NOT send the frame set provided as the
""content"" parameter.

If neither of those suggestions lead anywhere, the upcoming patch
works for the case of a frame set that lacks a command (method) as its
first frame, and ""works for me"", but I don't have a cluster setup to
check for unwanted consequences.

"
Bug,QPID-1879,12426552,The client library uses a new thread for every connection,astitcher,astitcher,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"This is actually slightly worse than just using a new thread per broker connection as it also uses a new Poller for every Connection and the Poller is fairly hefty and includes a number of fds for its own use. This multiplies the client fd use for clients with many Connections.

It's not really acceptable that opening 1000 connections should create 1000 threads.

It should be noted that this isn't the only aspect of the client library that uses excessive numbers of threads, lets knock them off one by one"
Bug,QPID-2427,12457854,Modify browse option in-line with path chosen for python client,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"Change c++ client from boolean value named 'browse' to 'mode' which can be
'browse' or 'consume'."
Bug,QPID-3199,12503979,Severe but difficult to diagnose lock error in qpid::sys::StateMonitor,astitcher,astitcher,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,"The qpid::sys::StateMonitor class has 4 member functions liker this:
  void waitFor(Enum s) { ScopedWait(*this); while (s != state) wait(); }

However the ScopeWait(*this); is in error, because it creates a temporary ScopedWait and then immediately destroys it. Instead of locking this and then unlocking it at the end of the function execution.

What was meant was:
  void waitFor(Enum s) { ScopedWait w(*this); while (s != state) wait(); }

which creates a local variable w which is destroyed at the end of the function execution unlocking this.

It is possible that the compiler/options we use do not actually exhibit this bug. As the correct behaviour may not actually be implemented by all compilers.

If this bug exhibits it might show as StateMonitor::waitFor() never detecting the desired state for instance. It is remarkable that this code has been in the codebase for 3.5 years and we've not noticed any bug caused by it.

This bug was detected by the work on QPID-3004: The clang++ compiler detected that the value being returned by the constructor was not being used at all."
Bug,QPID-1705,12415926,Enabling heartbeats causes segfault on failover,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"If a client with heartbeats enabled fails over, the heartbeat task on the old ConnectionImpl object can fire and attempt to invoke on the now dangling pointer."
Bug,QPID-4293,12606899,HA broker crashes on startup,aconway,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Clustering,,,,,,,"From Nitin Shah:

I tried to start the version 18 of the C++ broker and get the following error in /var/log/messages and the broker dies. Any idea what we are doing wrong. We have been using the version 16 and that starts fine.

10:29:35 nshah_1 qpidd[1550]: 2012-09-05 10:29:35 [Broker] notice SASL disabled: No Authentication Performed
Sep  5 10:29:35 nshah_1 qpidd[1550]: 2012-09-05 10:29:35 [Network] notice Listening on TCP/TCP6 port 5672
Sep  5 10:29:35 nshah_1 qpidd[1549]: 2012-09-05 10:29:35 [Broker] critical Unexpected error: Cannot read from child process.

I started doing some investigation on the new release mainly because I could not see what we were ( if possible) doing wrong with the release. The broker would start executing and immediately one was getting an assert as shown below in the output I generated with running it under GDB. It asserts because it fails the test in file types.cpp in qpid/ha line 38 ( assert(value < count). I noticed that this is happening as a result of the call from the HaBroker::initialize() function line 90 in the HaBroker.cpp file where a QPID_LOG is being invoked.

I believe the root of the problem is the BrokerInfo class constructor is not initializing the private class data called ""BrokerStatus status"" which is defined in file BrokerInfo.h . BrokerStatus is defined in types.h as an enum as follows

enum BrokerStatus {
    JOINING,                    ///< New broker, looking for primary
    CATCHUP,                    ///< Backup: Connected to primary, catching up on state.
    READY,                      ///< Backup: Caught up, ready to take over.
    RECOVERING,                 ///< Primary: waiting for backups to connect & sync
    ACTIVE,                     ///< Primary: actively serving clients.
    STANDALONE                  ///< Not part of a cluster.
};

It seems like the assert happens on the second call to EnumBase::str() in types.cpp. The count was 6 and the value was some large uninitialized value.

I initialized the status variable in the constructor to STANDALONE and the broker came up and worked fine."
Bug,QPID-2734,12469306,testAuthenticatedUsername fails on cmake builds,gsim,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"This test failure in unit_test has been failing since July 1, 2010, approx svn r959461.

./../../qpid/cpp/src/tests/MessagingSessionTests.cpp(775): error in ""testAuthenticatedUsername"": check fix.connection.getAuthenticatedUsername() == std::string(""anonymous"") failed [ != anonymous]

Based on email exchanges on dev@qpid, this test succeeds on Linux using the autoconf build."
Bug,QPID-2388,12455236,user-defined signals can cause process terminate,astitcher,azimf,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"I have an application which uses some user-defined signals for process control. When trying to bind qpid in to this application I've found that the client library spawns an i/o thread which ignores signal masks that the process has defined before making any calls to qpid. The i/o thread changes it's own signal mask to sigemptyset and is catching signals intended for another thread in my process which has called sigtimedwait(). The default action for user defined signals is process terminate, so the process is subsequently dying.

I've made the following change to EpollPoller.cpp to work around the problem within my environment:

$ diff -w EpollPoller.cpp EpollPoller-fixed.cpp
248c248
<         ::sigemptyset(&sigMask);
---
>         ::sigfillset(&sigMask);"
Bug,QPID-1333,12406048,Compile failure in C++ tests/ClientSessionTest.cpp at rev 702675,shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"At svn rev 702675 the C++ test qpid/cpp/src/tests/ClientSessionTest.cpp failed compile with:

ClientSessionTest.cpp:165: error: expected constructor, destructor, or type conversion before '(' token
ClientSessionTest.cpp:186: error: expected constructor, destructor, or type conversion before '(' token

The noted lines both contain QPID_AUTO_TEST_CASE_EXPECTED_FAILURES

I thought this may have been a mis-coded BOOST macro in unit_test.h, and changed:

@@ -76,7 +76,7 @@
 #endif

 #ifndef QPID_AUTO_TEST_CASE_EXPECTED_FAILURES
-# define QPID_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)  BOOST_AUTO_TEST_SUITE_EXPECTED_FAILURES(name,n)
+# define QPID_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)  BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)
 #endif

but that moved the error down a line to:

ClientSessionTest.cpp:166: error: expected unqualified-id before '{' token
ClientSessionTest.cpp:187: error: expected unqualified-id before '{' token

So I extended the work-around section for QPID_AUTO_TEST_CASE_EXPECTED_FAILURES to :

--- unit_test.h (revision 702976)
+++ unit_test.h (working copy)
@@ -53,7 +53,7 @@

 // Workaround for BOOST_AUTO_TEST_SUITE_EXPECTED_FAILURES
 //
-#if (BOOST_VERSION < 103500)
+#if (BOOST_VERSION < 103600)

That got things compiling, but I'm not sure this is correct...
The diff I have here now (all together) is:

Index: unit_test.h
===================================================================
--- unit_test.h (revision 702976)
+++ unit_test.h (working copy)
@@ -53,7 +53,7 @@

 // Workaround for BOOST_AUTO_TEST_SUITE_EXPECTED_FAILURES
 //
-#if (BOOST_VERSION < 103500)
+#if (BOOST_VERSION < 103600)

 // Keep the test function for compilation but do not not register it.
 // TODO aconway 2008-04-23: better workaround for expected failures.
@@ -76,7 +76,7 @@
 #endif

 #ifndef QPID_AUTO_TEST_CASE_EXPECTED_FAILURES
-# define QPID_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)  BOOST_AUTO_TEST_SUITE_EXPECTED_FAILURES(name,n)
+# define QPID_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)  BOOST_AUTO_TEST_CASE_EXPECTED_FAILURES(name,n)
 #endif

 #ifndef QPID_AUTO_TEST_SUITE_END
"
Bug,QPID-2392,12455496,Powershell scripts not included in release source kits,shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,The release process for 0.6 didn't contain the Powershell scripts for the C++ broker/client test suite on Windows.
Bug,QPID-4290,12606581,ReplicatingSubscription counts as a consumer and doesn't allow auto-delete queues to be deleted,aconway,ncdc,Closed,Fixed,2013-07-29 18:52,C++,C++ Clustering,,,,,,,"If you create an auto-delete queue, the ReplicatingSubscription that backs it up is included in the Queue's consumerCount, so auto-deletion never occurs because consumerCount is always > 0.  ReplicatingSubscriptions should not be counted as consumers so auto deletion can succeed."
Bug,QPID-3487,12523131,Client should send completions when closing a receiver,gsim,ncdc,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"When closing a receiver for a queue that is either delete:always or auto-delete:true, it is possible for the queue to remain visible in management (qmf) even though the client has already acknowledged, released, or rejected all messages.

Steps to reproduce:

1) Create receiver e.g. my-queue; {create:always, delete:always, node: {x-declare: {auto-delete: true}}}
2) Set capacity to something e.g. 10
3) Send messages to my-queue
4) Call get() on the receiver for each message
5) Ack/release/reject each message
6) Close the receiver
7) IMPORTANT: keep the session alive

Expected results: ""qpid-stat -q"" will not show my-queue in the list

Actual results: ""qpid-stat -q"" shows my-queue in the list

This happens because the broker has instances of DeliveryRecord in memory for each message that the receiver acquired, and each DeliveryRecord has a shared_ptr to the Queue.  Because the receiver does not necessarily send completions for all the message.transfer commands, DeliveryRecords will still be around, which means the Queue will still be visible via management."
Bug,QPID-4191,12601407,HA removing self address breaks if a VIP is used.,aconway,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Clustering,,,,,,,"The HA broker was removing its own address from the set of cluster addresses to avoid useless self-connection attempts. However this completely breaks if a Virtual IP address (VIP) is used. 

The remove-self is not essential, self-connection attempts are prevented elsewhere. Backup brokers will be prevented from connecting to self by the same connection-observer as normal clients.  "
Bug,QPID-4136,12598713,HA sporadic failures in ha_tests,aconway,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Clustering,,,,,,,"ha_tests.py fails sporadically. 2 different types of failure have been observed:

---- failure 1
ha_tests.RecoveryTests.test_queue_hold ............................................ fail
Error during test:  Traceback (most recent call last):
    File ""/home/aconway/qpid/dbg/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/home/aconway/qpid/qpid/cpp/src/tests/ha_tests.py"", line 901, in test_queue_hold
      cluster[1].assert_browse_backup(""q1"", [str(i) for i in range(100)+range(100,200)])
    File ""/home/aconway/qpid/qpid/cpp/src/tests/ha_tests.py"", line 158, in assert_browse_backup
      assert_browse_retry(bs, queue, expected, **kwargs)
    File ""/home/aconway/qpid/qpid/cpp/src/tests/brokertest.py"", line 466, in assert_browse_retry
      assert expect_contents == actual_contents, msg
  AssertionError: browse failed: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '100', '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', '111', '112', '113', '114', '115', '116', '117', '118', '119', '120', '121', '122', '123', '124', '125', '126', '127', '128', '129', '130', '131', '132', '133', '134', '135', '136', '137', '138', '139', '140', '141', '142', '143', '144', '145', '146', '147', '148', '149', '150', '151', '152', '153', '154', '155', '156', '157', '158', '159', '160', '161', '162', '163', '164', '165', '166', '167', '168', '169', '170', '171', '172', '173', '174', '175', '176', '177', '178', '179', '180', '181', '182', '183', '184', '185', '186', '187', '188', '189', '190', '191', '192', '193', '194', '195', '196', '197', '198', '199'] != []

----- failure 2

ha_tests.RecoveryTests.test_queue_hold .................................. fail
Error during test:  Traceback (most recent call last):
    File ""/var/lib/jenkins/workspace/Qpid-cpp/qpid/cpp/src/tests/python/commands/qpid-python-test"", line 340, in run
      phase()
    File ""/var/lib/jenkins/workspace/Qpid-cpp/qpid/cpp/src/tests/ha_tests.py"", line 891, in test_queue_hold
      assertSyncTimeout(s1)
    File ""/var/lib/jenkins/workspace/Qpid-cpp/qpid/cpp/src/tests/ha_tests.py"", line 875, in assertSyncTimeout
      self.fail(""Expected Timeout exception"")
    File ""/usr/lib64/python2.6/unittest.py"", line 316, in fail
      raise self.failureException, msg
  AssertionError: Expected Timeout exception

 "
Bug,QPID-1998,12431068,Possible 0-pointer crash in SystemInfo::getProcessName(),shuston,shuston,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"As reported on users@qpid.apache.org by Alan Conway:

Nithesh Shetty wrote:
[snip]
>  
> Now the problem  is it give exception if u check the call stack then 
> it show ptr = 0x00000000 line 664
> qpid::sys::SystemInfo::getProcessName() 
> qpid::client::ConnectionHandler::ConnectionHandle()
> qpid::client::ConnectionImpl::ConnectionImp()
> qpid::client:Connection::open() ( open connection is from read thread)
>  
> tested the above code on windows
>  

There's a bug in the windows code for getProcessName which might be the cause of 
your woes.

std::string SystemInfo::getProcessName()
{
     // Only want info for the current process, so ask for something specific.
     // The module info won't be used here but it keeps the snapshot limited to
     // the current process so a search through all processes is not needed.
     HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0);
     if (snap == INVALID_HANDLE_VALUE)
         return 0;
         ^^^^^^^^

This return statment is constructing a string from a 0 pointer which is going to 
lead to a null pointer crash. I don't know if its likely to be the cause of your 
crash since I don't know under what circumstances you'd get the 
INVALID_HANDLE_VALUE.
"
Bug,QPID-561,12377259,c++ broker using incorrect value for xa-ok.,,aconway,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,JMS AMQP 0-x,,,,,"The qpidd broker uses the constant XA_OK=8, but the 0-10 XML defines xa-ok=0. The value 8 looks like a 0-9 throwback.
It appears that python uses the incorrect value also, since changing it to - broke the python xa tests with the broker.

constants.h now provides generated C++ constants for all AMQP constants define in XML, we should replace all hand-written constants with constants based on the generated ones."
Bug,QPID-2908,12477505,Creating a ring queue with c++ address strings does not work.,jonathan.robie,aconway,Closed,Fixed,2013-07-29 18:35,C++,C++ Client,,,,,,,"Using qpid-send I try to create a ring queue of size 3. I send 5 messages to it, expecting that 2 will be over-written due to the ring queue policy. However qpid-receive shows that all 5 messages were stored on the queue:

[aconway@rolf qpid]$ qpid-send -a ""rq ; { create: always, node: { type:queue, x-declare: { arguments: { 'qpid.max_size': 3, 'qpid.policy_type': ring }} }}"" --content-stdin
a
b
c
d
e
[aconway@rolf qpid]$ qpid-receive -a ""rq""
a
b
c
d
e

Using qpid-tool I get the following for the queue:
   arguments              {u'qpid.max_size': '3', u'qpid.policy_type': 'ring'}

Note single quotes around '3' - it appears to be treated as string rather than integer. On a ring queue created from a python client these quotes don't appear.
"
Bug,QPID-2874,12474607,Clustered broker crashes in assertion in cluster/ExpiryPolicy.cpp,aconway,aconway,Closed,Fixed,2013-07-29 18:34,C++,C++ Clustering,,,,,,,"From users@qpid.apache.org:

        We have a Java node connecting to one of two Qpid brokers (0.5 or 0.6,
        doesn't matter, we get the same) as a client of another Java node which acts
        as the server. The client sends messages over a queue, awaiting a response
        message from the server on a temporary queue. Both brokers use clustering
        (and are part of the same cluster). At some point, after 1 to 3 exchanges
        between the client and server nodes, both Qpid brokers simply crash, without
        any error being logged. Broker logfile is attached. The typical output that
        appears in the broker log files - the last line in the log is always the
        same, so it seems that the place at which the failure occurs is consistent.

Original message with logs and config: http://apache-qpid-users.2158936.n2.nabble.com/Qpid-clustering-broker-crash-tt5511801.html#a5511801

Stack trace:

[root@ca-mtl1-tric-01 .qpidd]# gdb /opt/qpid/current/sbin/qpidd core.6709
GNU gdb (GDB) Red Hat Enterprise Linux (7.0.1-23.el5_5.2)
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
and ""show warranty"" for details.
This GDB was configured as ""i386-redhat-linux-gnu"".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /opt/qpid/qpid-0.5/sbin/qpidd...done.
[New Thread 6732]
[New Thread 6727]
[New Thread 6721]
[New Thread 6710]
[New Thread 6709]

warning: .dynamic section for ""/usr/lib/libplc4.so"" is not at the expected address

warning: difference appears to be caused by prelink, adjusting expectations

warning: .dynamic section for ""/usr/lib/libplds4.so"" is not at the expected address

warning: difference appears to be caused by prelink, adjusting expectations

warning: .dynamic section for ""/usr/lib/openais/libcpg.so.2"" is not at the expected address

warning: difference appears to be caused by prelink, adjusting expectations
Reading symbols from /opt/qpid/current/lib/libqpidbroker.so.0...done.
Loaded symbols for /opt/qpid/current/lib/libqpidbroker.so.0
Reading symbols from /opt/qpid/current/lib/libqpidcommon.so.0...done.
Loaded symbols for /opt/qpid/current/lib/libqpidcommon.so.0
Reading symbols from /usr/lib/libboost_program_options.so.2...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libboost_program_options.so.2
Reading symbols from /usr/lib/libboost_filesystem.so.2...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libboost_filesystem.so.2
Reading symbols from /lib/libuuid.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib/libuuid.so.1
Reading symbols from /lib/libdl.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib/libdl.so.2
Reading symbols from /lib/librt.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib/librt.so.1
Reading symbols from /usr/lib/libsasl2.so.2...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libsasl2.so.2
Reading symbols from /usr/lib/libstdc++.so.6...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libstdc++.so.6
Reading symbols from /lib/libm.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib/libm.so.6
Reading symbols from /lib/libgcc_s.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib/libgcc_s.so.1
Reading symbols from /lib/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib/libc.so.6
Reading symbols from /lib/ld-linux.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib/ld-linux.so.2
Reading symbols from /lib/libpthread.so.0...(no debugging symbols found)...done.
Loaded symbols for /lib/libpthread.so.0
Reading symbols from /lib/libresolv.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib/libresolv.so.2
Reading symbols from /lib/libcrypt.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib/libcrypt.so.1
Reading symbols from /opt/qpid/current/lib/qpid/daemon/replicating_listener.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/replicating_listener.so
Reading symbols from /opt/qpid/current/lib/qpid/daemon/replication_exchange.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/replication_exchange.so
Reading symbols from /opt/qpid/current/lib/qpid/daemon/acl.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/acl.so
Reading symbols from /opt/qpid/current/lib/qpid/daemon/ssl.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/ssl.so
Reading symbols from /opt/qpid/current/lib/libsslcommon.so.0...done.
Loaded symbols for /opt/qpid/current/lib/libsslcommon.so.0
Reading symbols from /usr/lib/libnss3.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libnss3.so
Reading symbols from /usr/lib/libssl3.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libssl3.so
Reading symbols from /usr/lib/libnspr4.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libnspr4.so
Reading symbols from /usr/lib/libnssutil3.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libnssutil3.so
Reading symbols from /usr/lib/libplc4.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libplc4.so
Reading symbols from /usr/lib/libplds4.so...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libplds4.so
Reading symbols from /usr/lib/libz.so.1...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libz.so.1
Reading symbols from /opt/qpid/current/lib/qpid/daemon/cluster.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/cluster.so
Reading symbols from /usr/lib/openais/libcpg.so.2...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/openais/libcpg.so.2
Reading symbols from /usr/lib/libcman.so.2...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libcman.so.2
Reading symbols from /opt/qpid/current/lib/libqpidclient.so.0...done.
Loaded symbols for /opt/qpid/current/lib/libqpidclient.so.0
Reading symbols from /opt/qpid/current/lib/qpid/client/rdmaconnector.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/client/rdmaconnector.so
Reading symbols from /opt/qpid/current/lib/librdmawrap.so.0...done.
Loaded symbols for /opt/qpid/current/lib/librdmawrap.so.0
Reading symbols from /usr/lib/librdmacm.so.1...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/librdmacm.so.1
Reading symbols from /usr/lib/libibverbs.so.1...(no debugging symbols found)...done.
Loaded symbols for /usr/lib/libibverbs.so.1
Reading symbols from /opt/qpid/current/lib/qpid/client/sslconnector.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/client/sslconnector.so
Reading symbols from /opt/qpid/current/lib/qpid/daemon/rdma.so...done.
Loaded symbols for /opt/qpid/current/lib/qpid/daemon/rdma.so
Core was generated by `/opt/qpid/current/sbin/qpidd -p 10004 --cluster-name=TEST_CL --no-data-dir --au'.
Program terminated with signal 6, Aborted.
#0  0x007cd402 in __kernel_vsyscall ()
(gdb) thread apply all backtrace

Thread 6 (Thread 6709):
#0  0x007cd402 in __kernel_vsyscall ()
#1  0x00993486 in epoll_wait () from /lib/libc.so.6
#2  0x00475584 in qpid::sys::Poller::wait (this=0x8b70430, timeout=...)
    at qpid/sys/epoll/EpollPoller.cpp:432
#3  0x004763d3 in qpid::sys::Poller::run (this=0x8b70430)
    at qpid/sys/epoll/EpollPoller.cpp:398
#4  0x004c7ef4 in qpid::sys::Dispatcher::run (this=0xbfab0ea0)
    at qpid/sys/Dispatcher.cpp:37
#5  0x001d3f21 in qpid::broker::Broker::run (this=0x8b837b0)
    at qpid/broker/Broker.cpp:319
#6  0x08050155 in QpiddDaemon::child (this=0xbfab116c)
    at posix/QpiddBroker.cpp:128
#7  0x002140db in qpid::broker::Daemon::fork (this=0xbfab116c)
    at qpid/broker/Daemon.cpp:85
#8  0x0804ea7c in QpiddBroker::execute (this=0xbfab13f5, options=0x8b81248)
    at posix/QpiddBroker.cpp:158
#9  0x0804c8e7 in main (argc=14, argv=0xbfab14a4) at qpidd.cpp:77

Thread 5 (Thread 6710):
#0  0x007cd402 in __kernel_vsyscall ()
#1  0x00706ef2 in pthread_cond_timedwait@@GLIBC_2.3.2 ()
---Type <return> to continue, or q <return> to quit---
   from /lib/libpthread.so.0
#2  0x0099f524 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x0029db60 in qpid::broker::Timer::run (this=0xb7fae0b0)
    at ./qpid/sys/posix/Condition.h:69
#4  0x0046ced1 in qpid::sys::(anonymous namespace)::runRunnable (p=0xb7fae0b0)
    at qpid/sys/posix/Thread.cpp:35
#5  0x00702832 in start_thread () from /lib/libpthread.so.0
#6  0x00992e0e in clone () from /lib/libc.so.6

Thread 4 (Thread 6721):
#0  0x007cd402 in __kernel_vsyscall ()
#1  0x00706ef2 in pthread_cond_timedwait@@GLIBC_2.3.2 ()
   from /lib/libpthread.so.0
#2  0x0099f524 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x0029db60 in qpid::broker::Timer::run (this=0x8b839b4)
    at ./qpid/sys/posix/Condition.h:69
#4  0x0046ced1 in qpid::sys::(anonymous namespace)::runRunnable (p=0x8b839b4)
    at qpid/sys/posix/Thread.cpp:35
#5  0x00702832 in start_thread () from /lib/libpthread.so.0
#6  0x00992e0e in clone () from /lib/libc.so.6

Thread 3 (Thread 6727):
#0  0x007cd402 in __kernel_vsyscall ()
---Type <return> to continue, or q <return> to quit---
#1  0x00706ef2 in pthread_cond_timedwait@@GLIBC_2.3.2 ()
   from /lib/libpthread.so.0
#2  0x0099f524 in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/libc.so.6
#3  0x0029db60 in qpid::broker::Timer::run (this=0x8b83a34)
    at ./qpid/sys/posix/Condition.h:69
#4  0x0046ced1 in qpid::sys::(anonymous namespace)::runRunnable (p=0x8b83a34)
    at qpid/sys/posix/Thread.cpp:35
#5  0x00702832 in start_thread () from /lib/libpthread.so.0
#6  0x00992e0e in clone () from /lib/libc.so.6

Thread 2 (Thread 6732):
#0  0x007cd402 in __kernel_vsyscall ()
#1  0x00993486 in epoll_wait () from /lib/libc.so.6
#2  0x00475584 in qpid::sys::Poller::wait (this=0x8b70430, timeout=...)
    at qpid/sys/epoll/EpollPoller.cpp:432
#3  0x004763d3 in qpid::sys::Poller::run (this=0x8b70430)
    at qpid/sys/epoll/EpollPoller.cpp:398
#4  0x004c7ef4 in qpid::sys::Dispatcher::run (this=0xbfab0ea0)
    at qpid/sys/Dispatcher.cpp:37
#5  0x0046ced1 in qpid::sys::(anonymous namespace)::runRunnable (p=0xbfab0ea0)
    at qpid/sys/posix/Thread.cpp:35
#6  0x00702832 in start_thread () from /lib/libpthread.so.0
#7  0x00992e0e in clone () from /lib/libc.so.6
---Type <return> to continue, or q <return> to quit---

Thread 1 (Thread 6731):
#0  0x007cd402 in __kernel_vsyscall ()
#1  0x008e9df0 in raise () from /lib/libc.so.6
#2  0x008eb701 in abort () from /lib/libc.so.6
#3  0x008e326b in __assert_fail () from /lib/libc.so.6
#4  0x00f9cc46 in qpid::cluster::ExpiryPolicy::willExpire (this=0x8b87340,
    m=...) at qpid/cluster/ExpiryPolicy.cpp:47
#5  0x0024c6c4 in qpid::broker::Message::setExpiryPolicy (this=0xb4903128,
    e=...) at qpid/broker/Message.cpp:338
#6  0x0024e8bd in qpid::broker::Message::setTimestamp (this=0xb4903128, e=...)
    at qpid/broker/Message.cpp:331
#7  0x0027a419 in qpid::broker::SemanticState::route (this=0x8b755b0, msg=...,
    strategy=...) at qpid/broker/SemanticState.cpp:358
#8  0x0027b858 in qpid::broker::SemanticState::handle (this=0x8b755b0, msg=...)
    at qpid/broker/SemanticState.cpp:348
#9  0x00292532 in qpid::broker::SessionState::handleContent (this=0x8b75488,
    frame=..., id=...) at qpid/broker/SessionState.cpp:243
#10 0x00292b23 in qpid::broker::SessionState::handleIn (this=0x8b75488,
    frame=...) at qpid/broker/SessionState.cpp:321
#11 0x0029640b in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn)>::ha---Type <return> to continue, or q <return> to quit---
ndle (this=0x8b75588, t=...) at ./qpid/framing/Handler.h:67
#12 0x0049840a in qpid::amqp_0_10::SessionHandler::handleIn (this=0x8b74b78,
    f=...) at qpid/amqp_0_10/SessionHandler.cpp:86
#13 0x0029640b in qpid::framing::Handler<qpid::framing::AMQFrame&>::MemFunRef<qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface, &(qpid::framing::Handler<qpid::framing::AMQFrame&>::InOutHandlerInterface::handleIn)>::handle (this=0x8b74b80, t=...) at ./qpid/framing/Handler.h:67
#14 0x00207fbc in operator() (this=0x8b73be4, frame=...)
    at ./qpid/framing/Handler.h:42
#15 qpid::broker::Connection::received (this=0x8b73be4, frame=...)
    at qpid/broker/Connection.cpp:106
#16 0x00f81462 in qpid::cluster::Connection::deliveredFrame (this=0x8b73b40,
    f=...) at qpid/cluster/Connection.cpp:158
#17 0x00f61b1d in qpid::cluster::Cluster::deliveredFrame (this=0x8b87470,
    e=...) at qpid/cluster/Cluster.cpp:271
#18 0x00f634fd in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:149
#19 operator()<boost::_mfi::mf1<void, qpid::cluster::Cluster, qpid::cluster::EventFrame const&>, boost::_bi::list1<qpid::cluster::EventFrame const&> > (
    function_obj_ptr=..., a0=...) at /usr/include/boost/bind.hpp:287
#20 operator()<qpid::cluster::EventFrame const> (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/bind_template.hpp:32
#21 boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void,---Type <return> to continue, or q <return> to quit---
 boost::_mfi::mf1<void, qpid::cluster::Cluster, qpid::cluster::EventFrame const&>, boost::_bi::list2<boost::_bi::value<qpid::cluster::Cluster*>, boost::arg<1> > >, void, qpid::cluster::EventFrame const&>::invoke (function_obj_ptr=...,
    a0=...) at /usr/include/boost/function/function_template.hpp:136
#22 0x00f6a7c4 in boost::function1<void, qpid::cluster::EventFrame const&, std::allocator<void> >::operator() (this=0x8b87908, a0=...)
    at /usr/include/boost/function/function_template.hpp:576
#23 0x00f6fb79 in qpid::cluster::PollableQueue<qpid::cluster::EventFrame>::handleBatch (this=0x8b87840, values=...) at qpid/cluster/PollableQueue.h:48
#24 0x00f635fd in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:149
#25 operator()<boost::_mfi::mf1<void, qpid::cluster::PollableQueue<qpid::cluster::EventFrame>, std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> >&>, boost::_bi::list1<std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> >&> > (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind.hpp:287
#26 operator()<std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> > > (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/bind_template.hpp:32
#27 boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::cluster::PollableQueue<qpid::cluster::EventFrame>, std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> >&>, boost::_bi::list2<boost::_bi::value<qpid::cluster::PollableQueue<qpid::clu---Type <return> to continue, or q <return> to quit---
ster::EventFrame>*>, boost::arg<1> > >, void, std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> >&>::invoke (
    function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:136
#28 0x00f6ab94 in boost::function1<void, std::deque<qpid::cluster::EventFrame, std::allocator<qpid::cluster::EventFrame> >&, std::allocator<void> >::operator()
    (this=0x8b87888, a0=...)
    at /usr/include/boost/function/function_template.hpp:576
#29 0x00f7327c in qpid::sys::PollableQueue<qpid::cluster::EventFrame>::process
    (this=0x8b87840) at ./qpid/sys/PollableQueue.h:149
#30 0x00f734a2 in qpid::sys::PollableQueue<qpid::cluster::EventFrame>::dispatch
    (this=0x8b87840, cond=...) at ./qpid/sys/PollableQueue.h:136
#31 0x00f6363d in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:149
#32 operator()<boost::_mfi::mf1<void, qpid::sys::PollableQueue<qpid::cluster::EventFrame>, qpid::sys::PollableCondition&>, boost::_bi::list1<qpid::sys::PollableCondition&> > (function_obj_ptr=..., a0=...) at /usr/include/boost/bind.hpp:287
#33 operator()<qpid::sys::PollableCondition> (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/bind_template.hpp:32
#34 boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::PollableQueue<qpid::cluster::EventFrame>, qpid::sys::PollableCondition&>, boost::_bi::list2<boost::_bi::value<qpid::sys::PollableQueue<qpid::cluster::EventFrame>*>, boost::arg<1> > >, void, qpid::sys::Poll---Type <return> to continue, or q <return> to quit---
ableCondition&>::invoke (function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:136
#35 0x00473d67 in boost::function1<void, qpid::sys::PollableCondition&, std::allocator<boost::function_base> >::operator() (this=0x8b88630, a0=...)
    at /usr/include/boost/function/function_template.hpp:576
#36 0x00472c37 in qpid::sys::PollableConditionPrivate::dispatch (
    this=0x8b88628) at qpid/sys/posix/PollableCondition.cpp:89
#37 0x0047308d in operator() (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/mem_fn_template.hpp:149
#38 operator()<boost::_mfi::mf1<void, qpid::sys::PollableConditionPrivate, qpid::sys::DispatchHandle&>, boost::_bi::list1<qpid::sys::DispatchHandle&> > (
    function_obj_ptr=..., a0=...) at /usr/include/boost/bind.hpp:287
#39 operator()<qpid::sys::DispatchHandle> (function_obj_ptr=..., a0=...)
    at /usr/include/boost/bind/bind_template.hpp:32
#40 boost::detail::function::void_function_obj_invoker1<boost::_bi::bind_t<void, boost::_mfi::mf1<void, qpid::sys::PollableConditionPrivate, qpid::sys::DispatchHandle&>, boost::_bi::list2<boost::_bi::value<qpid::sys::PollableConditionPrivate*>, boost::arg<1> > >, void, qpid::sys::DispatchHandle&>::invoke (
    function_obj_ptr=..., a0=...)
    at /usr/include/boost/function/function_template.hpp:136
#41 0x004cb547 in boost::function1<void, qpid::sys::DispatchHandle&, std::allocator<boost::function_base> >::operator() (this=0x8b71010, a0=...)
    at /usr/include/boost/function/function_template.hpp:576
---Type <return> to continue, or q <return> to quit---
#42 0x004c9a48 in qpid::sys::DispatchHandle::processEvent (this=0x8b71008,
    type=READABLE) at qpid/sys/DispatchHandle.cpp:428
#43 0x004763b0 in process (this=0x8b70430) at ./qpid/sys/Poller.h:122
#44 qpid::sys::Poller::run (this=0x8b70430)
    at qpid/sys/epoll/EpollPoller.cpp:402
#45 0x004c7ef4 in qpid::sys::Dispatcher::run (this=0xbfab0ea0)
    at qpid/sys/Dispatcher.cpp:37
#46 0x0046ced1 in qpid::sys::(anonymous namespace)::runRunnable (p=0xbfab0ea0)
    at qpid/sys/posix/Thread.cpp:35
#47 0x00702832 in start_thread () from /lib/libpthread.so.0
#48 0x00992e0e in clone () from /lib/libc.so.6


"
Bug,QPID-2762,12470263,qpid-tool does not list all classes.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:29,C++,C++ Tools,,,,,,,"The ""list"" command in qpid-tool does not find all classes if a given class has different hash values (e.g. agents are publishing different versions of the same class).   qpid-tool will stop listing at the first match against the package/class name, instead of listing all class keys containing the same package/class name."
Bug,QPID-2448,12459139,qpid::client::ConnectionImpl::addSession does not raise an exception if no channel number is available.,aconway,aconway,Closed,Fixed,2013-07-29 17:57,C++,C++ Client,,,,,,,"qpid::client::ConnectionImpl::addSession does not raise an exception if no channel number is available, it silently fails to allocate a channel. It should throw a ResourceLimitExceededException. "
Bug,QPID-2436,12458292,Cluster inconsistency caused by management agents.,aconway,aconway,Closed,Fixed,2013-07-29 17:55,C++,C++ Clustering,,,,,,,"When management agents are attached  to brokers in a cluster, you can get nodes failing with errors like this:

cluster0-3: 2010-03-04 16:41:04 critical cluster(20.0.100.32:19887 READY/error) local error 104126 did not occur on member 20.0.100.32:19083: invalid-argument: anonymous.qmfagent-32e08748-11cc-43c2-87e8-f1cc2ecafbd8: confirmed < (33+0) but only sent < (32+0) (../../cpp/src/qpid/SessionState.cpp:151)
A reproducing test has been comitted to SVN

Steps to Reproduce:
1. Remove cluster_tests.LongTests.test_management from src/tests/cluster_tests.fail to enable the test
2. make check TESTS=run_cluster_tests CLUSTER_TESTS='*.test_management -DDURATION=2
"
Bug,QPID-534,12372923,throw exception for get where it fails due to channel or connection exception,gsim,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"E.g. if getting from a non-existant queue, exception should be thrown rather than returning false."
Bug,QPID-535,12373050,throw correct exception when a channel- or connection- close is received instead of an expected response,gsim,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"E.g. if issuing a consume request for a queue that deosn't exist, the client should throw a ChannelException with the correct code and text. (Currently it throws QpidError(Expected class:method 60:21, got 20:40))"
Bug,QPID-303,12360763,Client hangs on error,gsim,aconway,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"If the broker crashes or disconnects unexpectedly, or the client internally throws an exception becaue the broker returns a bad frame, the C++ client  hangs. Some client threads are not being shut down on error.
"
Bug,QPID-1867,12425927,C++ build failure on RHEL 5 starting at about r776144,shuston,shuston,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"The following errors started happening Tuesday night/Wednesday morning on my RHEL 5 system:
g++ -DHAVE_CONFIG_H -I. -I../../../src -I. -Igen -I../../../src/gen -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -I/usr/include/nspr4 -I -g -O2 -MT qpid/sys/ssl/libsslcommon_la-util.lo -MD -MP -MF qpid/sys/ssl/.deps/libsslcommon_la-util.Tpo -c ../../../src/qpid/sys/ssl/util.cpp -fPIC -DPIC -o qpid/sys/ssl/.libs/libsslcommon_la-util.o
../../../src/qpid/sys/ssl/util.cpp:29:21: error: pk11pub.h: No such file or directory
../../../src/qpid/sys/ssl/util.cpp:30:17: error: ssl.h: No such file or directory
../../../src/qpid/sys/ssl/util.cpp:71: error: 'PK11SlotInfo' was not declared in this scope
../../../src/qpid/sys/ssl/util.cpp:71: error: expected primary-expression before ',' token
../../../src/qpid/sys/ssl/util.cpp:71: error: expected primary-expression before 'retry'
../../../src/qpid/sys/ssl/util.cpp:71: error: expected primary-expression before 'void'
../../../src/qpid/sys/ssl/util.cpp:71: error: initializer expression list treated as compound expression
../../../src/qpid/sys/ssl/util.cpp:72: error: expected ',' or ';' before '{' token
../../../src/qpid/sys/ssl/util.cpp:80: error: 'PK11SlotInfo' was not declared in this scope
../../../src/qpid/sys/ssl/util.cpp:80: error: expected primary-expression before ',' token
../../../src/qpid/sys/ssl/util.cpp:80: error: expected primary-expression before 'retry'
../../../src/qpid/sys/ssl/util.cpp:80: error: expected primary-expression before 'void'
../../../src/qpid/sys/ssl/util.cpp:80: error: initializer expression list treated as compound expression
../../../src/qpid/sys/ssl/util.cpp:81: error: expected ',' or ';' before '{' token
../../../src/qpid/sys/ssl/util.cpp:118: error: expected `}' at end of input
../../../src/qpid/sys/ssl/util.cpp:118: error: expected `}' at end of input
../../../src/qpid/sys/ssl/util.cpp:118: error: expected `}' at end of input
make[3]: *** [qpid/sys/ssl/libsslcommon_la-util.lo] Error 1
g++ -DHAVE_CONFIG_H -I. -I../../../src -I. -Igen -I../../../src/gen -Werror -pedantic -Wall -Wextra -Wno-shadow -Wpointer-arith -Wcast-qual -Wcast-align -Wno-long-long -Wvolatile-register-var -Winvalid-pch -Wno-system-headers -Woverloaded-virtual -I/usr/include/nspr4 -I -g -O2 -MT qpid/sys/ssl/libsslcommon_la-SslSocket.lo -MD -MP -MF qpid/sys/ssl/.deps/libsslcommon_la-SslSocket.Tpo -c ../../../src/qpid/sys/ssl/SslSocket.cpp -fPIC -DPIC -o qpid/sys/ssl/.libs/libsslcommon_la-SslSocket.o
../../../src/qpid/sys/ssl/SslSocket.cpp:42:21: error: pk11pub.h: No such file or directory
../../../src/qpid/sys/ssl/SslSocket.cpp:43:17: error: ssl.h: No such file or directory
../../../src/qpid/sys/ssl/SslSocket.cpp:44:17: error: key.h: No such file or directory
../../../src/qpid/sys/ssl/SslSocket.cpp: In constructor 'qpid::sys::ssl::SslSocket::SslSocket()':
../../../src/qpid/sys/ssl/SslSocket.cpp:111: error: 'SSL_ImportFD' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp: In constructor 'qpid::sys::ssl::SslSocket::SslSocket(qpid::sys::IOHandlePrivate*, PRFileDesc*)':
../../../src/qpid/sys/ssl/SslSocket.cpp:121: error: 'SSL_ImportFD' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:122: error: 'SSL_ResetHandshake' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:122: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:123: error: 'SSL_ForceHandshake' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:123: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp: In member function 'void qpid::sys::ssl::SslSocket::connect(const std::string&, uint16_t) const':
../../../src/qpid/sys/ssl/SslSocket.cpp:141: error: 'NSS_GetClientAuthData' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:141: error: 'SSL_GetClientAuthDataHook' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:141: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:142: error: 'SSL_SetURL' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:142: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:155: error: 'SSL_ForceHandshake' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:155: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp: In member function 'int qpid::sys::ssl::SslSocket::listen(uint16_t, int, const std::string&, bool) const':
../../../src/qpid/sys/ssl/SslSocket.cpp:169: error: 'SSL_ImportFD' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:171: error: 'SSL_REQUEST_CERTIFICATE' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:171: error: 'SSL_OptionSet' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:171: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:172: error: 'SSL_REQUIRE_CERTIFICATE' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:172: error: 'SSL_OptionSet' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:172: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:176: error: 'CERTCertificate' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:176: error: 'cert' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:176: error: 'PK11_FindCertFromNickname' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:178: error: 'SECKEYPrivateKey' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:178: error: 'key' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:178: error: 'PK11_FindKeyByAnyCert' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:180: error: 'NSS_FindCertKEAType' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:180: error: 'SSL_ConfigSecureServer' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:180: error: 'SECSuccess' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:181: error: 'SECKEY_DestroyPrivateKey' was not declared in this scope
../../../src/qpid/sys/ssl/SslSocket.cpp:182: error: 'CERT_DestroyCertificate' was not declared in this scope
make[3]: *** [qpid/sys/ssl/libsslcommon_la-SslSocket.lo] Error 1

"
Bug,QPID-683,12382500,Assertion in SessionCore::connectionClosed(),,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"#0  0x45b8b410 in __kernel_vsyscall ()
#1  0x45bd1069 in raise () from /lib/libc.so.6
#2  0x45bd2671 in abort () from /lib/libc.so.6
#3  0x45bca9d9 in __assert_fail () from /lib/libc.so.6
#4  0x001ad95c in qpid::client::SessionCore::connectionClosed (this=Variable ""this"" is not available.
) at qpid/client/SessionCore.cpp:280
#5  0x0018a65b in qpid::client::ConnectionImpl::forChannels<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::client::SessionCore, unsigned short, std::string const&>, boost::_bi::list3<boost::arg<1>, boost::_bi::value<unsigned short>, boost::_bi::value<std::string> > > > (this=0x90ca650, functor=@0xb7585b84) at /usr/include/boost/bind/mem_fn_template.hpp:262
#6  0x001881b5 in qpid::client::ConnectionImpl::closed (this=0x90ca650, code=541, text=@0xb7586014)
    at qpid/client/ConnectionImpl.cpp:129
#7  0x00188aad in boost::detail::function::void_function_obj_invoker2<boost::_bi::bind_t<void, boost::_mfi::mf2<void, qpid::client::ConnectionImpl, unsigned short, std::string const&>, boost::_bi::list3<boost::_bi::value<qpid::client::ConnectionImpl*>, boost::arg<1>, boost::arg<2> > >, void, unsigned short, std::string const&>::invoke (function_obj_ptr=
      {obj_ptr = 0x90ca788, const_obj_ptr = 0x90ca788, func_ptr = 0x90ca788, data = ""\210""}, a0=541, a1=@0xb7586014)
    at /usr/include/boost/bind/mem_fn_template.hpp:252
#8  0x001a3ca9 in boost::function2<void, unsigned short, std::string const&, std::allocator<void> >::operator() (
    this=0x90ca74c, a0=541, a1=@0xb7586014) at /usr/include/boost/function/function_template.hpp:576
#9  0x001a2301 in qpid::client::ConnectionHandler::handle (this=0x90ca678, method=0xb758600c)
    at qpid/client/ConnectionHandler.cpp:184

void SessionCore::connectionClosed(uint16_t code, const std::string& text) {
    Lock l(state);
    try {
        doClose(code, text);
    } catch(...) { assert (0); }
}

So doClose() threw an exception... don't know what it was I'm afraid.
"
Bug,QPID-657,12380780,session methods need to accept string literals in keyword and ordinary methods,gsim,gsim,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"e.g. session.queueQuery(""foo"") or session.queueQuery_(queue=""foo"")

(currently only std::string is accepted)."
Bug,QPID-449,12366915,C++ client race in socket code,gsim,aconway,Closed,Fixed,2013-07-29 15:15,C++,C++ Client,,,,,,,"quick_topictest fails intermittently on a multi-processor. Fairly easy to reproduce. Does not occur on my single CPU laptop so it looks like a thread sync problem.

Here's an example: (red-hatters I ran this on  qpid-test.lab.boston.redhat.com)

[aconway@qpid-test tests]$ while ./quick_topictest  ; do echo -n . ; done
........../quick_topictest FAILED:
Start subscriber 1
Start subscriber 0
Completed 1 of 1 in 81ms
Error [20009] Bad file descriptor (sys/apr/Socket.cpp:58)
[aconway@qpid-test tests]$ while ./quick_topictest  ; do echo -n . ; done
................./quick_topictest FAILED:
Start subscriber 1
Start subscriber 0
Completed 1 of 1 in 79ms
Error [20009] Bad file descriptor (sys/apr/Socket.cpp:58)
terminate called after throwing an instance of 'qpid::QpidError'
  what():  Error [20009] Bad file descriptor (sys/apr/Socket.cpp:58)
./topictest: line 30: 10569 Aborted                 ./topic_publisher -messages\
 $MESSAGES -batches $BATCHES -subscribers $SUBSCRIBERS
"
Bug,QPID-52,12353771,"C++ build fails on RHEL 4, unordered_map not available.",aconway,aconway,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"c++ broker no longer builds on RHEL4. In 
particular the <tr1/memory> & <tr1/unordered_map> includes in FieldTable 
were causing errors"
Bug,QPID-4663,12638373,Cmake build failure (0.22-Alpha) when building with XML (xqilla-devel-2.2.3-8.el6.x86_64),,iboverma,Closed,Fixed,2013-07-29 13:18,C++,C++ Build,,,,,,,"    If Cmake builds are executed with XML, the build fails with these errors:

Building CXX object src/CMakeFiles/xml.dir/qpid/xml/XmlExchange.o

/var/lib/jenkins/iboverma/qpid/qpid/cpp/src/qpid/xml/XmlExchange.cpp: In member function ?쁞ool qpid::broker::XmlExchange::matches(qpid::broker::XmlExchange::Query&, qpid::broker::Deliverable&, const qpid::framing::FieldTable*, bool)??

/var/lib/jenkins/iboverma/qpid/qpid/cpp/src/qpid/xml/XmlExchange.cpp:192: error: ?쁟lass ResultImpl??has no member named ?쁤etEffectiveBooleanValue??
make[2]: *** [src/CMakeFiles/xml.dir/qpid/xml/XmlExchange.o] Error 1

make[1]: *** [src/CMakeFiles/xml.dir/all] Error 2

Note: There is no such problem when building with autotools"
Bug,QPID-4662,12638370,Cmake build failure (0.22-Alpha) when building with boost-1.41.0-11.el6_1.2.x86_64,,iboverma,Closed,Fixed,2013-07-29 13:18,C++,C++ Build,,,,,,,"    By default, cmake builds are executed with -Werror flag, the build fails with these errors:

/usr/include/boost/function/function_template.hpp:602: note: ?쁣??was declared here

In file included from /usr/include/boost/bind/bind.hpp:1538,

                 from /usr/include/boost/bind.hpp:22,

                 from /var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:32:

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp: In function ?쁞oost::_bi::bind_t<R, R (*)(B1, B2, B3, B4, B5, B6), typename boost::_bi::list_av_6<A1, A2, A3, A4, A5, A6>::type> boost::bind(R (*)(B1, B2, B3, B4, B5, B6), A1, A2, A3, A4, A5, A6) [with R = void, B1 = boost::shared_ptr<qpid::sys::Poller>, B2 = const qpid::sys::SocketTransportOptions&, B3 = qpid::sys::Timer*, B4 = const qpid::sys::Socket&, B5 = qpid::sys::ConnectionCodec::Factory*, B6 = const std::string&, A1 = boost::shared_ptr<qpid::sys::Poller>, A2 = qpid::sys::SocketTransportOptions, A3 = qpid::sys::Timer*, A4 = boost::arg<1>, A5 = qpid::sys::ConnectionCodec::Factory*, A6 = std::basic_string<char, std::char_traits<char>, std::allocator<char> >]??

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??is used uninitialized in this function

/usr/include/boost/bind/bind_cc.hpp:83: note: ?쁝2??was declared here

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??may be used uninitialized in this function

/usr/include/boost/bind/bind.hpp:551: note: ?쁝2??was declared here

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??may be used uninitialized in this function

/usr/include/boost/bind/storage.hpp:276: note: ?쁝2??was declared here

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??may be used uninitialized in this function

/usr/include/boost/bind/storage.hpp:227: note: ?쁝2??was declared here

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??may be used uninitialized in this function

/usr/include/boost/bind/storage.hpp:195: note: ?쁝2??was declared here

/var/lib/jenkins/workspace/qpid-cpp-trunk-cmake/label/master/qpid/cpp/src/qpid/sys/SocketTransport.cpp:209: error: ?쁝2??may be used uninitialized in this function

/usr/include/boost/bind/storage.hpp:129: note: ?쁝2??was declared here

make[2]: *** [src/CMakeFiles/qpidbroker.dir/qpid/sys/SocketTransport.o] Error 1

make[1]: *** [src/CMakeFiles/qpidbroker.dir/all] Error 2

make: *** [all] Error 2"
Bug,QPID-4435,12615969,Reconnect on connect failure hangs at third address to try,astitcher,astitcher,Closed,Fixed,2012-11-13 22:19,C++,C++ Broker,C++ Client,,,,,,"Necessary conditions to trigger hang:

* You are connecting to a name that resolves to 3 or more underlying network addresses.
* The first 2 addresses refuse the connection (there is no daemon listening on the appropriate port at that address).

In this case the client will attempt to connect to the third resolved address, but will hang forever waiting.

If you look at a server log that is listening on the third address then you will eventually see:
   ... error Connection ... No protocol received closing
because the server has received the connection and made the initial reply but has not heard back in the alloted time."
Bug,QPID-982,12394996,C++ rubygen code generator sensitive to ruby version.,,aconway,Closed,Fixed,2012-09-18 22:33,C++,C++ Broker,C++ Client,,,,,,"ruby generator does not work with some 1.8.6 versions of ruby, as discussed on qpid-dev:

> On Tue, Apr 29, 2008 at 1:41 PM, Gordon Sim <gsim@redhat.com> wrote:
> 
>> Senaka Fernando wrote:
>>
>>> My version of ruby is,
>>>
>>> ruby 1.8.6 (2007-06-07 patchlevel 36) [i486-linux]
>>>
>> The problem does appear to be related to ruby version. Arnaud hit the same
>> problem with 1.8.6.111 and on upgrading to 1.8.6.114 the problem went away
>> and the files were generated as expected.
>>"
Bug,QPID-4107,12597493,HA does not replicate alternate-exchange,aconway,aconway,Closed,Fixed,2012-07-26 21:29,C++,C++ Clustering,,,,,,,"In a HA cluster, the alternate-exchange setting on queues and exchanges is not replicated.

Note that to replicate it, you need to solve the problem of ensuring you have replicated the required exchange before you try to set it on a newly replicated queue (or exchange)."
Bug,QPID-3445,12519667,"Assertion, and unexpected exception in qpid::messaging::decode",gsim,pcolby,Closed,Fixed,2012-02-20 10:15,C++,C++ Client,,,,,,,"Although this is technically two different bug reports, they are very closely related, and should probably be tested / fixed together, so I'm reporting them both here... hope that's okay ;)

Both {{qpid::messaging::decode}} functions can assert, or throw an unexpected {{qpid::framing::IllegalArgumentException}} on invalid input.

Consider the following code fragment:
{code}
const qpid::messaging::Message message(""foo"");
try {
    qpid::types::Variant::Map map;
    qpid::messaging::decode(message, map); // asserts in qpid::framing::Buffer::getLong
} catch (const qpid::messaging::EncodingException &ex) {
    std::cout << ""qpid::messaging::EncodingException "" << ex.what() << std::endl;
}
std::cout << ""done"" << std::endl; // never reached.
{code}

In that example, the {{qpid::messaging::decode}} function will result in an assertion in {{qpid::framing::Buffer::getLong}} as that function assumes / requires the buffer to be at least 4 bytes.  Clearly in this case the decode should fail, but ideally it should fail in a catchable way, not an assertion.

I would think the right solution would be to add a minimum size check to the {{qpid::framing::FieldTable::decode}} function.  But it could also be solved by adding the size check to the {{qpid::messaging::decode}} and/or  {{qpid::framing::Buffer::getLong}} functions.

As a temporary workaround, client code can add a size check before the {{decode}} call, like:

{code}
const qpid::messaging::Message message(""foo"");
try {
    if (message.getContent().size() < 4)
        throw qpid::messaging::EncodingException(""message too small"");
    qpid::types::Variant::Map map;
    qpid::messaging::decode(message, map);
} catch (const qpid::messaging::EncodingException &ex) {
    std::cout << ""qpid::messaging::EncodingException "" << ex.what() << std::endl;
}
std::cout << ""done"" << std::endl;
{code}

But now if we extend the message a little, so that it is at least 4 bytes long like so:
{code}
const qpid::messaging::Message message(""\0\0\0\7foo"", 7);
try {
    if (message.getContent().size() < 4)
        throw qpid::messaging::EncodingException(""message too small"");
    qpid::types::Variant::Map map;
    qpid::messaging::decode(message, map);
} catch (const qpid::messaging::EncodingException &ex) {
    std::cout << ""qpid::messaging::EncodingException "" << ex.what() << std::endl;
}
std::cout << ""done"" << std::endl; // never reached.
{code}

Then we run into a second problem.  In that case, the {{""done""}} line is still not reached, because a {{qpid::framing::IllegalArgumentException}} is thrown in {{qpid::framing::FieldTable::decode}} with message {{""Not enough data for field table.""}}.  However, this exception type is not listed in the documentation for the {{qpid::messaging::decode}} function - the documentation only mentions {{EncodingException}}, and the two share no common ancestry until right back at {{std::exception}}.

Although one solution might be just to add {{IllegalArgumentException}} to the documentation, I suspect a preferable solution would be to catch the {{IllegalArgumentException}} in {{qpid::messaging::decode}} and re-throw it as an {{EncodingException}} like:
{code}
     static void decode(const Message& message, typename C::ObjectType& object, const std::string& encoding)
     {
         checkEncoding(message, encoding);
-        C::decode(message.getContent(), object);
+        try {
+            C::decode(message.getContent(), object);
+        } catch (const qpid::Exception &ex) {
+            throw EncodingException(ex.what());
+        }
     }
{code}

A quick code review shows that {{qpid::framing::FieldTable::decode}} (and thus {{qpid::messaging::decode}}) can also throw the {{OutOfBounds}} exception, which, like {{IllegalArgumentException}}, descends from {{qpid::Exception}}.  So a final solution might look something like:
{code}
Index: framing/FieldTable.cpp
===================================================================
--- framing/FieldTable.cpp      (revision 1160172)
+++ framing/FieldTable.cpp      (working copy)
@@ -198,10 +198,12 @@

 void FieldTable::decode(Buffer& buffer){
     clear();
+    if (buffer.available() < 4)
+        throw IllegalArgumentException(QPID_MSG(""Not enough data for field table.""));
     uint32_t len = buffer.getLong();
     if (len) {
         uint32_t available = buffer.available();
-        if (available < len)
+        if ((available < len) || (available < 4))
             throw IllegalArgumentException(QPID_MSG(""Not enough data for field table.""));
         uint32_t count = buffer.getLong();
         uint32_t leftover = available - len;
Index: messaging/Message.cpp
===================================================================
--- messaging/Message.cpp       (revision 1160172)
+++ messaging/Message.cpp       (working copy)
@@ -21,6 +21,7 @@
 #include ""qpid/messaging/Message.h""
 #include ""qpid/messaging/MessageImpl.h""
 #include ""qpid/amqp_0_10/Codecs.h""
+#include <qpid/Exception.h>
 #include <boost/format.hpp>

 namespace qpid {
@@ -115,7 +116,11 @@
     static void decode(const Message& message, typename C::ObjectType& object, const std::string& encoding)
     {
         checkEncoding(message, encoding);
-        C::decode(message.getContent(), object);
+        try {
+            C::decode(message.getContent(), object);
+        } catch (const qpid::Exception &ex) {
+            throw EncodingException(ex.what());
+        }
     }

     static void encode(const typename C::ObjectType& map, Message& message, const std::string& encoding)
{code}

Thoughts?"
Bug,QPID-3623,12531614,qpid-analyze-tool incorrectly assigns transaction numbers to commands,kpvdr,kpvdr,Closed,Fixed,2011-11-16 16:13,C++,C++ Tools,,,,,,,The qpid trace analysis tool tracks transactional sessions and assigns a generated transaction id to commands to help isolate transactional boundaries. The tool incorrectly assigns these numbers based on the ordering seen on the wire rather than on the MessageAccept commands that precede the TxCommit.
Bug,QPID-3121,12500645,Cluster management inconsistency when using persistent store.,aconway,aconway,Closed,Fixed,2011-06-23 13:40,C++,C++ Clustering,,,,,,,"If cluster_tests.py, test_management is modified to enable durable messages, it fails the log comparison test shows messages like this on one broker but not the others:

trace Changed V1 statistics org.apache.qpid.broker:connection:127.0.0.1:52742-127.0.0.1:44104 len=NN
trace Changed V2 statistics org.apache.qpid.broker:connection:127.0.0.1:52742-127.0.0.1:44104

To date this hasn't been seen to actually cause a cluster crash but in principle it is possible it could.

To reproduce, build the message store at: http://anonsvn.jboss.org/repos/rhmessaging/store/
In the tests/cluster directory, run this in a loop:

make check TESTS=run_python_cluster_tests CLUSTER_TESTS='*.test_management* -DDURATION=2'

It will fail, usually on the first iteration, showing the log files that don't match. Use diff or other such tool to confirm that the mismatched lines are as above. The file may also contain some other mismatches showing a different number of stats in a periodic update - that is a consequence of the above."
Bug,QPID-3004,12495825,Qpid does not compile cleanly with clang++ compiler (2.8),,astitcher,Closed,Fixed,2011-05-09 21:05,C++,C++ Broker,C++ Client,C++ Clustering,,,,,"The Clang project C++ compiler has got to the point where it can now compile the qpid C++ code.

There are some advantages of using this compiler over the GCC compiler that we've previously been using for Unix compiles:
  Much better error messages:
  Faster compiles
and of course there are disadvantages too.

In general I believe there is no portable code just ported code, but code that compiles under the most environments will naturally be the most portable and I'd assert the most bug free too. Therefore I think it is to the benefit of the Qpid if we get the C++ code to compile under clang++ too.

Currently there appear to be a vast number of warnings of the form:

In file included from ../../src-working/cpp/src/qpid/client/SessionImpl.h:35:
./qpid/framing/AMQP_ClientOperations.h:54:30: warning: extra ';' inside a class [-pedantic]
        ConnectionHandler(){};
                             ^

[You'll note that there is an indicator of where in the line the error occurs too as well as just the line no. - the variable pitch font messes it up though]

And there are some smaller number of actual compile errors."
Bug,QPID-2916,12478587,C++ broker & Python client will silently truncate strings whose length is greater than the max length supported by the type.,kgiusti,kgiusti,Closed,Fixed,2010-10-28 21:41,C++,C++ Broker,C++ Client,Python Client,,,,,"While testing QMF, I attempted to send a string of length > 255 bytes as a str8.  Both the broker and the python client will encode the string by either truncating it, or incorrectly truncating the length."
Bug,QPID-2558,12463329,client connection.open to a non-broker on qpid 0.6 windows segfaults with: access violation,,clyfe,Closed,Fixed,2010-05-03 23:02,C++,C++ Client,,,,,,,"In windows environment, visual studio compiler, make a client like:

    Connection c;
    try {
        // there is no broker running at 10.10.5.51 so an exception should be thrown
        c.open(""10.10.5.51"",5672,""my_user"",""my_password"");
    } catch (...) {
        std::cout << ""error"" << std::endl;
    }

on qpid 0.5 an exception is thrown and catched. ALL OK HERE
on qpid 0.6 the program segfaults with the message:
""Unhandled exception at 0x692eccb9 in testqpid06.exe: 0xC0000005: Access violation reading location 0x00000000.""
This error is thrown just after executing the ""c.open"" line.
On Linux all is OK, the problem is only on Windows."
Bug,QPID-2186,12439851,"Windows - ""vector iterator not dereferencable""",astitcher,lroloson,Closed,Fixed,2010-04-29 1:18,C++,C++ Client,,,,,,,"i have the direct listener built from the examples, and it throws the above exception when there is no broker running at the supplied address. It does connect and get messages when the broker is running. 

The call stack when the exception occurs: 
---------------------------------------------- 

>	msvcp90d.dll!std::_Debug_message(const wchar_t * message=0x00fa7e28, const wchar_t * file=0x00fa7798, unsigned int line=98)  Line 24	C++ 
 	qpidcommond.dll!std::_Vector_const_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >::operator*()  Line 98 + 0x14 bytes	C++ 
 	qpidcommond.dll!std::_Vector_iterator<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >::operator*()  Line 340	C++ 
 	qpidcommond.dll!std::vector<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >::front()  Line 790 + 0x24 bytes	C++ 
 	qpidcommond.dll!std::priority_queue<boost::intrusive_ptr<qpid::sys::TimerTask>,std::vector<boost::intrusive_ptr<qpid::sys::TimerTask>,std::allocator<boost::intrusive_ptr<qpid::sys::TimerTask> > >,std::less<boost::intrusive_ptr<qpid::sys::TimerTask> > >::top()  Line 207	C++ 
 	qpidcommond.dll!qpid::sys::Timer::run()  Line 114 + 0xf bytes	C++ 
 	qpidcommond.dll!`anonymous namespace'::runRunnable(void * p=0x101e63d0)  Line 32 + 0xf bytes	C++ 
 	msvcr90d.dll!_callthreadstartex()  Line 348 + 0xf bytes	C 
 	msvcr90d.dll!_threadstartex(void * ptd=0x0116b6d8)  Line 331	C 
 	kernel32.dll!7c80b729() 
 	[Frames below may be incorrect and/or missing, no symbols loaded for kernel32.dll]	
 	boost_program_options-vc90-mt-gd-1_35.dll!003a0043() 
 	msvcr90d.dll!_mbsnbcpy_l(unsigned char * dst=0x00730063, const unsigned char * src=0x00000073, unsigned int cnt=6619236, localeinfo_struct * plocinfo=0x00610066)  Line 57 + 0x3d bytes	C++ "
Bug,QPID-1722,12416469,Use of gethostbyname() in Socket.cpp isn't thread safe,astitcher,astitcher,Closed,Fixed,2009-03-09 21:22,C++,C++ Broker,C++ Client,,,,,,"Using gethostbyname() like this in multiple threads at once (for instance connecting simultaneously) may cause client/broker crashes

The best fix is to replace the old API used with the re-entrant and more featureful getaddrinfo() API
"
Bug,QPID-920,12393968,Convert c++ client to final 0-10 spec,gsim,gsim,Closed,Fixed,2008-06-26 8:28,C++,C++ Client,,,,,,,C++ client is still using the preview version of the 0-10 spec.
Bug,QPID-581,12377737,channel closure is broken,gsim,gsim,Closed,Fixed,2008-06-26 8:28,C++,C++ Client,,,,,,,Closing a channel while incoming messages are being received does not work. The client assumes the deliver is the response to the channel.close and gets confused.
Bug,QPID-354,12362320,c++ client does not expose durable param to queue declare,gsim,gsim,Closed,Fixed,2008-06-26 8:28,C++,C++ Client,,,,,,,The durable flag for queue-declare is currently hardcoded to false and must be exposed to applications.
Bug,QPID-758,12386931,The Java request/response server fails when reading replyto field sets by a c++ producer. ,,arnaudsimon,Closed,Fixed,2008-01-23 14:43,C++,C++ Client,JMS AMQP 0-x,,,,,,"The following exception is thrown:
Illegal value in JMS_ReplyTo property: direct://amq.direct/client a4f614c5-3d4e-43d3-804a-b108500e67f8/client a4f614c5-3d4e-43d3-804a-b108500e67f8
       at org.apache.qpid.client.message.AbstractJMSMessage.getJMSReplyTo(AbstractJMSMessage.java:227)
"
Bug,QPID-8476,13333687,Reorder compiler warning [-Wreorder] in examples/messaging/spout.cpp,jdanek,jdanek,Resolved,Fixed,2021-03-31 0:06,C++,C++ Build,,,,,,,"Compilation prints the following warning. I am using GCC 9.

{noformat}
[ 91%] Building CXX object examples/messaging/CMakeFiles/spout.dir/OptionParser.cpp.o
/home/jdanek/.cache/bazel/_bazel_jdanek/36e30b937da1503cce68d3840f1df2bc/sandbox/linux-sandbox/24/execroot/cli_cpp/external/qpid-cpp/examples/messaging/spout.cpp: In constructor 'Options::Options()':
/home/jdanek/.cache/bazel/_bazel_jdanek/36e30b937da1503cce68d3840f1df2bc/sandbox/linux-sandbox/24/execroot/cli_cpp/external/qpid-cpp/examples/messaging/spout.cpp:48:9: warning: 'Options::count' will be initialized after [-Wreorder]
   48 |     int count;
      |         ^~~~~
/home/jdanek/.cache/bazel/_bazel_jdanek/36e30b937da1503cce68d3840f1df2bc/sandbox/linux-sandbox/24/execroot/cli_cpp/external/qpid-cpp/examples/messaging/spout.cpp:47:10: warning:   'bool Options::durable' [-Wreorder]
   47 |     bool durable;
      |          ^~~~~~~
/home/jdanek/.cache/bazel/_bazel_jdanek/36e30b937da1503cce68d3840f1df2bc/sandbox/linux-sandbox/24/execroot/cli_cpp/external/qpid-cpp/examples/messaging/spout.cpp:57:5: warning:   when initialized here [-Wreorder]
   57 |     Options()
      |     ^~~~~~~
{noformat}

There is a patch submitted at https://github.com/apache/qpid-cpp/pull/23"
Bug,QPID-6007,12734479,qpid-route uses machine hostname if host not given,jross,eallen,Closed,Fixed,2019-10-02 17:34,C++,C++ Tools,,,,,,,"When a broker address is not supplied to qpid-route, it attempts to use the machines hostname as the broker address. This works well when the hostname is translatable to an ip address. However, when the hostname has been set to a non-translatable string, qpid-route fails. 

For backwards compatability, qpid-route should continue to use hostname when the broker address is not supplied, but if hostname is not a valid address, qpid-route should default to ""localhost"".
 "
Bug,QPID-5169,12670283,qpid-tools help typos (CRAM-MD -> CRAM-MD5),,eallen,Closed,Fixed,2019-10-02 17:34,C++,C++ Tools,,,,,,,Usage text for several python tools refers to CRAM-MD instead CRAM-MD5
Bug,QPID-6718,12860398,parsing errors for integer literals in selectors,astitcher,gsim,Closed,Fixed,2019-08-07 9:41,C++,C++ Client,,,,,,,"There are a few integer literals that cause selector parsing to fail or the resulting evaluation to be incorrect:

(a) hexadecimal literals don't seem to be recognised, e.g. 0xFF will result in a parse error
(b) octal literals are evaluated as decimal e.g 077 is interpreted as decimal 77 rather than decimal 63
(c) large numbers fail with a lexical cast error, e.g -9223372036854775808L or 9223372036854775807L"
Bug,QPID-7821,13079264,Missing man pages,jross,iboverma,Closed,Fixed,2018-04-03 23:23,C++,C++ Documentation,,,,,,,"Debian distribution requires all binaries to have man pages. These do not:
../build.log:W: qpid-receive: binary-without-manpage usr/bin/qpid-receive
../build.log:W: qpid-send: binary-without-manpage usr/bin/qpid-send
../build.log:W: qmf-gen: binary-without-manpage usr/bin/qmf-gen
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-config
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-ha
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-printevents
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-queue-stats
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-route
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-stat
../build.log:W: qpid-tools: binary-without-manpage usr/bin/qpid-tool
"
Bug,QPID-7860,13087239,[cpp] Build produces deprecation warnings on recent Fedora,jross,jross,Resolved,Fixed,2017-10-27 14:17,C++,C++ Broker,C++ Client,,,,,,"{noformat}
-- Found SWIG: /usr/bin/swig (found version ""3.0.11"") 
-- Found PythonLibs: /usr/lib64/libpython2.7.so (found version ""2.7.13"") 
-- Found Perl: /usr/bin/perl (found version ""5.24.1"") 
-- Found PerlLibs: /usr/lib64/libperl.so (found version ""5.24.1"") 
-- Building Python bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/python/CMakeLists.txt:35 (swig_add_module)


CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qmf2/python/CMakeLists.txt:35 (swig_add_module)


-- Building Ruby bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/ruby/CMakeLists.txt:48 (swig_add_module)


CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qmf2/ruby/CMakeLists.txt:39 (swig_add_module)


-- Building Perl bindings
CMake Deprecation Warning at /usr/share/cmake/Modules/UseSWIG.cmake:226 (message):
  SWIG_ADD_MODULE is deprecated.  Use SWIG_ADD_LIBRARY instead.
Call Stack (most recent call first):
  bindings/qpid/perl/CMakeLists.txt:31 (swig_add_module)


-- Configuring done
-- Generating done
-- Build files have been written to: /home/jross/code/qpid-cpp/bld
{noformat}"
Bug,QPID-140,12357364,topictest script assumes that sh==bash,aconway,astitcher,Closed,Fixed,2017-03-14 19:43,C++,C++ Tests,,,,,,,"the topictest script has #!/bin/sh but then uses bash features, this works in distros where sh==bash but not those where they are separate."
Bug,QPID-2963,12480984,doxygen-generated C++ docs lost CSS references,robbie,shuston,Closed,Fixed,2017-03-13 12:05,C++,C++ Documentation,,,,,,,"The svn checkin at r95722 removed the CSS references from qpid/cpp/docs/api/header.html - this caused the generated html to lose the CSS references and the tab navigation, etc. The web content hasn't been regenerated since before this change so it still looks ok."
Bug,QPID-2714,12468434,"""Programming in Apache Qpid"" doesn't discuss capacity/credit",,shuston,Closed,Fixed,2017-03-13 12:00,C++,C++ Documentation,,,,,,,"My comments grew out of looking at the C++ messaging API, though this probably applies to Python and .NET as well.

During a discussion on users@qpid I initiated recently I learned that creating a number of Receivers and calling session.nextReceiver() to wait for a message on any of the Receivers doesn't work unless some capacity is granted to the Receivers first. This is different from simply calling fetch() on a Receiver with no capacity - in that case the client code issues credit behind the scenes.

The code example shown in section 6 won't work (I used something very similar in a program I wrote, and it didn't for the reason above). I'll attach a patch that fixes the C++ code example, but there should be an introduction/discussion of the whole topic of capacity, credit, acks, etc."
Bug,QPID-4135,12598612,Footnote in table 2.3 in section 2.4.3.5 appears wrong,,davin,Closed,Fixed,2017-03-13 11:58,C++,C++ Documentation,,,,,,,"[a] If at-most-once is requested, unreliable will be used and for durable messages on durable queues there is the possibility that messages will be redelivered; if exactly-once is requested, ((at-most-once will)) be used and the application needs to be able to deal with duplicates.

I think should read:

[a] If at-most-once is requested, unreliable will be used and for durable messages on durable queues there is the possibility that messages will be redelivered; if exactly-once is requested, ((at-least-once)) will be used and the application needs to be able to deal with duplicates.

NOTE: Change is noted using ((double-parens)).
NOTE: RHEL MRG documentation appears wrong as well."
Bug,QPID-3077,12499253,"cpp INSTALL-WINDOWS errors, inconsistencies, improvements",shuston,shuston,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,The qpid/cpp/INSTALL-WINDOWS has some improvements suggested by Mike Owens wrt enclosing path names in quotes and specifying a makefile generator to cmake.
Bug,QPID-2309,12444271,Windows installer doesn't set up Start menu items for Broker or Qpid docs,shuston,shuston,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,The windows installer generated via CMake doesn't successfully add the desired Start menu items for either starting the broker or displaying the HTML API  help.
Bug,QPID-5863,12724709,qpid-config does not throws correct exception when binding nonexisting exchange,pmoravec,pmoravec,Closed,Fixed,2017-03-12 14:06,C++,C++ Tools,,,,,,,"Description of problem:
When binding nonexisting exchange to a queue, qpid-config failes with attribute error, instead of not-found exception from qmf agent.

Version-Release number of selected component (if applicable):
qpid-tools-0.22-3.el6.noarch

How reproducible:
100%

Steps to Reproduce:
1. bind a non existing exchange
qpid-config bind ""asdf"" queue 'x'


Actual results:
Failed: AttributeError: 'NoneType' object has no attribute 'type'

Expected results:
exception like with non existing queue
Failed: Exception: Exception from Agent: {u'error_code': 7, u'error_text': 'not-found: Bind failed. No such exchange: asdf (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/broker/Broker.cpp:1445)'}


Additional info:
binding non existing queue:
qpid-config bind ""amq.topic"" queue 'x'
Failed: Exception: Exception from Agent: {u'error_code': 7, u'error_text': 'not-found: Bind failed. No such queue: queue (/builddir/build/BUILD/qpid-0.22/cpp/src/qpid/broker/Broker.cpp:1445)'}"
Bug,QPID-4554,12629745,"QPID tools use of SSL parameter ""ssl_keyfile"" is incorrect.",kgiusti,kgiusti,Closed,Fixed,2017-03-12 14:06,C++,C++ Tools,,,,,,,"qid tools pass the SSL keyfile parameter to the python client library using the incorrect parameter name.  This results in the keyfile parameter being silently ignored.

The correct parameter name is ""ssl_keyfile"".  The tools incorrectly use ""ssl_key""."
Bug,QPID-3907,12547622,qpid-config fails when listing queues that have alternate exchange,tross,tross,Closed,Fixed,2017-03-12 14:06,C++,C++ Tools,,,,,,,"When running the command ""qpid-config queues"" when the broker has at least one queue with an alternate exchange, an exception is thrown during the execution of the command.
"
Bug,QPID-6661,12849576,[AMQP 1.0] heartbeat anomalies,gsim,gsim,Closed,Fixed,2016-09-06 21:32,C++,C++ Broker,C++ Client,,,,,,"The first heartbeat is often sent after the full idle period, whereas subsequent heartbeats are sent twice as frequently. This happens on both broker and client. This is a result of the periodic timer task that triggers the heartbeats being out of sync with the times computed by proton.

Also on the client, occasionally a heartbeat is missed. This is in part due to the issue above, but also occasionally due to timing of incoming heartbeats with respect to the timer task, resulting in proton emitting the heartbeat but it not actually being written to the wire."
Bug,QPID-6491,12820479,qpid-route map does not use any authentication when querying other brokers,pmoravec,pmoravec,Closed,Fixed,2016-09-06 21:32,C++,C++ Tools,,,,,,,"""qpid-route route map"" during generating the federation topology connects to each and every broker in the federation to query it's federation peers. All such connections (except for the very first broker) are made as anonymous user only.

It is requested the tool passes username, password and optionally also --client-sasl-mechanism parameter to all other brokers as well.

(another option to this would be the tool gets the credentials info from the broker, but currently QMF response to links does not contain such info. This option would need much more code change also on broker side)"
Bug,QPID-6648,12845724,"Spelling, grammar errors in qpid::messaging::Receiver API doc",shuston,shuston,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,,,,,,,There are a number of minor spelling/grammar errors I noticed while reading the qpid::messaging::Receiver API doc. This entry is a catch-all for them.
Bug,QPID-7100,12942923,qpid-perftest divide by zero when mode is shared and nsubs is zero,gsim,yalogr,Closed,Fixed,2016-09-06 21:32,C++,C++ Client,,,,,,,"when test mode is shared mode, qpid-perftest divides by zero when nsubs is zero."
Bug,QPID-2919,12478662,"hello_world, hello_xml examples left out of CMakeLists.txt",shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Examples,,,,,,,"The hello_world and hello_xml C++ examples added at r934573 and r941482, respectively, were not added to CMakeLists.txt."
Bug,QPID-2300,12443957,C++ packaging directory not included in release,shuston,shuston,Closed,Fixed,2016-09-06 20:28,C++,C++ Build,,,,,,,"The qpid/cpp/packaging directory (contains graphics, logos) is not included in the source cpp release. This prevents building an NSIS (Windows) installer from the cpp release."
Bug,QPID-4413,12614558,cmake build puts qpid.pc and qmf2.pc in wrong place,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"The cmake build generates qpid.pc and qmf2.pc but leaves them in the current directory, not in CMAKE_CURRENT_BINARY_DIR, where the install step expects to pick them up from."
Bug,QPID-2860,12474313,"C++ hello_xml example receives all message content, not just what's wanted",gsim,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Examples,,,,,,,"In using the qpid/cpp/examples/messaging/hello_xml.cpp example to figure something out, I changed the sent message's <station> element to Boston. This should cause the message to not pass the XQuery set in the receiver. But when executed, the ""Boston"" message is still received.

$ ./hello_xml
<weather><station>Boston (BOS)</station><wind_speed_mph>16</wind_speed_mph><temperature_f>70</temperature_f><dewpoint>35</dewpoint></weather>
"
Bug,QPID-3068,12498967,Some Windows-related files not packaged in release,shuston,shuston,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,"The release scripts don't package:

  windows/resources/template-resource.rc
  windows/resources/version-resource.h
  windows/resources/qpid-icon.ico"
Bug,QPID-3116,12500456,rubygen with ruby 1.9,aconway,baldmountain,Closed,Fixed,2016-09-06 20:27,C++,C++ Build,,,,,,,The ampqgen.rb script appends an underscore to attributes that may conflict with attributes that may already exist in object. The issue is with 'type'. It is an attribute in ruby 1.8.x but not in 1.9.x. The code accesses a type_ attribute in the code which doesn't actually exist when running under 1.9.x because type isn't an attribute. The fis is a simple special case for the type symbol.
Bug,QPID-4221,12603198,qpid-cluster -c does not work,,pmoravec,Closed,Fixed,2016-09-06 16:21,C++,C++ Tools,,,,,,,"Description of problem:
qpid-cluster -c <ID> shall view client connections to specified member, but it does not work at all. 


Version-Release number of selected component (if applicable):
any


How reproducible:
100%


Steps to Reproduce:
1. Setup a qpid cluster
2. Run qpid-cluster <one_broker_address> to discover ID of a broker. Output is something like:
$ qpid-cluster localhost:5672
  Cluster Name: test
Cluster Status: ACTIVE
  Cluster Size: 2
       Members: ID=1.2.3.4:28840 URL=amqp:tcp:1.2.3.4:5672
              : ID=1.2.3.5:21260 URL=amqp:tcp:1.2.3.5:5672
$
3. Query for connections on one node using broker ID from previous output, i.e.:
$ qpid-cluster -c 1.2.3.4:28840 localhost:5672

  
Actual results:
Output identical to the one in point 2. is written:
  Cluster Name: test
Cluster Status: ACTIVE
  Cluster Size: 2
       Members: ID=1.2.3.4:28840 URL=amqp:tcp:1.2.3.4:5672
              : ID=1.2.3.5:21260 URL=amqp:tcp:1.2.3.5:5672


Expected results:
List of connections, i.e. something like:
Clients on Member: ID=1.2.3.5:21260:
    dhcp-1-223:5672-1.2.3.4
    dhcp-1-223:5672-1.2.3.5
    localhost.localdomain:5672-127.0.0.1


Additional info:
Patch attached, trivial omitting of setting up variables at options parsing
"
Bug,QPID-2219,12441684,Example tests hang when run in a vpath build,tross,tross,Closed,Fixed,2016-09-06 16:21,C++,C++ Examples,,,,,,,"The example tests (i.e. make check -C examples) do not run in a vpath build.  The example programs fail to execute and the test then hangs forever waiting for the expected output.

...
make[2]: Entering directory `/home/ross/svn/qpid/build-vpath/examples'
../../cpp/examples/verify_all /home/ross/svn/qpid/build-vpath/../cpp/.. /home/ross/svn/qpid/build-vpath ""--no-module-dir --data-dir \""\"" --auth no --load-module ../src/.libs/xml.so""	 
== /home/ross/svn/qpid/build-vpath/../cpp/../cpp/examples/pub-sub/verify 
../../cpp/examples/verify: line 61: ./topic_listener: No such file or directory
...

The verify_all script makes no distinction between the source directory and the build directory.  The verify scripts are in the source dir but the compiled C++ example programs are in the build dir.
"
Bug,QPID-4222,12603200,qpid-cluster -C ignores credentials provided,,pmoravec,Closed,Fixed,2016-09-06 16:21,C++,C++ Tools,,,,,,,"Description of problem:
qpid-cluster -C shall connect to all brokers of the cluster to gather all connections to the brokers. However it ignores credentials from broker URL. So any connection attempt to a broker with authentication fails.


Version-Release number of selected component (if applicable):
any (incl. 0.12)


How reproducible:
100%


Steps to Reproduce:
1. Start clustered broker with authentication enabled (sasl config without anonymous mechanism)
2. SASL database to have default credentials stored (guest/guest for realm QPID)
3. Run:
qpid-cluster -C guest/guest@${HOSTNAME}:5672

  
Actual results:
Traceback (most recent call last):
  File ""/usr/bin/qpid-cluster"", line 316, in ?
    sys.exit(main())
  File ""/usr/bin/qpid-cluster"", line 307, in main
    raise Exception(""Failed: %s - %s"" % (e.__class__.__name__, e))
Exception: Failed: ConnectionFailed - (None, 'No acceptable SASL authentication mechanism available')


Expected results:
list of connections of the cluster to be printed out


Additional info:
Patch to be provided"
Bug,QPID-5828,12721434,qpid::Messaging API Sender/Receiver assorted bugs,gsim,calille,Closed,Fixed,2016-04-28 11:14,C++,C++ Client,,,,,,,"Several issues with the qpid::messaging::Sender and qpid::messaging::Receiver implementations.

Summarized below:

 - TTL on a message does not get adjusted when stored in the outgoing
 Sender queue and the queue cannot be emptied due to broker unavailability. 

- TTL on messages that expire while they are cached in the receivers queue. Messages still get delivered even though they have expired.  

 - getUnsettled segmentation error when called with no connection to
 broker but messages in the Sender outgoing queue (fine with zero size
 outbound queue).

 - Inconsistent behavior of Sender when Broker not connected. When
 sending a message an Exception occurs, as no connection, but messages
 are still placed in outbound queue up until the Sender is flushed
 ('window < Capacity/4' , not sure where the 4 comes from). At this point
 any further sent messages still cause an exception, but messages do not
 get placed in the outbound queue. Varying the capacity varies when this
 occurs and so doesn't seem correct.
"
Bug,QPID-5866,12724925,[C++ client] AMQP 1.0 closing session without closing receiver first marks further messages as redelivered,pmoravec,pmoravec,Closed,Fixed,2015-06-06 14:50,C++,C++ Client,,,,,,,"Having a C++ AMQP 1.0 consumer with prefetch and closing its session without closing receiver first, the client does not send back to the broker disposition about unconsumed messages (that were buffered by the client due to prefetch but not offered to the application).

This causes next consumer to get messages with redelivered flag enabled / delivery count incremented.

Reproducer:

{code}
$ qpid-send --messages 3 --address ""q;{create:sender}""

$ qpid-receive --connection-options {protocol:amqp1.0} --print-headers true --messages 1 --address q
Properties: {sn:1, ts:1395841514445073615}

$ qpid-receive --connection-options {protocol:amqp1.0} --print-headers true --messages 1 --address q
Redelivered: true
Properties: {sn:2, ts:1395841514445244860, x-amqp-delivery-count:1}

$
{code}"
Bug,QPID-6013,12734795,qpid-route shall warn that federation link hasn't been created,eallen,eallen,Closed,Fixed,2015-03-19 12:23,C++,C++ Tools,,,,,,,"When creating a federation route between two brokers where the underlying link isn't created properly (due to networking issue or due to failed authentication), qpid-route command shall warn about it. Otherwise users don't know the command hasn't fully succeeded.
"
Bug,QPID-6273,12762274,client/server example doesn't use content-object,gsim,gsim,Closed,Fixed,2015-03-19 12:22,C++,C++ Client,,,,,,,Thus the requests and responses are sent as binary data rather than textual strings.
Bug,QPID-5860,12724232,Sender lock held when invoking on Session,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,"On Sender::close(), the sender lock is held while calling out to SessionImpl::senderCancelled(). The lock should be released for that call."
Bug,QPID-5848,12723631,Update doxygen for connection options,gsim,gsim,Closed,Fixed,2014-09-26 15:43,C++,C++ Client,,,,,,,Several are missing (particularly new AMQP 1.0 ones) and the support under AMQP 1.0 isn't clear.
Bug,QPID-5959,12731762,[AMQP 1.0] can't read content encoding on received message,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"Though x-amqp-content-encoding can be used as a pseudo-property for setting the value on an outgoing message, the same name does not work as a way of reading the value contained on a received message."
Bug,QPID-5394,12682770,Qpid cpp build always builds swig python binding code even when not necessary,astitcher,astitcher,Closed,Fixed,2014-06-03 15:35,C++,C++ Build,,,,,,,"It is very annoying that it is impossible to get a ""clean"" no op build when there is really nothing to build.

There appears to be  an incorrect dependency somewhere in the build chain for the swig produced binding code for python which makes that code be produced every build."
Bug,QPID-5609,12699387,QPID fails to compile in C++11 with Boost 1.54 ,,andyrobo60,Closed,Fixed,2014-04-02 21:40,C++,C++ Broker,C++ Client,,,,,,"QPID fails to compile with GCC 4.8.2 and Boost 1.54 in C+\+11 using the compiler flag ""-std=c++11"". 

This problem is caused by a change to Boost's shared_ptr. When compiling in c+\+11 the shared_pointer interface is changed to match c++11's std::shared_pointer. This causes the boolean conversion operator to be made explicit, preventing the implicit conversion to a boolean when returning a shared_ptr from a function. 

To get QPID to compile with GCC 4.8.2 and C+\+11 extra compiler flags are needed. After running CMake modify the CMakeCache.txt file and set the variable ""CMAKE_CXX_FLAGS"" to ""-std=c+\+11 -Wno-unused-local-typedefs -Wno-ignored-qualifiers -Wno-deprecated-declarations"". Passing the variable to CMake on the command line can cause problems as CMake doesn't like the '=' in the flag ""-std=c+\+11""."
Bug,QPID-5233,12673856,[AMQP 1.0] default sender capacity for 1.0 is different from that for 0-10,gsim,gsim,Closed,Fixed,2014-02-19 11:30,C++,C++ Client,,,,,,,consistency is always preferable
Bug,QPID-5304,12677898,Unit test program has bad failure mode if XML_LIB is not set,astitcher,astitcher,Closed,Fixed,2014-02-19 11:30,C++,C++ Broker,C++ Client,,,,,,"If you have built the xml exchange, then it is impossible to just run the unit test program manually without at least setting XML_LIB as the program will abort very early on.

This is particularly annoying if you just want to test something unrelated quickly."
Bug,QPID-5143,12669292,default url shouldn't specify transport,gsim,gsim,Closed,Fixed,2014-02-19 11:29,C++,C++ Client,,,,,,,"The default url if none is specified is amqp:tcp:127.0.0.1 (this is also the default for qpid-send and qpid-receive, though not for the drain and spout examples). However since the transport specified in the 0-10 format url overrides the connection option, this means that simply specifying e.g. {transport:ssl} as the connection options gets ignored and TCP is used."
Bug,QPID-4407,12614319,default implementation of SASL does not check that mechanism is correct,gsim,gsim,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,"i.e. when cyrus-sasl support is not built in, the mechanism will be sent as taken from configuration even if that is null or something not supported by the broker."
Bug,QPID-4801,12645671,No error reported on failure to open a configuration file,mcpierce,mcpierce,Closed,Fixed,2013-09-08 13:37,C++,C++ Client,,,,,,,A critical example of this is when a client app attempts to connect to the broker using SSL. If the qpidc.conf file is unreadable (the file permissions deny reading) then the Connection attempts to connect and fails. But rather than reporting the cause of the failure (that it was unable to load the connection configuration) it just repeatedly attempts to establish the connection.
Bug,QPID-3660,12533935,"qpid-stat -c columns for ""msgIn"" and ""msgOut"" actually display frames, not messages",tross,tross,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"The stats displayed in the msgIn and msgOut columns for qpid-stat -c show the frame counters, not the message counters."
Bug,QPID-3100,12500175,Excessive memory use per-connection,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,Due to unnecessarily high number of buffers created initially
Bug,QPID-2302,12444044,"Missing header.html, footer.html in C++ docs/api distribution",shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"In a C++ source distribution, the cpp/docs/api/header.html and footer.html files are missing. This prohibits generating the doxygen docs."
Bug,QPID-4175,12600704,HA code rationalize logging,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"Clean up and rationalize log messages and levels.

notice: Major broker-level events: connecting, failing-over, primary active, backup ready.
info: Major queue level events: subscriptions ready, replicators created etc.
debug: Detailed replication events: accept/reject conections, details of queue replication protocol.
trace: dumping raw QMF messages
"
Bug,QPID-3169,12502322,qpid-route tool should output usage info if bad/unknown command entered.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"qpid-route silently fails if the command argument is not recognized.

example:

$ qpid-route snoopdog localhost:5671
$ ## nothing printed out, just returns
Or, even worse:

$ qpid-route map localhost:5671
$ ## I feel stoopid - I just wasted time trying to debug my federation because no map was shown
$ ## the actual command is ""qpid-route route map""
"
Bug,QPID-3129,12500779,cluster_tests.LongTests.test_failover hangs ,aconway,aconway,Closed,Fixed,2013-07-29 18:54,C++,C++ Clustering,,,,,,,"The test cluster_tests.LongTests.test_failover hangs if run with duration of a minute or more.

To reproduce:
  make check TESTS=run_cluster_tests CLUSTER_TESTS='cluster_tests.LongTests.test_failover -DDURATION=1'

Should pass after about 1 minute, but hangs indefinitely.

This is probably a test bug."
Bug,QPID-1745,12417105,C++ Windows; IntegerTypes.h need not define size_t,shuston,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"The qpid/cpp/src/qpid/sys/windows/IntegerTypes.h file typedefs size_t. This is not necessary for VC9, and the definition conflicts with the proper def for 64-bit builds. Removing the typedef for size_t works for both 32- and 64-bit builds."
Bug,QPID-2768,12470320,Address with '/' after name but no subject results in parsing error,gsim,gsim,Closed,Fixed,2013-07-29 18:54,C++,C++ Client,,,,,,,"e.g. $ spout 'exchange/'
Expected subject after /, character 9 of exchange/

Should instead simply treat this as implying no subject (i.e. being equivalent to 'exchange')
"
Bug,QPID-3282,12508470,Potential bug when checking socket connections for identical local and remote endpoint,astitcher,astitcher,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Currently there is a check in Socket::connect that tries to make sure we don't try to connect to the same endpoint that the local end is bound to, this can happen in rare circumstances when connecting to localhost when the OS decides to bind the local end to a port that has just been given up by an exiting application that we are just about to retry connecting to.

However the existing test doesn't canonicalise the endpoint names so it might try to do a string compare of ""localhost:1234"" with ""127.0.0.1:1234"" and fail even though it should succeed."
Bug,QPID-3035,12497573,Removing a sequence number from a SequenceSet can corrupt the sequence.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Given a SequenceSet with disjoint sub-sequences, deleting from the end of one sequence will corrupt a following sequence (if present).  

Example - given the following sequence:

{[1,6] [10,20]}

deleting the sequence ""6"" will result in the following:

{[1,5] [7,20]}

the trailing subsequence now incorrectly includes 7-9."
Bug,QPID-3757,12538329,Difficult recovery on broker death,gsim,rspringer,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"When using the old API (which might render this bug as invalid, if the old API is completely deprecated), if the broker dies, it's not possible to recover Subscription and LocalQueue variables unless you follow a precise workaround procedure.  

The problem is:
   If the broker dies and is then respawned, if one attempts to reconnect to the new broker and doesn't create a new Session (i.e., use the old one), bad things happen (since Session doesn't yet support resume(), I assume that's expected behavior).
   If, however, one tries to create new Session, new SubscriptionManager, and new Subscription objects, an assertion failure is generated (backtrace attached).
   After reading the backtrace, I believe the following is happening:
1) In recovery, we attempt to assign a new Subscription to the previous Subscription variable (i.e., ""sub = subMgr->subscribe()"")
2) That causes the refcount for the old Subscription to fall to 0, causing it to be cleaned up.
3) As part of that cleanup, the associated SubscriptionImpl object goes to destroy its (std::auto_ptr<ScopedDivert>) demuxRule member.
4) That demuxRule member maintains a reference to a Demux object, demuxer, which exists inside the Session object. Since the Session object has been re-created, that old reference is invalid & results in the assertion.

Thus, we have a fatal circle - we need to create a new Session object to be able to proceed, but when we do so, we render ourselves unable to re-use Subscription variables.

Gordon proposed a workaround which does solve the problem for me, in practice, and that is to assign ""null"" Subscription and LocalQueue objects to those variables before re-creating the Session object. Unfortunately, this won't be clear to any new users, so if anyone is still using the old API, they might be likely to encounter it.

I'll attach an example showing the problem and the fix as well as snippets from my backtrace shortly."
Bug,QPID-3147,12501489,Misconfigured tracing/logging can lead to hung threads in logging stack,aconway,pmackinn,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Given the following trace and logging environment variable mix-up like this:

QPID_TRACE=debug+
QPID_LOG_ENABLE=

A C++ client that embeds the Qpid runtime can get hung although it has recognized the misconfiguration.

#0  0x00555416 in __kernel_vsyscall ()
#1  0x00f49367 in syscall () at ../sysdeps/unix/sysv/linux/i386/syscall.S:30
#2  0x002bbfca in __cxxabiv1::__cxa_guard_acquire (g=0x2171ea0)
    at ../../../../libstdc++-v3/libsupc++/guard.cc:293
#3  0x020ca3b8 in instance ()
    at /usr/include/boost/pool/detail/singleton.hpp:83
#4  qpid::log::Logger::instance () at qpid/log/Logger.cpp:47
#5  0x020cd324 in qpid::log::Statement::Initializer::Initializer (
    this=0x2171b88, s=...) at qpid/log/Statement.cpp:61
#6  0x02075b6c in qpid::Exception::Exception (this=0x880b370, msg=
    ""Error in environment variables: in option 'trace': invalid bool value\n"")
    at qpid/Exception.cpp:31
#7  0x0208095d in Exception (this=0xbf8d0df0, argc=0, argv=0x0, configFile="""", 
    allowUnknown=false) at ../include/qpid/Options.h:210
#8  qpid::Options::parse (this=0xbf8d0df0, argc=0, argv=0x0, configFile="""", 
    allowUnknown=false) at qpid/Options.cpp:352
#9  0x020c9c57 in qpid::log::Logger::Logger (this=0x2171ec0)
    at qpid/log/Logger.cpp:55
#10 0x020ca330 in instance ()
    at /usr/include/boost/pool/detail/singleton.hpp:83
#11 object_creator () at /usr/include/boost/pool/detail/singleton.hpp:66
#12 __static_initialization_and_destruction_0 ()
    at /usr/include/boost/pool/detail/singleton.hpp:95
#13 global constructors keyed to Logger.cpp(void) () at qpid/log/Logger.cpp:156
#14 0x020ebc6d in __do_global_ctors_aux () from /usr/lib/libqpidcommon.so.2
#15 0x01fc2a84 in _init () from /usr/lib/libqpidcommon.so.2
#16 0x004f68fc in call_init (l=<value optimized out>, argc=3, argv=0xbf8d1634, 
    env=0x87feb58) at dl-init.c:68
#17 0x004f6a19 in _dl_init (main_map=<value optimized out>, argc=3, 
    argv=0xbf8d1634, env=0x87feb58) at dl-init.c:132
#18 0x004fa74f in dl_open_worker (a=0xbf8d10d0) at dl-open.c:464
#19 0x004f6786 in _dl_catch_error (objname=0xbf8d10f8, errstring=0xbf8d10f4, 
    mallocedp=0xbf8d10ff, operate=0x4fa3b0 <dl_open_worker>, args=0xbf8d10d0)
    at dl-error.c:178"
Bug,QPID-4155,12599513,qpid-stat fails while trying to display queue names that have non-ascii characters,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"If a queue (or exchange) is created with a name that contains non-ascii characters, qpid-stat will error out while attempting to display the list of queues or exchanges."
Bug,QPID-3533,12526339,qpid-config does not properly set some options if value evaluates to False,nsantos,bpedman,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"PROBLEM STATEMENT:
Some options with the qpid-config tool ignore options which evaluate to False, most  notably a value of 0. In my case I was trying to set the flow-stop-count to 0 as described here: http://qpid.apache.org/books/0.12/AMQP-Messaging-Broker-CPP-Book/html/ch01s09.html to disable the flow control.

STEPS TO REPRODUCE:
- Add a queue using the following options:
qpid-config add queue myqueue --max-queue-count=5 --limit-policy=flow-to-disk --flow-stop-count=0
- Generate at least 5 messages that will go on myqueue

RESULTS:
Generating the 5th message will hang, waiting for the queue count to go less than 4

EXPECTED RESULTS:
Messages should continue to flow onto the queue (and be flushed to the disk)

COMMENTS:
The reason this happens is because the flow stop count is never set by qpid-config. There are several options that share the same issue in qpid-config. I created a patch that fixes this issue for me and will attach it."
Bug,QPID-3082,12499493,Add qmf-tool to the qpid/tools/setup.py distribution file.,kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,Packaging,,,,,,Need to update the setup script to include new qmf-tool command line tool.
Bug,QPID-4082,12595387,cluster de-sync after broker restart & queue replication,aconway,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"Description of problem:
Having queue state replication between 2 clusters, restarting _a_ broker in both source+destination clusters sometimes leads to cluster de-sync. No QMF communication is involved, though symptoms are similar to the bug caused by missing propagation of QMF errors within a cluster.


Version-Release number of selected component (if applicable):
spotted in qpid 0.14, expected also in 0.16


How reproducible:
100% within 10 minutes.


Steps to Reproduce:
1. Have 2node src. cluster and 2node dst cluster (see reproducer for example config and also for a reproducer script for further steps).
2. Have a queue state replication between the clusters.
3. Randomly stop or start a broker in a cluster (such that everytime both clusters have at least 1 node running - i.e. stop+start only non-elder brokers)
4. After each stop or start, send 1 message to the src.broker to a queue to be replicated.
5. Wait some time

  
Actual results:
The started-up broker in src.cluster may shutdown after logging:
2012-05-31 11:58:40 critical cluster(10.34.1.218:26715 READY/error) local error 502 did not occur on member 10.34.1.218:26294: invalid-argument: anonymous.b941dd87-3fa1-442d-99f7-8c0907599b30: confirmed < (24+0) but only sent < (23+0) (qpid/SessionState.cpp:154)


Expected results:
No such error

Additional info:
- the affected session is always federation route for the queue state replication
- the stop and start of both one src and one dst broker is essential in the scenario, e.g. without (re)starting a dst.broker, no error.
- sometimes almost deterministic scenario is:
1) start everything, send a message
2) stop a dst.broker, send a message
3) stop a src.broker, send a message
4) start src.broker, then dst.broker
5) wait some time (i.e. 10 seconds) and send a message
Sometimes I got instantly the error, sometimes never.


Patch to be proposed."
Bug,QPID-1068,12396261,C++ configure fails if help2man not present,astitcher,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Recent email suggested that help2man is not really a requirement for configuring/building the C++ code, and if it's not present, the man pages should not be generated. However, if help2man is  not present, the configure fails. This patch fixes that - if help2man is not present, the docs/man directory is not built."
Bug,QPID-557,12376706,Clean  up all avoidable valgrind issues ,,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid/cpp/src/tests/.valgrind.supp-default suppresses a bunch of leaks and other errors. They appear to be harmless but most can probably be avoided by minor rework of the code. Clean up all the avoidable issues and trim the suppressions file down to the bare minimum of unavodiable errors harmless error reports, annotate each error remaining with comments explaining why it is harmless.
"
Bug,QPID-1993,12430897,"Solved the ""ignoring return value"" error",gsim,chenta,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"Every time I get the latest source code from the repository. The compiler always complain about ignoring return value. 
The original trick to suppress this warning seems ok. But maybe the recent version of gcc doesn't accept this trick anymore. So I decide to use a temporary variable to handle this problem."
Bug,QPID-3268,12507857,Incorrect syntax reported for connection options in drain and spout examples,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,i.e. listed as {name=value} rather than {name:value} as it should be.
Bug,QPID-4595,12633567,Invoking Receiver::fetch() in a loop for slow producer causes only first <prefetch> messages received,gsim,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Description of problem:
Having a scenario with a slow producer and a consumer periodically running Receiver::fetch() method (for timeout lesser than forever), the consumer gets just first N messages where N is the size of prefetch / capacity, and then nothing - despite there are new messages on the broker.


Version-Release number of selected component (if applicable):
qpid-cpp-client*-0.18-14


How reproducible:
100%


Steps to Reproduce:
1. Unpack attached tarball
2. make
3. in one terminal, create queue and start producer (that waits 15 seconds to kick-off consumer first):
./setup
4. in another terminal, start consumer:
./read

  
Actual results:
When producer starts to produce messages, the consumer gets just first 10 messages (or whatever is set in receiver.setCapacity()). Later on, despite there are new messages in the queue, receiver does not get any.


Expected results:
Receiver gets further messages when some occurr on the broker.


Additional info:
Patch proposed"
Bug,QPID-3638,12532354,incompatibility with new boost version 1.48,tross,nsantos,Closed,Fixed,2013-07-29 18:53,C++,C++ Broker,C++ Client,,,,,,"qpid/log/Logger.cpp:26:43: fatal error: boost/pool/detail/singleton.hpp: No such file or directory

Looks like the code under boost/pool has been re-organized in version 1.48, and that file no longer exists."
Bug,QPID-3045,12498005,Sporadic failure of cluster_tests.ShortTests.test_route_update  ,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"See https://bugzilla.redhat.com/show_bug.cgi?id=675921
"
Bug,QPID-4043,12559533,The cluster code (c++ broker) uses deprecated CPG definitions,tross,tross,Closed,Fixed,2013-07-29 18:53,C++,C++ Clustering,,,,,,,"The clustering code uses deprecated definitions from the corosync/cpg.h header file.  These definitions are removed in Corosync 2.0.  As a result, Qpid does not build against Corosync 2.0 (included in Linux distributions like Fedora 17).
"
Bug,QPID-1156,12399124,Compile warning re casts in cpp/src/qpid/framing/Blob.h,gsim,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Building the C++ tests (make check) there's a compile warning that gets promoted to an error:

../../src/qpid/framing/Blob.h:141:   instantiated from `qpid::framing::Blob<Size, BaseType>::Blob(const qpid::framing::Blob<Size, BaseType>&) [with unsigned int Size = 12u, BaseType = BlobTestSuite::Base]'
Blob.cpp:63:   instantiated from here
../../src/qpid/framing/Blob.h:132: warning: cast from `const qpid::framing::Blob<12u, BlobTestSuite::Base>*' to `char*' discards qualifiers from pointer target type

The attached patch resolves this issue.
"
Bug,QPID-562,12377379,Qpid C++ client appears to send heartbeats unnecessarily,gsim,rgreig,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"When running the topictest that comes with the C++ codebase, with -trace set, I see a lot of heartbeats being sent:

SENT: Frame[channel=0; heartbeat]

This is during periods of high activity where I do not expect to see them."
Bug,QPID-550,12375911,No constant for fanout exchange in ClientExchange.h,,jonathan.robie,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"There is no constant for fanout in ClientExchange.h. This should be added. I installed using http://rhm.et.redhat.com/download/qpidc-devel-0.1-5.M2.i386.rpm.

I haven't checked whether this is defined in later versions."
Bug,QPID-3049,12498389,qpid-send --durable does not send durable messages.,aconway,aconway,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,The qpid-send test client with argument --durable only sends the first message as durable. Subsequent messages are not durable.
Bug,QPID-3578,12529934,qpid-queue-stats doesn't support multiple filters (despite --help saying it does),,ncdc,Closed,Fixed,2013-07-29 18:53,C++,C++ Tools,,,,,,,"Trying to use multiple filters with qpid-queue-stats does not work due to an indentation issue in the Python code.  For example:

{noformat}
qpid-queue-stats -f ""a.*,b.*""
{noformat}

will only find queues matching the a.* pattern.

The issue is that if the first pattern fails, instead of trying all additional patterns, execution stops.  This is because the check to see if all matches failed is indented one level too far to the right.  As a result, this check executes inside the for loop, instead of outside.  The diff below fixes the issue:

{noformat}
diff --git a/qpid/tools/src/py/qpid-queue-stats b/qpid/tools/src/py/qpid-queue-stats
index 54f22df..562ccce 100755
--- a/qpid/tools/src/py/qpid-queue-stats
+++ b/qpid/tools/src/py/qpid-queue-stats
@@ -84,8 +84,8 @@ class BrokerManager(Console):
         if x.match(name):                 
           match = True
           break
-        if match == False:
-          return
+      if match == False:
+        return
 
     if last == None:
       lastSample = first
{noformat}"
Bug,QPID-1155,12399122,Compile warning re casts in cpp/src/tests/InlineVector.cpp,gsim,shuston,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"There's a compile warning in cpp/src/tests/InlineVector.cpp that build settings convert to an error:

InlineVector.cpp: In function `bool InlineVectorTestSuite::isInline(const InlineVectorTestSuite::Vec&)':
InlineVector.cpp:33: warning: cast from `const InlineVectorTestSuite::Vec*' to `char*' discards qualifiers from pointer target type
InlineVector.cpp:33: warning: cast from `const int*' to `char*' discards qualifiers from pointer target type
InlineVector.cpp:34: warning: cast from `const int*' to `char*' discards qualifiers from pointer target type
InlineVector.cpp:34: warning: cast from `const InlineVectorTestSuite::Vec*' to `char*' discards qualifiers from pointer target type

The attached patch fixes this issue."
Bug,QPID-4669,12639142,require proton 0.3 or greater,gsim,gsim,Closed,Fixed,2013-07-29 18:52,C++,C++ Broker,C++ Client,,,,,,0.2 is too out of date and qpidc won't compile against it.
Bug,QPID-1051,12395847,The C++ examples contain some typos and other mistakes that will confuse users. These are usability errors,aconway,whenry,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"There are a few residual usability errors that seem to be the result of copying examples over and not cleaning up. None of these bugs stop the code from compiling or running but would cause usability problems for new users that are looking at the examples as templates on how to use qpid.

E.g.

Several files declare unused Message instances:

Message message;

Some files headers contain erroneous information. Either mentioning non-existent files or using incorrect names.

I will attach some diff files that show the bugs in the code.

request_response/server.cpp  - declares a Message instance called message but doesn't use it.
pub-sub/topic_listener.cpp = mentions  topic_config_queues.cpp in the header but there is no such file.
pub-sub/topic_publisher.cpp = mentions  topic_config_queues.cpp in the header but there is no such file. Message is declared and unused.
fanout/listener.cpp - minor typo 'fro' for 'from' in header and Message declared and unused
fanout/producer.cpp -  declare_queues.cpp mentioned in header and Message declared twice. One in try block is used.
direct/declare_queues.cpp - named incorrectly as define_config_queues.cpp in header. Message declared and unused
direct/lisener.cpp- minor typo 'fro'  for 'from' in header . Message declared and unused


"
Bug,QPID-4537,12627484,qpid-stat: fix undefined name error,tross,zhigang,Closed,Fixed,2013-07-29 18:52,C++,C++ Tools,,,,,,,"qpid/tools/src/py/qpid-stat should use self.connection instead of connection:

Traceback (most recent call last):
  File ""./qpid-stat"", line 568, in <module>
    sys.exit(main())
  File ""./qpid-stat"", line 564, in main
    bm.Disconnect()   # try to deallocate brokers
  File ""./qpid-stat"", line 158, in Disconnect
    connection.close()
NameError: global name 'connection' is not defined
"
Bug,QPID-117,12356194,C++ code won't build on Ubuntu due to assumptions about where apr headers live,aconway,astitcher,Closed,Fixed,2013-07-29 15:15,C++,C++ Broker,C++ Client,,,,,,"The C++ code includes apr headers using ""apr-1/apr_..."" this doesn't generally work as the spr headers need not be in a subdirectory called this. Indeed under Ubuntu they are in a directory called apr-1.0.

The solution is to follow the normal include usage for apr and just include ""apr_,,,""."
Bug,QPID-296,12360537,C++ Header guards may not be compliant with C++ standard,kpvdr,astitcher,Closed,Fixed,2013-07-29 13:58,C++,C++ Broker,C++ Client,,,,,,"According to the C++ standard symbols that have a single ""_"" followed by an uppercase
letter and symbols starting with ""__"" (double underscore are reserved for the implementer (That is usually the
compiler/library writer). 

There are numerous header files with guards that violate this standard in the C++ source base."
Bug,QPID-3737,12537869,Patch to make qpid-stat -L option work,tross,pcolby,Closed,Fixed,2012-05-18 1:47,C++,C++ Tools,,,,,,,"Current behaviour:

{code}
qpid -qIS queue         // Shows up to 50 queues.
qpid -qIS queue -L 0    // Shows as many queues as possible (ie no limit).
qpid -qIS queue -L 1    // Shows as many queues as possible (ie no limit).
qpid -qIS queue -L 10   // Shows as many queues as possible (ie no limit).
qpid -qIS queue -L 100  // Shows as many queues as possible (ie no limit).
qpid -qIS queue -L blah // Shows as many queues as possible (ie no limit).
{code}

This happens because:
# the default limit is 50, and
# the limit argument is read as a string, but compared to an int in the Sorter constructor - a comparison that always fails.

Behaviour after the near-trivial attached patch:
{code}
qpid -qIS queue         // Shows up to 50 queues.
qpid -qIS queue -L 0    // Shows as many queues as possible (ie no limit).
qpid -qIS queue -L 1    // Shows up to 1 queue.
qpid -qIS queue -L 10   // Shows up to 10 queues.
qpid -qIS queue -L 100  // Shows up to 100 queues.
qpid -qIS queue -L blah // qpid-stat: error: option -L: invalid integer value: 'foo'
{code}

I'll attach the patch, but's for the impatient ;)

{code}
Index: qpid-stat
===================================================================
--- qpid-stat   (revision 1229483)
+++ qpid-stat   (working copy)
@@ -70,7 +70,7 @@
                   help=""Sort by column name"")
     group2.add_option(""-I"", ""--increasing"", action=""store_true"", default=False,
                   help=""Sort by increasing value (default = decreasing)"")
-    group2.add_option(""-L"", ""--limit"", default=50, metavar=""<n>"",
+    group2.add_option(""-L"", ""--limit"", type=""int"", default=50, metavar=""<n>"",
                   help=""Limit output to n rows"")
     group2.add_option(""-C"", ""--cluster"", action=""store_true"", default=False,
                   help=""Display per-broker cluster detail."")
{code}"
Bug,QPID-3442,12519632,qpid-tool schema descriptions repeated / duplicated,tross,pcolby,Closed,Fixed,2012-03-03 14:39,C++,C++ Tools,,,,,,,"It seems that when qpid-tool displays a schema element with no description, it repeats the previous element's description (if any) instead.

For example:
{code}
qpid: schema connection
Object Class: Table Class: org.apache.qpid.broker:connection:_data(1cb21a64-b290-c47d-40bc-5ea42cffd7c7)
    Element            Type          Access      Unit  Notes      Description
    =================================================================================================================================
    vhostRef           reference     ReadCreate        index
    address            short-string  ReadCreate        index
    incoming           boolean       ReadCreate
    SystemConnection   boolean       ReadCreate                   Infrastucture/ Inter-system connection (Cluster, Federation, ...)
    federationLink     boolean       ReadOnly                     Is this a federation link
    authIdentity       short-string  ReadOnly                     authId of connection if authentication enabled
    remoteProcessName  long-string   ReadOnly          optional   Name of executable running as remote client
    remotePid          uint32        ReadOnly          optional   Process ID of remote client
    remoteParentPid    uint32        ReadOnly          optional   Parent Process ID of remote client
    shadow             boolean       ReadOnly                     True for shadow connections
    closing            boolean                                    True for shadow connections
    framesFromClient   uint64                                     True for shadow connections
    framesToClient     uint64                                     True for shadow connections
    bytesFromClient    uint64                                     True for shadow connections
    bytesToClient      uint64                                     True for shadow connections
    msgsFromClient     uint64                                     True for shadow connections
    msgsToClient       uint64                                     True for shadow connections

  Method: close
qpid:
{code}

If this example, you can see that the {{shadow}} element's description (""{{True for shadow connections}}"") has been repeated for all elements after it."
Bug,QPID-6106,12742161,"Replace empty fields with ""unknown"" in qpid-stat -c output ",jross,iboverma,Closed,Fixed,2019-10-02 17:34,C++,C++ Client,,,,,,,"""qpid-stat"" tool with ""-c"" option does not show a name of connected client from Windows machine. 

When the drain client is connected to the broker from a Linux machine, the name of the client is displayed correctly:

# qpid-stat -c
Connections
  connection                                 cproc      cpid   mech  auth       connected  idle  msgIn  msgOut
  ==============================================================================================================
  qpid.10.34.33.251:5672-10.34.33.199:57589  drain      3735         anonymous  2s         0s       0      0
  qpid.[::1]:5672-[::1]:60305                qpid-stat  11814        anonymous  0s         0s       1      0

-------------------------------------------------------------------------------

However if the drain client is connected from a Windows machine,the ""cproc"" column is empty:

# qpid-stat -c
Connections
  connection                                cproc      cpid   mech  auth       connected  idle  msgIn  msgOut
  =============================================================================================================
  qpid.10.34.33.251:5672-10.34.74.82:57245             1456                    1s         0s       0      0
  qpid.[::1]:5672-[::1]:60306               qpid-stat  11843        anonymous  0s         0s       1      0
"
Bug,QPID-4808,12645825,qpid messaging cpp client api documentation update,gsim,pematous,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,"The qpid::messaging::Connection Class Reference was recently changed, now the documentation lists 'sasl-mechanism' connection option, even if this form is supported as well the documentation should stick to 'sasl_mechanisms'.

There was also a new 'protocol' connection  option recently added, the documentation shall mention this option. "
Bug,QPID-3258,12507217,Doxygen docs for qmf::engine have QMFE_EXTERN showing in the output,shuston,shuston,Closed,Fixed,2017-03-13 11:49,C++,C++ Documentation,,,,,,,The generated doxygen docs for qmf::engine have QMFE_EXTERN showing in the output. It shouldn't be there.
Bug,QPID-3938,12549766,qmf-tool fails to create connection against updated Python wrapper,tross,tross,Closed,Fixed,2017-03-12 14:06,C++,C++ Tools,,,,,,,"The changes made to the wrapped Python client (to make it drop-in compatible with the pure Python client) caused an API change that broke qmf-tool.  A trivial change is needed to fix it.
"
Bug,QPID-3078,12499275,"qpid-receive's use of the ""-t"" option is ambiguous and will cause the command to fail.",kgiusti,kgiusti,Closed,Fixed,2017-03-12 14:06,C++,C++ Client,C++ Tools,,,,,,The '-t' short option for 'timeout' conflicts with the same short version of the 'trace' option.
Bug,QPID-5597,12698630,[C++ client] Topic subscriptions should not ignore auto-delete x-declare flag,pmoravec,pmoravec,Closed,Fixed,2015-01-19 14:13,C++,C++ Client,,,,,,,"Description of problem:
As Python client allows, C++ client should also take into account auto-delete x-declare option when declaring topic subscription.


Version-Release number of selected component (if applicable):
0.24 (and current upstream)


How reproducible:
100%


Steps to Reproduce:
qpid-receive -a ""amq.direct/#; {link: {x-declare:{'auto-delete':False}}}"" -m 1 --print-content=no -f &
qpid-stat -q | egrep '(queue|=|direct)'


Actual results:
  queue                                            dur  autoDel  excl  msg   msgIn  msgOut  bytes  bytesIn  bytesOut  cons  bind
  ================================================================================================================================
  amq.direct_19c89381-ace4-4871-85d6-c87f4462999a       Y        Y        0     0      0       0      0        0         1     2

(see the auxiliary subscription queue is auto-delete, despite we set it otherwise)


Expected results:
(non-auto-delete queue created)


Additional info:"
Bug,QPID-5708,12708850,Don't set address 'type' when both exchange and routing key are empty,gsim,gsim,Closed,Fixed,2014-09-26 15:42,C++,C++ Client,,,,,,,"In 0-10, if a reply-to on a message has the empty string as the exchange, the client will assume it refers to a queue and set the type on the address accordingly. However if the routing key is also the empty string, the type is meaningless and would be better avoided."
Bug,QPID-5797,12717903,[qpid-tools]: inability to call some QMF methods (queueMoveMessages / setLogLevel or so),pmoravec,pmoravec,Closed,Fixed,2014-06-04 8:24,C++,C++ Tools,,,,,,,"Some QMF methods in tools/src/py/qpidtoollibs/broker.py are either not declared or defined. In particular: queueMoveMessages, setLogLevel or queueRedirect."
Bug,QPID-5643,12703178,"""qpid-route route map"" does not pass credentials to other brokers in the ""route map""",pmoravec,pmoravec,Closed,Fixed,2014-03-24 13:01,C++,C++ Tools,,,,,,,"Tool qpid-route supports only ANONYMOUS sasl mech in method mapRoutes.

This results as (although both broker nodes are running with very same ACL rules and qpid.sasldb):

ExecutionException(error_code=403, command_id=serial(0), class_code=8, command_code=1, field_index=0, description=u'unauthorized-access: ACL denied queue create request from anonymous@QPID (qpid/broker/SessionAdapter.cpp:349)', error_info={}, channel=1, id=serial(0))

The reason is because when qpid-route queries subsequent brokers in the federation topology, it does not set any credentials (esp. those used for the first broker).

Trivial fix to follow just passes the credentials and other connection options to any further broker that the tool connects to."
Bug,QPID-5244,12674345,Remove old QMFv1 example agent,kgiusti,kgiusti,Closed,Fixed,2014-02-19 11:30,C++,C++ Examples,QMF,,,,,,The example QMF agent in cpp/examples/qmf-agent uses the old QMFv1 code that has been removed from the project.  
Bug,QPID-4744,12642601,qpid-tool does not allow separate keyfile for SSL connections,kgiusti,kgiusti,Closed,Fixed,2013-09-08 13:37,C++,C++ Tools,,,,,,,"All qpid tools support client-side authentication.  This is provided by two options to each command: --ssl-certificate and --ssl-keyfile.  The --ssl-certificate option specifies the client side certificate file (in PEM format).  If the certificate file does NOT contain the encrypted private key, then the --ssl-keyfile must be specified.  It provides for a separate file containing the encrypted private key (in PEM format).

qpid-tool does not support the separate keyfile option.
"
Bug,QPID-3584,12530283,qpid-config SPECIAL_ARGS list should include FLOW_RESUME_COUNT,tross,fadams,Closed,Fixed,2013-09-08 13:37,C++,C++ Tools,,,,,,,"qpid-config added a feature in 0.10 of a --argument option, a generic mechanism for passing arguments.

As part of the implementation of this constants relating to specific program options are contained in a list called SPECIAL_ARGS.

It looks like FLOW_RESUME_COUNT is missing from this list which causes an incorrect display with qpid-config queues e.g.

qpid-config add queue test0 --flow-resume-count=10

gives

test0 --flow-resume-count=10 --argument qpid.flow_resume_count=10

A trivial fix is to add FLOW_RESUME_COUNT to the SPECIAL_ARGS definition


"
Bug,QPID-4139,12598945,qpid-stat -b does not show broker names anymore,tross,pmoravec,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"qpid-stat -b does not show broker URL:

# qpid-stat -b
  Brokers
    broker  cluster       uptime  conn  sess  exch  queue
    =======================================================
    ?       <standalone>  5s         1     1     8     5
#

It is a regression since qpid 0.7 where the URL was shown.

A simple patch is to be proposed."
Bug,QPID-1069,12396267,Patch to build trunk with Boost 1.35,astitcher,shuston,Closed,Fixed,2013-07-29 18:54,C++,C++ Broker,C++ Client,,,,,,"Trunk C++ code fails to build with Boost 1.35 - there's a missing Boost feature prior to 1.35 that is now available. This patch allows C++ trunk code to build with Boost 1.35.
Index: Blob.h
===================================================================
--- Blob.h      (revision 657445)
+++ Blob.h      (working copy)
@@ -27,6 +27,7 @@
 #include <boost/utility/typed_in_place_factory.hpp>
 #include <boost/type_traits/is_base_and_derived.hpp>
 #include <boost/utility/enable_if.hpp>
+#include <boost/version.hpp>

 #include <new>

@@ -39,7 +40,8 @@
 using boost::in_place;
 using boost::typed_in_place_factory_base;

-/** 0-arg typed_in_place_factory, missing in boost. */
+/** 0-arg typed_in_place_factory, missing in pre-1.35 boost. */
+#if (BOOST_VERSION < 103500)
 template <class T>
 struct typed_in_place_factory0 : public typed_in_place_factory_base {
     typedef T value_type ;
@@ -49,6 +51,7 @@
 /** 0-arg in_place<T>() function, missing from boost. */
 template<class T>
 typed_in_place_factory0<T> in_place() { return typed_in_place_factory0<T>(); }
+#endif

 template <class T, class R=void>
 struct EnableInPlace
"
Bug,QPID-3564,12529490,"C++ test tools - message group validator (msg_group_test) incorrectly handles the ""no-senders"" and ""no-consumers"" scenarios.",kgiusti,kgiusti,Closed,Fixed,2013-07-29 18:54,C++,C++ Tools,,,,,,,"msg_group_test fails if used in a spout/drain pattern (e.g fill a queue, then drain it later).  Cannot specify --senders=0 nor --receivers=0 as options without the test hanging or failing.  This prevents testing some usage patterns."
Bug,QPID-1729,12416762,perftest doesn't check if connection has been closed due to error on shutdown,gsim,gsim,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"So you get e.g.:
 
  Error in shutdown: Connection closed
  Error in shutdown: Connection closed

where it tries to close a failed connection."
Bug,QPID-4576,12631696,qpid-receive does not commit ready address message,gsim,pmoravec,Closed,Fixed,2013-07-29 18:53,C++,C++ Client,,,,,,,"Description of problem:
Running qpid-benchmark with \-\-receive-arg=\-\-tx=10 option leads to timeout (see below for details). The reason is that qpid-receive does not commit its session after sending a message to ready address (see \-\-ready-address option).


Version-Release number of selected component (if applicable):
Any (also in upstream qpid 0.20)


How reproducible:
100%


Steps to Reproduce:
./qpid-benchmark \-\-receive-arg=\-\-tx=10

  
Actual results:
Traceback (most recent call last):
  File ""./qpid-benchmark"", line 330, in <module>
    if __name__ == ""__main__"": main()
  File ""./qpid-benchmark"", line 316, in main
    ready_receiver.wait(filter(None, receivers)) # Wait for receivers to be ready.
  File ""./qpid-benchmark"", line 269, in wait
    raise Exception(""Timed out waiting for receivers to be ready"")
Exception: Timed out waiting for receivers to be ready


Expected results:
No exception, proper run.


Additional info:
Patch proposed."
Bug,QPID-2548,12463002,Forgotten method on SubscriptionManager,gsim,fremmi,Closed,Fixed,2013-07-29 18:52,C++,C++ Client,,,,,,,"SubscriptionManager implementation has method SetDefaultSettings. But this is not present in the interface.

Patch to be applied:

Index: src/qpid/client/SubscriptionManager.cpp
===================================================================
--- src/qpid/client/SubscriptionManager.cpp     (revisione 822651)
+++ src/qpid/client/SubscriptionManager.cpp     (copia locale)
@@ -86,6 +86,10 @@
     impl->setFlowControl(name, flow);
 }

+void SubscriptionManager::setDefaultSettings(const SubscriptionSettings& s){
+       impl->setDefaultSettings(s);
+}
+
 void SubscriptionManager::setFlowControl(const std::string& name, uint32_t messages,  uint32_t bytes, bool window) {
     impl->setFlowControl(name, FlowControl(messages, bytes, window));
 }
"
Bug,QPID-3419,12518843,qpid-config --file-size parameter's help text uses incorrect units,tross,pcolby,Closed,Fixed,2012-03-03 14:39,C++,C++ Tools,,,,,,,"It seems to me, that the {{qpid-config --file-size}} parameter's help text uses incorrect units.  It shows:

bq. --file-size=<n>     File size in pages (64Kib/page)

which would indicate that 24-pages (the default) would yield 192KiB journal files (24 * 64 / 8).  But instead, the journal files I get are ~1.6MiB, which would suggest that the 64Kib is meant to be 64KiB (ie Kibibytes instead of Kibibits)."
Bug,QPID-2137,12437874,StringIndexOutOfBounds when formating Connection Message during failed systest run.,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"This problem occured during a run of systests in the AcknowledgeAfterFailoverOnmessageTest. The test failed with a concurrent modification exception. However prior to that a StringIndexOutOfBounds during client connection establishment occured
Then shortly afterwards a NullPointerException occured and repeated a number of times. 

Most likely what occured is the failed connection open was not correclty closed by mina and so the attempts to send on the socket resulted in the NPEs.

Then the ConcurrentModException occured potentially as a result of a new getConnection() being called asynchronously via the onMessage when the close() was being called.

Dispatcher-Channel-1 2009-10-12 16:25:36,694 ERROR [qpid.server.protocol.AMQPFastProtocolHandler] Exception caught inanonymous(17670761)(?, closing session explictly: java.lang.StringIndexOutOfBoundsException: String index out of range: 37
java.lang.StringIndexOutOfBoundsException: String index out of range: 37
	at java.lang.String.substring(String.java:1934)
	at java.text.MessageFormat.subformat(MessageFormat.java:1208)
	at java.text.MessageFormat.format(MessageFormat.java:836)
	at java.text.Format.format(Format.java:140)
	at org.apache.qpid.server.logging.messages.ConnectionMessages.CON_1001(ConnectionMessages.java:141)
"
Bug,QPID-1359,12406498,ConnectionTest.testClosedNofificationAndWriteToClosed throws ConnectionException: connect() aborted ,rhs,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,"This error came up on CC run:
	
org.apache.qpid.transport.ConnectionException: connect() aborted 
	at org.apache.qpid.transport.Connection.connect(Connection.java:191) 
	at org.apache.qpid.transport.ConnectionTest.connect(ConnectionTest.java:84) 
	at org.apache.qpid.transport.ConnectionTest.testClosedNotificationAndWriteToClosed(ConnectionTest.java:91)"
Bug,QPID-1397,12407163,ConnectionTest.testClosedNotificationAndWriteToClosed,rhs,ritchiem,Closed,Fixed,2008-12-17 20:36,Java,Java Common,,,,,,,"Summary:

Build system picked up the following error:

org.apache.qpid.transport.TransportException: sender is closed  
	at org.apache.qpid.transport.network.io.IoSender.send(IoSender.java:95)  
	at org.apache.qpid.transport.network.io.IoSender.send(IoSender.java:34)  
	at org.apache.qpid.transport.network.Disassembler.frame(Disassembler.java:111)  
	at org.apache.qpid.transport.network.Disassembler.fragment(Disassembler.java:144)  
	at org.apache.qpid.transport.network.Disassembler.method(Disassembler.java:225)  
	at org.apache.qpid.transport.network.Disassembler.control(Disassembler.java:164)  
	at org.apache.qpid.transport.network.Disassembler.control(Disassembler.java:48)  
	at org.apache.qpid.transport.Method.delegate(Method.java:127)  
	at org.apache.qpid.transport.network.Disassembler.send(Disassembler.java:80)  
	at org.apache.qpid.transport.network.Disassembler.send(Disassembler.java:48)  
	at org.apache.qpid.transport.Connection.send(Connection.java:274)  
	at org.apache.qpid.transport.Session.send(Session.java:383)  
	at org.apache.qpid.transport.Session.invoke(Session.java:471)  
	at org.apache.qpid.transport.SessionInvoker.sessionFlush(SessionInvoker.java:55)  
	at org.apache.qpid.transport.Session.invoke(Session.java:465)  
	at org.apache.qpid.transport.SessionInvoker.messageTransfer(SessionInvoker.java:75)  
	at org.apache.qpid.transport.Session.messageTransfer(Session.java:645)  
	at org.apache.qpid.transport.Session.messageTransfer(Session.java:655)  
	at org.apache.qpid.transport.ConnectionTest.send(ConnectionTest.java:119)  
	at org.apache.qpid.transport.ConnectionTest.testClosedNotificationAndWriteToClosed(ConnectionTest.java:152)


Full log attached to JIRA."
Bug,QPID-148,12357461,Field table values are not preserved.,ritchiem,ritchiem,Closed,Fixed,2008-07-07 10:50,Java,Java Common,,,,,,,"When a message is sent with a custom header property the received message has lost the custom property.

Not just custom properties all properties are affected see comments for explination"
Bug,QPID-248,12359805,field table type codes conflict with spec,rhs,rhs,Resolved,Fixed,2007-01-04 21:19,Java,Java Common,,,,,,,"The Java framing library uses it's own set of type codes for field table  values. Some of these are to support extra types not defined in the spec, but some of the conflict with the type codes defined in the spec, for example 'S' means longstr in the spec and unsighed short according to the java. This breaks interoperability with other AMQP implementations, e.g. the entire python interop test suite."
Bug,QPID-2438,12458432,Performance tests do not correctly populate the message with the given MessageSize,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:08,Java,Java Performance Tests,,,,,,,"The TestUtils class method createTestMessageOfSize does not actually create messages of the requested size. 
Requests for messages > 112 bytes will result in only 112 byte messages. Message size requests of less than 112 bytes will result in a message of up to 12Kbytes.

It can be fixed by either:
1) Fixing the erroneous div and mod calculations,
2) Replacing the complex for loops with a single for loop from 0 to size,
3) using an empty byte array : new byte[size].

"
Bug,QPID-2744,12469463,FieldTable throws a NullPointerException in setObjectProperty rather than expected AMQPInvalidClassException,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Common,,,,,,,"When a null object is passed to setObjectProperty in the FieldTable we should throw an AMQPInvalidClassException stating we need a primitive value.

However we do object.getClass() to show what we were given.. if object is null then we get a NPE.

This needs to be fixed so it doesn't NPE."
Bug,QPID-168,12358399,qpid-server.bat needs updated to support same arguments/features as qpid-server (via qpid-run) bash script,,marnie,Closed,Fixed,2017-03-14 20:01,Java,Java Common,,,,,,,"The qpid-server bash script passes it's arguments through to qpid-run, which allows various arguments and options to be set for such things as using external classpaths, setting options required for the management modules etc etc (long list !).

However, the qpid-server.bat script has not been kept in step and lags behind significantly in terms of features. It  needs to be udpated to support the same set of features that the qpid-run script provides. Note that QPID-14 is currently outstanding which would make updating the bat script easier to complete as it'd provide a list of features to match.

Note that it's been reported that the QPID_OPTS param is not picked up by the qpid-server.bat script. QPID_ARGS works ok, but only useful for passing options to the server's main class."
Bug,QPID-1152,12399094,JUnit toolkit does not compile,aidan,aidan,Closed,Fixed,2017-03-14 20:01,Java,Java Tests,,,,,,,Junit toolkit does not compile cleanly 
Bug,QPID-2725,12468652,Large quantities of documentation are duplicated ,,ritchiem,Closed,Fixed,2016-09-06 16:22,Java,Java Documentation,,,,,,,"The way we generated documentation has led us to duplicate a large amount of contents which will be hard to maintain.

This is because we have the ability to make 1 Book that includes all the documentation yet still make individual books.
The problem is in the 1 Book scenario we need to use the <part> tag for content and in the individual books we need <book>

The simple solution is to have the individual book include the <part> but we are not doing that, we are duplicating the code and in some cases we have an  IDENTICAL file checked in twice: Qpid-Book.xml and Book.xml I'm looking at you.
These individual books all have the same code as the files that don't have the -Book
src/AMQP-Messaging-Broker-CPP-Book.xml   src/Qpid-Compatibility-And-Interoperability-Book.xml
src/AMQP-Messaging-Broker-Java-Book.xml  

They need updated to import the non -Book version or we will end up with in consistent documentation.
"
Bug,QPID-5989,12733430,Maven build generates duplicate system test class files,macbean,kwall,Closed,Fixed,2019-10-02 19:21,Java,Java Tests,,,,,,,Running the test-comple shows that some classes with systest directories are being compiled twice.  This is causing problems for tools such as Sonar.
Bug,QPID-6865,12913645,[Java Perftest] Perftest failure on 0-9,rgodfrey,lorenz.quack,Resolved,Fixed,2019-10-02 19:21,Java,Java Performance Tests,,,,,,,"Perftest fail on draining the queues:
{noformat}
2015-11-17 09:05:38,826 ERROR [org.apache.qpid.disttest.ControllerRunner.main()] o.a.q.d.c.AbstractTestRunner Couldn't run test
org.apache.qpid.disttest.DistributedTestException: org.apache.qpid.disttest.DistributedTestException: Failed to drain queue:direct:///testQueue_2/testQueue_2?routingkey='testQueue_2'&durable='true'
	at org.apache.qpid.disttest.jms.QpidQueueCreator.deleteQueues(QpidQueueCreator.java:249) ~[classes/:na]
	at org.apache.qpid.disttest.jms.ControllerJmsDelegate.deleteQueues(ControllerJmsDelegate.java:268) ~[classes/:na]
	at org.apache.qpid.disttest.controller.AbstractTestRunner.deleteQueues(AbstractTestRunner.java:208) ~[classes/:na]
	at org.apache.qpid.disttest.controller.AbstractTestRunner.runParts(AbstractTestRunner.java:344) ~[classes/:na]
	at org.apache.qpid.disttest.controller.AbstractTestRunner.doIt(AbstractTestRunner.java:297) ~[classes/:na]
	at org.apache.qpid.disttest.controller.HillClimbingTestRunner.run(HillClimbingTestRunner.java:76) [classes/:na]
	at org.apache.qpid.disttest.controller.Controller.runAllTests(Controller.java:173) [classes/:na]
	at org.apache.qpid.disttest.ControllerRunner.runTest(ControllerRunner.java:211) [classes/:na]
	at org.apache.qpid.disttest.ControllerRunner.runTests(ControllerRunner.java:186) [classes/:na]
	at org.apache.qpid.disttest.ControllerRunner.runController(ControllerRunner.java:125) [classes/:na]
	at org.apache.qpid.disttest.ControllerRunner.main(ControllerRunner.java:102) [classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_60]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_60]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_60]
	at java.lang.reflect.Method.invoke(Method.java:497) ~[na:1.8.0_60]
	at org.codehaus.mojo.exec.ExecJavaMojo$1.run(ExecJavaMojo.java:293) [exec-maven-plugin-1.3.2.jar:na]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_60]
Caused by: org.apache.qpid.disttest.DistributedTestException: Failed to drain queue:direct:///testQueue_2/testQueue_2?routingkey='testQueue_2'&durable='true'
	at org.apache.qpid.disttest.jms.QpidQueueCreator.drainQueue(QpidQueueCreator.java:323) ~[classes/:na]
	at org.apache.qpid.disttest.jms.QpidQueueCreator.access$300(QpidQueueCreator.java:57) ~[classes/:na]
	at org.apache.qpid.disttest.jms.QpidQueueCreator$2.call(QpidQueueCreator.java:225) ~[classes/:na]
	at org.apache.qpid.disttest.jms.QpidQueueCreator$2.call(QpidQueueCreator.java:214) ~[classes/:na]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) ~[na:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) ~[na:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) ~[na:1.8.0_60]
	... 1 common frames omitted
Caused by: org.apache.qpid.disttest.DistributedTestException: Failed to query queue depth:direct:///testQueue_2/testQueue_2?routingkey='testQueue_2'&durable='true'
	at org.apache.qpid.disttest.jms.QpidQueueCreator.getQueueDepth(QpidQueueCreator.java:294) ~[classes/:na]
	at org.apache.qpid.disttest.jms.QpidQueueCreator.drainQueue(QpidQueueCreator.java:317) ~[classes/:na]
	... 7 common frames omitted
Caused by: org.apache.qpid.AMQTimeoutException: Server did not respond in a timely fashion
	at org.apache.qpid.client.util.BlockingWaiter.block(BlockingWaiter.java:170) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.protocol.BlockingMethodFrameListener.blockForFrame(BlockingMethodFrameListener.java:115) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQProtocolHandler.writeCommandFrameAndWaitForReply(AMQProtocolHandler.java:685) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:706) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:700) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8.sendExchangeBound(AMQSession_0_8.java:503) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8.access$100(AMQSession_0_8.java:71) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8$2.execute(AMQSession_0_8.java:459) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8$2.execute(AMQSession_0_8.java:456) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.failover.FailoverNoopSupport.execute(FailoverNoopSupport.java:67) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8.isBound(AMQSession_0_8.java:462) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession_0_8.requestQueueDepth(AMQSession_0_8.java:964) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession$9.execute(AMQSession.java:2807) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession$9.execute(AMQSession.java:2802) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.failover.FailoverNoopSupport.execute(FailoverNoopSupport.java:67) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession.getQueueDepth(AMQSession.java:2814) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.client.AMQSession.getQueueDepth(AMQSession.java:2786) ~[qpid-client-6.0.0-SNAPSHOT.jar:6.0.0-SNAPSHOT]
	at org.apache.qpid.disttest.jms.QpidQueueCreator.getQueueDepth(QpidQueueCreator.java:289) ~[classes/:na]
	... 8 common frames omitted
{noformat}
Full logs as attachments."
Bug,QPID-7301,12978180,[Java Client] [Java Broker] JMS Selector parsing will not fail if a valid selector is followed by invalid text,lorenz.quack,rgodfrey,Closed,Fixed,2019-10-02 19:20,Java,Java Common,,,,,,,"A JMS Selector which has a valid stem followed by invalid data will not cause a failure, and the selector will be parsed an executed as if only the valid stem were present.

For example the selector

{code}
a = 1 AMD  b = 2
{code}

will be treated as if the selector was

{code}
a = 1
{code}"
Bug,QPID-5764,12713861,[Java] add a note detailing the move to the Maven build for future releases,robbie,robbie,Closed,Fixed,2017-03-14 21:52,Java,Java Build,,,,,,,"Add a note to the main Java build detailing that we will be switching to the maven build systems (see QPID-5048 + QPID-5610) for future releases, to try and give affected developers+users advanced notice.

"
Bug,QPID-68,12354859,Ant build system fails if the project path contains a space,,ritchiem,Closed,Fixed,2017-03-14 21:52,Java,Java Build,,,,,,,"If a folder on your path contains a space then the ant process fails to build.

This is due to the custom Ant code.

The Map.java code splits incoming propery value is split on regex ""\\s+"".

Changing module.xml line 23 to include a split value.

 <map property=""module"" value=""${basedir}"" split=""${path.separator}"">

AFAICT there is only ever going to be one directory in the ${basedir}
value hence use the system path.separator will not cause a problem but
allow spaces in the path

"
Bug,QPID-1605,12412910,intermittent failures of the failover related QueueBrowser* tests,rhs,rhs,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"The failover related tests sometimes fail because the java 0-10 client is acknowledging messages received from a prior session, and these sometimes fall outside the range of messages that have been sent on the new session. When this happens an assertion failure is triggered on the C++ broker. The java client needs to be fixed to pause failover until all the messages from old sessions have been processed."
Bug,QPID-3973,12552367,QPID Java SSLUtil does not support non-JKS key store types,rgodfrey,jsightle@redhat.com,Closed,Fixed,2017-03-14 20:12,Java,Java Common,JMS AMQP 0-x,,,,,,"We are required to run our system in FIPS-compliant mode, using the NSS library for Java Security. In this mode, we cannot use JKS for private key storage.

Unfortunately, SSLUtil does not support configurable KeyStore types, and will throw an exception if we attempt to do this."
Bug,QPID-1761,12417331,BBEncoder.grow doesn't properly copy and ends up garbling the encoded data,rhs,rhs,Closed,Fixed,2017-03-14 20:12,Java,Java Common,,,,,,,"BBEncoder.grow doesn't flip the old buffer before copying it to the new buffer. The default buffer size is 4K, so this will only effect messages with more than 4K worth of headers."
Bug,QPID-4081,12595359,"If Exception is thrown on stopping of first broker from several brokers started by test case, the remaining brokers continue running and impact all following test cases",rgodfrey,orudyy,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"If Exception is thrown on stopping of any broker from several brokers started by test case, the remaining brokers are left running and might continue operating and impact all following test cases. As result, if any of the following tests tries to start broker on the occupied port, the broker does not start and test fails."
Bug,QPID-4104,12597419,Test org.apache.qpid.server.store.StoreOverfullTest.testCapacityExceededCausesBlockTwoConnections fails occasionally,kwall,orudyy,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"Test org.apache.qpid.server.store.StoreOverfullTest.testCapacityExceededCausesBlockTwoConnections fails occasionally.

The second queue in this test has not been created and bound. As result an exception AMQNoRouteException is returned for each published message.

{noformat}
org.apache.qpid.client.AMQNoRouteException: Error: No Route for message [error code 312: no route]
	at org.apache.qpid.client.AMQSession_0_8$2.run(AMQSession_0_8.java:506)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)
{noformat}"
Bug,QPID-4047,12559885,IoNetworkTransport doesn't use timeout on socket connect,rgodfrey,lefthandmagic,Closed,Fixed,2017-03-14 20:12,Java,Java Common,,,,,,,"line 76 of org/apache/qpid/transport/network/io/IoNetworkTransport calls _socket.connect without supplying a timeout value.  This is equivalent to an infinite timeout. Re-use the _timeout field within the same class that specifies a 60 second timeout for reads?

I've attached a patch."
Bug,QPID-4602,12634125,Java broker fails to start if the default log4j configuration is used,robbie,orudyy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"The commit in revision https://svn.apache.org/repos/asf/qpid/trunk@1448306 broke java system tests. The log4j configuration location is not correctly passed into the spawn broker command line if it contains spaces. As result, a default log4j configuration is used but LoggingManagementFacade is not created for it and NullPointerException is thrown from JMXManagement on trying to create LoggingManagementMBean:
{noformat}
Exception during startup: java.lang.NullPointerException
java.lang.NullPointerException
	at org.apache.qpid.server.jmx.mbeans.LoggingManagementMBean.buildAllAvailableLoggerLevelsWithInheritedPsuedoLogLevel(LoggingManagementMBean.java:323)
	at org.apache.qpid.server.jmx.mbeans.LoggingManagementMBean.<init>(LoggingManagementMBean.java:87)
	at org.apache.qpid.server.jmx.JMXManagement.start(JMXManagement.java:190)
	at org.apache.qpid.server.jmx.JMXManagement.setState(JMXManagement.java:110)
	at org.apache.qpid.server.model.adapter.AbstractAdapter.setDesiredState(AbstractAdapter.java:94)
	at org.apache.qpid.server.model.adapter.BrokerAdapter.changeState(BrokerAdapter.java:707)
	at org.apache.qpid.server.model.adapter.BrokerAdapter.setState(BrokerAdapter.java:675)
	at org.apache.qpid.server.model.adapter.AbstractAdapter.setDesiredState(AbstractAdapter.java:94)
	at org.apache.qpid.server.configuration.updater.ChangeStateTask.call(ChangeStateTask.java:59)
	at org.apache.qpid.server.configuration.updater.ChangeStateTask.call(ChangeStateTask.java:28)
	at org.apache.qpid.server.configuration.updater.TaskExecutor.executeTask(TaskExecutor.java:213)
	at org.apache.qpid.server.configuration.updater.TaskExecutor.access$200(TaskExecutor.java:46)
	at org.apache.qpid.server.configuration.updater.TaskExecutor$CallableWrapper$1.run(TaskExecutor.java:252)
	at java.security.AccessController.doPrivileged(Native Method)
	at javax.security.auth.Subject.doAs(Subject.java:396)
	at org.apache.qpid.server.configuration.updater.TaskExecutor$CallableWrapper.call(TaskExecutor.java:247)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
	at java.util.concurrent.FutureTask.run(FutureTask.java:138)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:662)
{noformat}"
Bug,QPID-3679,12534941,Documentation for JMS prefetch could use some correction and amplification,robbie,gsim,Closed,Fixed,2017-03-14 20:08,Java,Java Documentation,JMS AMQP 0-x,,,,,,"(1) the documentation states that maxprefetch controls the 'maximum number of pre-fetched messages per destination'. However this is not strictly correct, it is the prefetch per *consumer* (if you had multiple consumers on the same destination they would each have that amount of prefetch).

(2) there is no mention of the capacity option in the address (which admittedly is only supported by the JMS client ta this point)"
Bug,QPID-3501,12524290,LogMonitor can corrupt test logs files and cause tests subclassing AbstractLoggingTests to fail.,kwall,kwall,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"On an old slow CI box, occasionally we see test failures from those tests subclassing AbstractLoggingTests (ChannelLoggingTests, ExchangeLoggingTest etc).

For example:   org.apache.qpid.server.logging.ExchangeLoggingTest fails on the 0-9-1 test profile with exception:

{code}
TestName: testDiscardedMessage Duration: 11.167

Incorrect message expected:<...3> but was:<...1>
                                

junit.framework.ComparisonFailure: Incorrect message expected:<...3> but was:<...1>
	at org.apache.qpid.server.logging.AbstractTestLogging.validateMessageID(AbstractTestLogging.java:119)
	at org.apache.qpid.server.logging.ExchangeLoggingTest.testDiscardedMessage(ExchangeLoggingTest.java:249)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:238)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:131)
{code}

Analysis shows that the tests' assertions are failing because the test standard out file is corrupt.  When the test fails, the .out file contains a long sequence of ASCII NULs and parts of the log are duplicated.  It is the duplication that causes the assertion failure, as the log files contain incorrect numbers of operation log messages (EXH- in this case). 
 

{code}
od -a TEST-org.apache.qpid.server.logging.ExchangeLoggingTest.testDiscardedMessage.out | head
0000000 nul nul nul nul nul nul nul nul nul nul nul nul nul nul nul nul
*
0164000 nul nul nul nul nul nul nul nul nul nul nul nul m a i n
0164020 sp 2 0 1 1 - 0 9 - 2 1 sp 2 1 : 1

{code}"
Bug,QPID-3454,12520097,System test StreamMessageTest would not detect regression in StreamMessage buffer expansion.,robbie,kwall,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"A defect in the logic of StreamMessageTest#testModifyReceivedMessageExpandsBuffer would mean that a regression could go unnoticed.

The test incorrectly uses a Junit assertion _within_ an onMessage.  Unfortunately if this assertion were to ever fail, the Junit test harness would not hear the assertion fail as onMessage is executed by a separate thread.

 "
Bug,QPID-1809,12422863,SimpleACLTest..testServerPublishInvalidQueueSuccess fails due to incorrect exception,aidan,ritchiem,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"Summary:

Test fails fairly regularly with the following error:

SimpleACLTest..testServerPublishInvalidQueueSuccess
junit.framework.AssertionFailedError: Incorrect exception expected:<class javax.jms.IllegalStateException> but was:<class javax.jms.JMSException>
at org.apache.qpid.server.security.acl.SimpleACLTest.testServerPublishInvalidQueueSuccess(SimpleACLTest.java:624)
at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:188)
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:222)
"
Bug,QPID-4341,12608801,ensure the Topic perftests actually use Topic destinations,robbie,robbie,Closed,Fixed,2017-03-14 20:08,Java,Java Performance Tests,,,,,,,"Most of the example performance test definitions for Topics dont actually use Topic destinations. This is probably 'OK' on the producer side since they are really just sending to an exchange with a particular routing key either way, but it should really be using a Topic destination since thats what users will do. On the consumer side the test should obviously be using a Topic destination."
Bug,QPID-2340,12445526,[Java] ProducerFlowControlTest failing due to race condition in test,rgodfrey,rgodfrey,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"ProducerFlowControlTest occasionally fails with unexpected numbers of messages being sent due to the fact that the test is based on sleeping for an amount of time, and assuming that the flow control will have kicked in by then.  this is necessary as sending messages cannot be made synchronous in 0-8.

To fix, introduce a .sync() method on AMQSession and call this after sends in the test.  This will ensure that any necessary flow control will have been enacted before the next client operation is invoked."
Bug,QPID-2484,12461384,"Interoperability tests fail due to attempts to print out contents of JMS Message objects, and do not parse command line properies",ritchiem,andrew.kennedy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"Interoperability tests fail due to attempts to print out contents of JMS Message objects, as the messages are not considered readable. This is exposed in the toString method, which is called during String concatenation. To fix this, the TestClient and ConversationFactory classes have been modified to print the JMSMessageId instead, which is always accessible. Additionally, the TestClient class does not correctly use parsed command line properties, and fails to set the broker URL and default virtual host name. The default virtual host should be set to ""test"" in the default properties, to match the Javadoc, and the TestClient should add the parsed command line properties to the default properties with the correct name."
Bug,QPID-2158,12438896,[Java 0-8/0-9] Overlong AMQShortStrings incorrectly encoded and cause Frame corruption,robbie,rgodfrey,Closed,Fixed,2017-03-14 20:07,Java,Java Common,,,,,,,"AMQP defines as shortstr as a 1-octet length followed by that many octets of data.  In java we use the AMQShortString class to represent this datatype in the 0-8/0-9 codebase.  Unfortunately the AMQShortString class does not check to ensure that on construction its total length is less than 256 characters.  In cases where an overlong  AMQShortString is created and subsequently encoded, the size is written out as (byte) length, which means that a String of length 296 will be encoded as an octect with value 40 (296 & 255) followed by 296 octets of data.  Upon decoding this causes a frame decoding error.

We should check on construction of an AMQShortString that the underlying data does not have length > 255, and that if it does we should throw an appropriate exception (IndexOutOfBoundsException?)

[This error was discovered when a long queue name was created, and that queue subsequently used as the destination for a reply-to field... the encoding of a reply-to copies the queue name twice (once as the queue name, once as the binding-key]"
Bug,QPID-2370,12446899,TTR-Qpid-07-NA failed due to channel error 504 during tear down,robbie,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Performance Tests,,,,,,,"During a full 'RunCore.sh' performance test run TTR-Qpid-07-NA hung holding the test run up. This appeared to be as a result of a Channel Error that was thrown during. 

Thread-4 2010-01-26 03:29:48,722 ERROR [apache.qpid.client.AMQConnection] error:
org.apache.qpid.AMQConnectionClosedException: Error: channel is closed [error code 504: channel error] [error code 504: channel error]

This may have occured during test tear down as the following was logged by the same thread just after the stack trace.
Thread-4 2010-01-26 03:29:48,725 WARN [apache.qpid.ping.PingTestPerf] There was an exception during per thread tear down.


"
Bug,QPID-4053,12560160,Performance Test Framework: QueueDelete can timeout if test ends when too many unprocessed messages remain on test queue,kwall,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Performance Tests,,,,,,,"There is a problem in the new Performance Test Framework.  If a test utilising the maxiumumDuration feature completes with too many messages left on a queue (as would be the case where number of producers out-number consumers), the QueueDelete command issued by the framework can apparently fail owing to a timeout exception.  The command does in fact complete successfully server side, it is just the client gives up awaiting the response.  This can cause a spurious test failure.

I see this with VaryingNumberOfParticipants.json when maximumDuration is set to 100seconds.

{code}
org.apache.qpid.AMQTimeoutException: Server did not respond in a timely fashion [error code 408: Request Timeout]
        at org.apache.qpid.client.util.BlockingWaiter.block(BlockingWaiter.java:177)
        at org.apache.qpid.client.protocol.BlockingMethodFrameListener.blockForFrame(BlockingMethodFrameListener.java:122)
        at org.apache.qpid.client.protocol.AMQProtocolHandler.writeCommandFrameAndWaitForReply(AMQProtocolHandler.java:656)
        at org.apache.qpid.client.protocol.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:677)
        at org.apache.qpid.client.protocol.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:671)
        at org.apache.qpid.client.AMQSession_0_8.sendQueueDelete(AMQSession_0_8.java:429)
        at org.apache.qpid.disttest.jms.QpidQueueCreator.deleteQueue(QpidQueueCreator.java:88)
        at org.apache.qpid.disttest.jms.QpidQueueCreator.deleteQueues(QpidQueueCreator.java:55)
        at org.apache.qpid.disttest.jms.ControllerJmsDelegate.deleteQueues(ControllerJmsDelegate.java:198)
        at org.apache.qpid.disttest.controller.TestRunner.deleteQueues(TestRunner.java:232)
        at org.apache.qpid.disttest.controller.TestRunner.runParts(TestRunner.java:139)
        at org.apache.qpid.disttest.controller.TestRunner.run(TestRunner.java:103)
        at org.apache.qpid.disttest.controller.Controller.runAllTests(Controller.java:172)
        at org.apache.qpid.disttest.ControllerRunner.runTest(ControllerRunner.java:120)
        at org.apache.qpid.disttest.ControllerRunner.runTests(ControllerRunner.java:105)
        at org.apache.qpid.disttest.ControllerRunner.runController(ControllerRunner.java:80)
        at org.apache.qpid.disttest.ControllerRunner.main(ControllerRunner.java:69)

{code}"
Bug,QPID-3792,12540561,Test DurableSubscriptionTest.testDurSubAddMessageSelectorNoClose fails sporadically for test profile java-bdb-spawn.0-10,robbie,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Test org.apache.qpid.test.unit.topic.DurableSubscriptionTest.testDurSubAddMessageSelectorNoClose fails sporadically for test profile java-bdb-spawn.0-10

junit.framework.AssertionFailedError: Queue depth is wrong expected:<1> but was:<0>
	at org.apache.qpid.test.unit.topic.DurableSubscriptionTest.testDurSubAddMessageSelectorNoClose(DurableSubscriptionTest.java:796)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:242)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:138)
"
Bug,QPID-2262,12443004,Random test failures in SimpleACLTest,ritchiem,rajith,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,I have modifed the test to detect when it receives an IllegalStateException and log about QPID-1204 rather than causing a test failure. This approach was already in use when the exception was an AMQAuthenticationException but was not handled when the cause is null.
Bug,QPID-2028,12432164,Broker test do not cleanup ApplicationRegistry that they create,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Summmary:

The non-unit tests in the broker package that cause an ApplicationRegistry to be created do not correctly remove this registry at the end of the test. This is what causes the ApplicationRegistry errors at the end of the ant run.

Sharing ARs between tests will increase the likelyhood of cross contamination of tests leading to spurious failures.

The tests should ensure that the correctly close any AR they create.

This is more relevant now as the new broker logging uses a ThreadLocal to maintain the current logger and only through a correct clean up of all tests can it be successfully tested in isolation."
Bug,QPID-3793,12540566,Test MessageStatisticsTest.testMessagePeakRates fails sporadically on java-bdb-spawn.0-10 test profile,robbie,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Test MessageStatisticsTest.testMessagePeakRates fails sporadically on java-bdb-spawn.0-10 test profile

junit.framework.AssertionFailedError: Incorrect dev vhost peak messages: expected 2.000000 +/- 20%, actual 1.500000
	at org.apache.qpid.management.jmx.MessageStatisticsTestCase.assertApprox(MessageStatisticsTestCase.java:126)
	at org.apache.qpid.management.jmx.MessageStatisticsTest.testMessagePeakRates(MessageStatisticsTest.java:181)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:242)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:138)
"
Bug,QPID-3164,12502263,Occasional test failures from SimpleAMQQueueTest.testSubscriptionSpecificRequeueForQueueWithMultipleSubscriptions,robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"QPID-2900 added a new test case SimpleAMQQueueTest.testSubscriptionSpecificRequeueForQueueWithMultipleSubscriptions which aims to verify that the method SimpleAMQQueue.requeue(QueueEntry, Subscription) behaves correctly and correctly requeues an entry for a specific subscription.   The test is showing sporadic test failures.

junit.framework.AssertionFailedError: Unexpected total number of messages sent to subscription1 after enqueue expected:<1> but was:<0>
	at org.apache.qpid.server.queue.SimpleAMQQueueTest.testSubscriptionSpecificRequeueForQueueWithMultipleSubscriptions(SimpleAMQQueueTest.java:453)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:120)

I notice that the test case has even failed on the new Jenkins instance:

https://builds.apache.org/hudson/pview/job/qpid-java-build/7/testReport/junit/org.apache.qpid.server.queue/SimpleAMQQueueTest/testSubscriptionSpecificRequeueForQueueWithMultipleSubscriptions/

"
Bug,QPID-1962,12429094,FirewallPluginTest.testSingleHostWilcardRule is dependent on 127.0.0.1 resolving to localhost,aidan,aidan,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,And that isn't necessarily always true. Sometimes people have /etc/hosts set right. 
Bug,QPID-3819,12541634,ExhaustiveACLTests can timeout (but still pass) during teardown [0-9-1],robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"On the 0-9-1 test profiles we sometimes see ExhaustiveACLTest take 30 or 60 seconds then pass. On investigation I see that we are logging an error, but the test is still passing:

{code}
main 2012-02-07 13:57:19,657 ERROR [apache.qpid.client.AMQConnection] error:
org.apache.qpid.AMQTimeoutException: Close did not complete in timely fashion [error code 408: Request Timeout]
        at org.apache.qpid.client.AMQConnectionDelegate_8_0.closeConnection(AMQConnectionDelegate_8_0.java:91)
        at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:865)
        at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:832)
        at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:816)
        at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:807)
        at org.apache.qpid.client.AMQConnection.close(AMQConnection.java:802)
        at org.apache.qpid.test.utils.QpidBrokerTestCase.tearDown(QpidBrokerTestCase.java:1047)
        at org.apache.qpid.server.security.acl.AbstractACLTestCase.tearDown(AbstractACLTestCase.java:105)
        at junit.framework.TestCase.runBare(TestCase.java:130)
        at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:237)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:138)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:422)
        at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:931)
        at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:785)
Caused by: org.apache.qpid.AMQTimeoutException: Server did not respond in a timely fashion [error code 408: Request Timeout]
        at org.apache.qpid.client.util.BlockingWaiter.block(BlockingWaiter.java:178)
        at org.apache.qpid.client.state.StateWaiter.await(StateWaiter.java:111)
        at org.apache.qpid.client.AMQConnectionDelegate_8_0.closeConnection(AMQConnectionDelegate_8_0.java:87)
        ... 19 more

{code}"
Bug,QPID-2092,12435310,Move system test configuration to the systest package,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Just to tidy things up a bit. 

Move the test configuration files to the systest package.
"
Bug,QPID-2635,12465878,Ant tests fail with OutOfMemoryError due to PermGen space exhaustion,robbie,andrew.kennedy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Ant tests fail with OutOfMemoryError due to PermGen space exhaustion. This appears to happen only with the last test, and only intermittently."
Bug,QPID-2503,12462044,CommandLineParser does not print '-' when showing options,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:07,Java,Java Tools,,,,,,,"The CommandLineParser in qpid utils does not show the '-' when it prints the options out.

As a result it makes it difficult for users to know the exact command line format.
Normally a long option would be prefixed with '--' but we only use a single '-'.
i.e. -option rather than --option

However currenty when printing out the help it only shows

  option : Description of option.

So the user does not know to only use a single '-'."
Bug,QPID-3803,12540945,System tests SortedQueueTest#test<ACK MODE>SortedQueue fail ocasionally on slow machines,robbie,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Testcase: testClientAckSortedQueue took 9.829 sec
        FAILED
Incorrect number of messages received expected:<200> but was:<42>
junit.framework.AssertionFailedError: Incorrect number of messages received expected:<200> but was:<42>
        at org.apache.qpid.server.queue.SortedQueueTest.runThroughSortedQueueForSessionMode(SortedQueueTest.java:154)
        at org.apache.qpid.server.queue.SortedQueueTest.testClientAckSortedQueue(SortedQueueTest.java:122)
        at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:237)
        at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:138)
"
Bug,QPID-2060,12433455,LogMonitorTest.testWaitForMessage_Found fails,aidan,aidan,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Testcase: testWaitForMessage_Found took 2.177 sec
        FAILED
Message was not logged
junit.framework.AssertionFailedError: Message was not logged
        at org.apache.qpid.util.LogMonitorTest.testWaitForMessage_Found(LogMonitorTest.java:176)
"
Bug,QPID-3747,12538037,PrefetchBehaviourTest.testLowPrefetchCausesMessagesToBeDistributedBetweenConsumers occasionally fails on spawned profiles.,robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"We see test AMQConnectionTest#testPrefetchSystemProperty occasionally fail on CI instances running the spawned profiles with assertion failure ""Consumer A should not have received a 3rd message""

e.g. java-mms-spawn.0-10  

{code}
junit.framework.AssertionFailedError: Consumer A should not have received a 3rd message
	at org.apache.qpid.test.unit.client.AMQConnectionTest.testPrefetchSystemProperty(AMQConnectionTest.java:263)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:240)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:135)
{code}



"
Bug,QPID-997,12395128,AMQBrokerManagerMBeanTest takes more than 60seconds to run,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

The AMQBrokerManagerMBeanTest takes more tha 60 seconds to run tends to suggest an error has occurred but no problems are logged out.

[junit] Running org.apache.qpid.server.AMQBrokerManagerMBeanTest
[junit] Tests run: 2, Failures: 0, Errors: 0, Time elapsed: 68.658 sec

surefire report:

$ cat org.apache.qpid.server.AMQBrokerManagerMBeanTest.txt
-------------------------------------------------------------------------------
Test set: org.apache.qpid.server.AMQBrokerManagerMBeanTest
-------------------------------------------------------------------------------
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0 sec



"
Bug,QPID-936,12394290,Test testMigrateDurableSubscriber from org.apache.qpid.test.unit.xa.TopicTest is failing,,arnaudsimon,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"This test is failing because it tries to migrate a durable subscriber form session S1 to session S2 without closing S1. 
The following line must be added: Line 1582:  autoAclSession.close();
Note:This test is run without message prefetch "
Bug,QPID-1389,12407079,ConnectionTest.testResume failure on build system,rhs,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Common,Java Tests,,,,,,"Summary:

The ConnectionTest failed again today with this issue.

ConnectionTest.testResume
org.apache.qpid.transport.SessionException: timed out waiting for sync: complete = 3, point = 8   
at org.apache.qpid.transport.Session.sync(Session.java:482)   
at org.apache.qpid.transport.Session.sync(Session.java:451)   
at org.apache.qpid.transport.ConnectionTest.testResume(ConnectionTest.java:221) "
Bug,QPID-1200,12401148,QpidTestCase fails if input has not been redirected,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"If the test case's output is not being redirected, out and err can get set to null which causes all kinds of issues."
Bug,QPID-987,12395062,org.apache.qpid.test.client.DupsOkTest has high memory requirements,,senakafdo,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"org.apache.qpid.test.client.DupsOkTest has high memory requirements due to using 9999 messages. If the test is not a stress test, why not halve the count to 4999. If not, it gives a ""java.lang.OutOfMemoryError: Java heap space"" when using ANT_OPTS='-Xmx512m'.

Regards,
Senaka"
Bug,QPID-1181,12400372,NullApplicationRegistry initialisation problem,,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

The NullApplicationRegistry is the default ApplicationRegistry that will be created if another is not configured when a call is made to ApplicationRegistry.getInstance()  and that instance needs creating.

However, there is a problem with this:

When created in this way the ApplicationRegistry creates the NullAR and then calls initialise() on it before adding to the global registry so that it can be retrieved via AR.getInstance()

The problem is that during the initialisation process a new VirtualHost is created.

        _managedObjectRegistry = new NoopManagedObjectRegistry();
        _virtualHostRegistry = new VirtualHostRegistry();
        VirtualHost dummyHost = new VirtualHost(""test"", getConfiguration());


Not a problem in itself BUT the VirtualHost constructor creates an MBean that needs to be registered.

That registration process however does:

ApplicationRegistry.getInstance().getManagedObjectRegistry();

This returns null as there is no ManagedObjectRegistry yet.

the subsequent call to registerObject in DefaultManagedObject results in a NPE.






"
Bug,QPID-1226,12401989,DupsOk doesn't create the consumer so will always fail to receive messages.,,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"The change for QPID-1225 highlighted that this test was always failing. This is because it never creates the queue it is sending messages to so they are all bounced with No Route.

Just need to create a consumer. to fix it up."
Bug,QPID-1203,12401238,Systests fail whe run against an external java broker,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Some tests fail against an external java broker:

QueueBrowser*.testFailover* and FailoverTest cannot create a 2nd external broker and should just be disabled in this context

TopicSessionTest.testNoLocal fails because QpidTestCase swallows the client id when creating an external connection

ConnectionTest fails because AMQConnection acts as if an unsupported protocol is a real failure to connect, which it isn't."
Bug,QPID-1167,12399816,Queue alerting nolonger works.,rgodfrey,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:
This was broken by commit:

#629731  	Thu Feb 21 02:09:03 PST 2008  	rgodfrey

The update to AMQQueue to create a list active of NotificationChecks is fine as a performance enhancement the problem is that on creation all alerts are 0 which means that no NotificationChecks are registered. 

In some places the AMQQueue creation is followed by Configurator.configure(...); however this does not call the set Methods but directly changes the variables so the NotificationCheck registrations are still missing.

The virtualhost has a getConfiguredObject() which should be used to ensure all object creations are correctly configured with the commons Configuration values. However all configured objects will also need an init()  method as we cannot use the constructor for things such as registering checks based on configurable values. These values are not set until later (the Configurator.configure(...) call to be exact.) 

Changes Required:

- All Configurable object creations need to be checked to ensure that the object is correctly configured based on the commons.Configuration.
- For consistency all Configurable objects should have an init() method to perform any final setup after the configured values have been set.

Testing:

This needs additional testing. In particular the configuration values for alerting need to be set via a real configuration not via the set<Notification>() methods.






"
Bug,QPID-627,12379944,DurableSubscriberTest hangs,,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,Occasionally DurableSubscriberTest will try to close the broker before it's shutdown everything and then MINA get's annoyed and waits forever. 
Bug,QPID-789,12388546,FieldTable.putDataInBuffer not thread safe,rgodfrey,rgodfrey,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,"putDataInBuffer is not thread safe - a member variabke byte buffer is used to write into a second byte buffer passed in as an argument.

To make the method thread safe, use a duplicate of the member variable instead."
Bug,QPID-1089,12396688,Test FieldTableMessageTest and TextMessageTest may hang,arnaudsimon,arnaudsimon,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,Those two tests hang if all messages are not delivered. They should timeout and fail instead. 
Bug,QPID-962,12394682,ConnectionTest takes too long to run,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"ConnectionTest takes 90-odd seconds to run, which is both frustrating and possibly indicative of a problem. Some investigation required."
Bug,QPID-766,12387483,FailoverMethodTest.testFailoverRoundRobinDelay has too long a delay measurement,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"FailoverMethodTest.testFailoverRoundRobinDelay tests for a delay of 9.5s, which is too long for 3 reconnection attempts of 2 seconds each."
Bug,QPID-964,12394698,CombinedTest.testForwardAll fails,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,JMS AMQP 0-x,,,,,,"Fails when run against a 0-10 broker 

Didn't receive all messages... got 0 expected 1

java.lang.Exception: Didn't receive all messages... got 0 expected 1
at org.apache.qpid.test.unit.client.forwardall.Client.waitUntilComplete(Client.java:106)
at org.apache.qpid.test.unit.client.forwardall.Client.shutdownWhenComplete(Client.java:80)
at org.apache.qpid.test.unit.client.forwardall.CombinedTest.testForwardAll(CombinedTest.java:59)
at org.apache.qpid.testutil.QpidTestCase.runBare(QpidTestCase.java:131)
at org.apache.qpid.testutil.QpidTestCase.run(QpidTestCase.java:157)"
Bug,QPID-1416,12407508,SimpleACLTest now fails with a Timeout exception rather than Authentication failure,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Test: 	testClientPublishInvalidQueueSuccess
Class: 	org.apache.qpid.server.security.acl.SimpleACLTest
	
junit.framework.AssertionFailedError: Incorrect exception expected:<class org.apache.qpid.client.AMQAuthenticationException> but was:<class org.apache.qpid.AMQTimeoutException>  
at org.apache.qpid.server.security.acl.SimpleACLTest.testClientPublishInvalidQueueSuccess(SimpleACLTest.java:316)  
at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)  
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220)
	

Full log to follow"
Bug,QPID-558,12377153,AMQShortString should autoexpand when adding content to it,,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,AMQShortString.writeToBuffer often throws exceptions because the buffer isn't set to autoexpand.
Bug,QPID-1161,12399293,Test kit for java,rajith,rajith,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"The attached Test kit for the java client consists of 2 components.

1) A Simple Perf Test that can be used to,
   a) Run a predefined perf report consisting of 8 use cases (see below)
   b) Run a producer and a consumer with a number of different options

2) Soak tests that can be run for longer durations (hours or days).

I am planning to add some stress tests to this module as well.
Please note this is not a replacement for the existing perf/systests etc.
But rather a small test kit thats focused on providing a packaged set of tests that can be quickly deployed on an environment to do quick smoke testing or easily setup a soak test.

1.0 Perf Kit
------------
1.1 The perf kit can be packaged as an RPM or a tar file and deploy on a target environment and run the perf report.
Or else a perf report can be automated to run every day or so an record numbers to catch perf regressions.

1.2 It calculates the following results in msg/sec.
    
    System throuhgput : no_of_msgs / (time_last_msg_rcvd - time_first_msg_send)

    Producer rate     : no_of_msgs / (time_after_sending - time_before_sending)

    Producer rate     : no_of_msgs / (time_last_msg_rcvd - time_first_msg_rcvd) 

    Latency           : time_msg_rcvd - time_msg_sent

The test will print min, max and avg latency.

1.3 The test assume that both producer and consumer are run on the same machine or different machines that are time synced.

1.4 You can also use run_sub.sh and run_pub.sh to run different use cases with several options.
    Please look at TestParams.java for all the configurable options.

1.5 You can also use the test kit to benchmark against any vendor.


2.0 Soak tests
--------------
2.0 This includes a set of soak tests that can be run for a longer duration.

2.1 A typical test will send x-1 messages and the xth message will contain an ""End"" marker.
    The producer will print the message_id and timestamp for the xth message.
    The consumer will reply with an empty message to the replyTo destination given in the xth message.
    The consumer also prints the message_id and timestamp for the xth message.
    A typical value for x is 100k 

2.2 The feedback loop prevents the producer from overrunning the consumer. 
    And the printout for every xth message will let you know how many iterations been completed at any given time.

2.2 The following results can be calculated for these tests. 
    
    Memory, CPU for each producer/consumer - scripts will be checked in

    Using the message_id and timestamp you can get latency samples for the test run.

    Using the timestamps you can calculate the system throughput rates.   

2.2 If you use different machines for producer and consumer the machines have to be time synced if you want latency samples. 
 
3.0 Perf Test report use cases
-------------------------------
3.1 Please check testkit/bin/perf_report.sh for more details

3.2 A typical test run will send 1000 msgs during warmup and 200k msgs for result calculation.

Test 1 Trans Queue

Test 2 Dura Queue

Test 3 Dura Queue Sync

Test 4 Topic

Test 5 Durable Topic

Test 6 Fanout

Test 7 Small TX  (about 2 msgs per tx)

Test 8 Large TX  (about 1000 msgs per tx) 


4.0 Soak tests use cases
-------------------------
4.1 Following are the current tests available in the test kit.

4.2 Please refer to the source to see the javadoc and options


1. SimpleProducer/Consumer sends X messages at a time and will wait for confirmation from producer before proceeding with the next iteration. A no of options can be configured.

2. MultiThreadedProducer/Consumer does the same thing as above but runs each session in a separate thread.
   It can also send messages transactionally. Again a no of options can be configured.

3. ResourceLeakTest will setup consumer/producers sends x messages and then teard down everything and continue again. "
Bug,QPID-928,12394081,Test org.apache.qpid.test.unit.client.connection.ConnectionCloseTest intermittently failing ,,arnaudsimon,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"This test is failing because more than 10 threads are still running immediately after the 500 connections are closed. It appears that those threads are Mina threads waiting on a selector key. Those threads are eventually notified if the main thread waits before checking for potential spurious threads. 
As the threshold (currently set to 10) is arbitrary, I would suggest that we wait 1s before making the check that should leave all type of hardware enough time to cleanup, we would then use a 0 threshold i.e. no spurious thread would be tolerated.
 "
Bug,QPID-1215,12401589,JNDICheck uses 1.6 specific methods Properites.load(Reader),ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tools,,,,,,,"Summary:

As we haven't yet said we are requiring 1.6 we should ensure our code compiles with JDK 1.5.

The use of Properties.load(Reader) was only introduced in JDK 1.6 so it should be replaced with a FileInputStream."
Bug,QPID-199,12358802,PropertyFieldTable cannot decode payload,rgreig,rgreig,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,The PropertyFieldTable throws a NullPointerException exception when decoding many payloads. This appears related to a switch on an enum.
Bug,QPID-839,12390458,DupsOkTest hangs on failure,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,JMS AMQP 0-x,,,,,,"Exception in thread ""Dispatcher-Channel-1"" junit.framework.AssertionFailedError:
 The queue should have 0 msgs left expected:<0> but was:<1>
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.failNotEquals(Assert.java:282)
        at junit.framework.Assert.assertEquals(Assert.java:64)
        at junit.framework.Assert.assertEquals(Assert.java:201)
        at org.apache.qpid.test.client.DupsOkTest$1.onMessage(DupsOkTest.java:103)
        at org.apache.qpid.client.BasicMessageConsumer.notifyMessage(BasicMessageConsumer.java:720)
        at org.apache.qpid.client.BasicMessageConsumer.notifyMessage(BasicMessageConsumer.java:680)
        at org.apache.qpid.client.AMQSession$Dispatcher.dispatchMessage(AMQSession.java:3019)
        at org.apache.qpid.client.AMQSession$Dispatcher.run(AMQSession.java:2942)
<hang>

Super fantastico!


"
Bug,QPID-909,12393533,DurationTestDecorator doesn't work in conjunction with the ScaledTestDecorator,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

Changes to the DurationTestDecorator to use a timer to interupt a running test work fine when only a single test is being run. 

When the test is wrapped with a ScaledTestDecorator then the new mechanism causes run 2-N to fail.

This is because the new timer sets shutdown on the DurationTestDecorator and closes the testresult.

These values are not rest on subsequent runs so the next run doesn't actually get performed due to the shutdown var being set. Also if the test were to run the testresult would interupt the run as the testresult has also been marked shutdown."
Bug,QPID-963,12394684,SimpleACLTest.testServerPublishInvalidQueueSucces and testServerPublishUsingTransactionSuccess fail,ritchiem,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,JMS AMQP 0-x,,,,,,"After the merge, SimpleACLTest fails in two test cases, and takes around 2 minutes to run on windows (possibly indicative of a problem with connections being forcibly closed? See QPID-962)

junit.framework.AssertionFailedError: Test publish failed:org.apache.qpid.client.JMSAMQException: Failed to commit:  [error code 403: access refused] [error code 403: access refused]
        at junit.framework.Assert.fail(Assert.java:47)
        at org.apache.qpid.server.security.acl.SimpleACLTest.testServerPublishUs
ingTransactionSuccess(SimpleACLTest.java:533)

testServerPublishInvalidQueueSuccess(org.apache.qpid.server.security.acl.SimpleACLTest)  Time elapsed: 60.531 sec  <<< ERROR!
org.apache.qpid.AMQConnectionFailureException: 530 [error code -1: unknown code]
        at org.apache.qpid.client.AMQConnection.<init>(AMQConnection.java:519)
        at org.apache.qpid.client.AMQConnection.<init>(AMQConnection.java:336)
        at org.apache.qpid.server.security.acl.SimpleACLTest.testServerPublishInvalidQueueSuccess(SimpleACLTest.java:541)
"
Bug,QPID-1320,12405893,ResetMessageListenerTest testAsynchronousRecieve test failure,aidan,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"This test has failed a number of times these were the failure messages:

junit.framework.AssertionFailedError: Second batch of messages not received correctly expected:<0> but was:<1>  
at org.apache.qpid.client.ResetMessageListenerTest.testAsynchronousRecieve(ResetMessageListenerTest.java:257)  
at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)  
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220,
org.apache.qpid.client.ResetMessageListenerTest


junit.framework.AssertionFailedError: First batch of messages not received correctly expected:<0> but was:<1>  
at org.apache.qpid.client.ResetMessageListenerTest.testAsynchronousRecieve(ResetMessageListenerTest.java:256)  
at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)  
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220)
"
Bug,QPID-1557,12411738,the cpp.cluster test profile fails,rhs,rhs,Closed,Fixed,2017-03-14 20:02,Java,Java Common,Java Tests,JMS AMQP 0-x,,,,,"When the tests are run against the clustered cpp broker with 'ant -Dprofile=cpp.cluster' there are a few failures:
  - the XA tests fail because the clustered broker doesn't support XA, these should be excluded from the profile
  - several of the failover tests fail because they assume that no state is shared between the primary and backup node, this is not true for a clustered broker, these tests need to be adjusted to handle clustered as well as non clustered failover
  - a few of the failover tests fail because the java client advertises a non-zero session timeout and this is hitting untested code in the broker, this is also incorrect because the java client isn't really doing a full session resume"
Bug,QPID-1385,12406973,CommitRollbackTest.testSend2ThenRollback failure from build system,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

The following failure occurred last night:

testSend2ThenRollback
org.apache.qpid.test.unit.transacted.CommitRollbackTest
org.apache.qpid.client.JMSAMQException: Fail-over interrupted commit. Status of the commit is uncertain.  
at org.apache.qpid.client.AMQSession.commit(AMQSession.java:740)  
at org.apache.qpid.test.unit.transacted.CommitRollbackTest.testSend2ThenRollback(CommitRollbackTest.java:370)  
at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)  
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220)


Attached is the full output from the test.
"
Bug,QPID-835,12390366,Benchmark Throughput Tests occasionally fail,,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Some of the throughput tests sometimes fail with mysterious F's being printed because not all messages were recieved. 

Running Throughput.sh will show the error."
Bug,QPID-1091,12396799,QpidTestCase does not clean up the InVM Broker after each test.,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

The QpidTestCase does not clean up after each test. This can lead to the tests interacting with each other. The functionality from VMTestCase should be replicated in QTC before it is removed.

Specifically, TransportConnection.killbroker(x); ApplicationRegistry.remove(x); should be performed to ensure we have a clean broker for each run."
Bug,QPID-1179,12400368,QueueBrowser Test Failure (testMultipleGetEnum),ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,JMS AMQP 0-x,,,,,,"Summary:

This test failed with the following error:

TestName: testMultipleGetEnum Duration: 7.932

                                expected:<42> but was:<100>

First point the expected and actual are reversed!

Second point why are we using 100 msgs is that really necessary.

In partial answer to the second point. The failure is due to the fact that running InVM broker and client on the single core machine is just to slow.

As will be shown in second JIRA the client has received more messages for the browser but the receive times out before they can be delivered.

Suggest reducing the msgs count to 10. To resolve this JIRA.
"
Bug,QPID-1184,12400609,all output during tests is buffered until the test case finishes,rhs,rhs,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Because all the output during tests is buffered, it is difficult to debug hangs since the log output is unavailable until the test concludes. Also, some of our tests produce many megabytes worth of output. Because junit buffers it all, there is increased memory pressure during test runs."
Bug,QPID-1210,12401440,qpid-run output is confusing for command line scripts,rhs,rhs,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,The info that qpid-run outputs can make it difficult to spot the real output of command-line tools when qpid-run is used to launch them.
Bug,QPID-1000,12395131,Deadlock in unit.basic.SelectorTest,rajith,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:

running ant then ant test resulted in this deadlock, Full Thread dump attached as file.

Found one Java-level deadlock:
=============================
""Dispatcher-Channel-1"":
  waiting to lock monitor 0x02a602dc (object 0x23a37cc8, a org.apache.qpid.test.unit.basic.SelectorTest),
  which is held by ""main""
""main"":
  waiting to lock monitor 0x02a60274 (object 0x22bd27e8, a java.lang.Object),
  which is held by ""Dispatcher-Channel-1""
"
Bug,QPID-1344,12406161,low level refactoring for replay breaks protocol negotiation,rhs,ritchiem,Closed,Fixed,2017-03-14 20:01,Java,Java Common,,,,,,,"Summary:

The change in QPID-1339 is causing Protocol negotiation to fail.

Problem
The initial problem is that the check for protocol 0-10 in ClientDelegate was incorrect preventing the ProtocolVersionException from being propogated to the connection.

The new Connection class also wraps the  ProtocolVersionException so AMQConnection is unable to work out the new protocol to try so it continues to try 0-10 until failover is exhausted.

"
Bug,QPID-5996,12734027,[Java Build] Test coverage reports are not currently working,rgodfrey,rgodfrey,Closed,Fixed,2017-03-13 12:27,Java,Java Build,,,,,,,"According to https://cwiki.apache.org/confluence/display/qpid/Qpid+Java+Build+How+To

mvn test jacoco:report

should execute the unit tests and then produce the code coverage report.

It does the former, but not the latter.
"
Bug,QPID-4412,12614525,[AMQP 1-0 Java Common] ReceivingLinkEndpoint.isDrained result is invalid,rgodfrey,chirino,Resolved,Fixed,2016-12-09 20:15,Java,Java Common,,,,,,,the delivery count was not being updated when a Flow was received.
Bug,QPID-755,12386860,Durable subscription test does not test durability.,,rupertlssmith,Resolved,Fixed,2016-12-09 20:15,Java,Java Tests,,,,,,,"The test sets up subscriptions 1 and 2, 2 is durable, later it kills 2 and creates 3, also durable.

open 1
open 2

send A.
check 1 got it.
check 2 got it

close 2.
open 3.

send B.
check 1 got it.
check 2 got it.

But, 3 should not have been open until after B was sent, in order to check that 3 gets messages from the durable subscription that it missed, while no consumer was connected to the subscription."
Bug,QPID-1915,12428265,CommitRollbackTest fails when run with bdb store loaded,,aidan,Resolved,Fixed,2016-12-09 20:14,Java,Java Tests,,,,,,,"TestName: testCommitWhithinOnMessage Duration: 37.755

Did not received message

junit.framework.AssertionFailedError: Did not received message
	at org.apache.qpid.test.unit.transacted.CommitRollbackTest.testCommitWhithinOnMessage(CommitRollbackTest.java:526)
	at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:204)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:249)
"
Bug,QPID-1564,12412044,"CLI code has duplicate headers, does not follow coding standards. ",rgodfrey,aidan,Resolved,Fixed,2016-12-09 20:08,Java,Java Tools,,,,,,,The qpid-cli code has duplicate ASL headers in some files and does not follow the qpid coding standards. 
Bug,QPID-6936,12920247,[Java Broker] Generation of Java Broker doc book in PDF format fails with exceptions,orudyy,orudyy,Closed,Fixed,2016-11-17 13:05,Java,Java Documentation,,,,,,,"Running ""make pdf"" for java broker doc book fails with the following exception:

{noformat}
org.apache.fop.apps.FOPException: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
javax.xml.transform.TransformerException: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at org.apache.fop.cli.InputHandler.transformTo(InputHandler.java:288)
	at org.apache.fop.cli.InputHandler.renderTo(InputHandler.java:115)
	at org.apache.fop.cli.Main.startFOP(Main.java:186)
	at org.apache.fop.cli.Main.main(Main.java:216)
Caused by: javax.xml.transform.TransformerException: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:749)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:351)
	at org.apache.fop.cli.InputHandler.transformTo(InputHandler.java:285)
	... 3 more
Caused by: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at org.apache.fop.events.ValidationExceptionFactory.createException(ValidationExceptionFactory.java:38)
	at org.apache.fop.events.EventExceptionManager.throwException(EventExceptionManager.java:58)
	at org.apache.fop.events.DefaultEventBroadcaster$1.invoke(DefaultEventBroadcaster.java:175)
	at com.sun.proxy.$Proxy5.tooManyCells(Unknown Source)
	at org.apache.fop.fo.flow.table.TableCellContainer.addTableCellChild(TableCellContainer.java:75)
	at org.apache.fop.fo.flow.table.TableRow.addChildNode(TableRow.java:95)
	at org.apache.fop.fo.FOTreeBuilder$MainFOHandler.startElement(FOTreeBuilder.java:324)
	at org.apache.fop.fo.FOTreeBuilder.startElement(FOTreeBuilder.java:179)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:208)
	at com.sun.org.apache.xml.internal.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:281)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.startElement(ToXMLSAXHandler.java:650)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:509)
	at com.sun.org.apache.xerces.internal.xinclude.XIncludeHandler.startElement(XIncludeHandler.java:949)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:380)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2787)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:118)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:668)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:737)
	... 5 more

---------

javax.xml.transform.TransformerException: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:749)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:351)
	at org.apache.fop.cli.InputHandler.transformTo(InputHandler.java:285)
	at org.apache.fop.cli.InputHandler.renderTo(InputHandler.java:115)
	at org.apache.fop.cli.Main.startFOP(Main.java:186)
	at org.apache.fop.cli.Main.main(Main.java:216)
Caused by: org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at org.apache.fop.events.ValidationExceptionFactory.createException(ValidationExceptionFactory.java:38)
	at org.apache.fop.events.EventExceptionManager.throwException(EventExceptionManager.java:58)
	at org.apache.fop.events.DefaultEventBroadcaster$1.invoke(DefaultEventBroadcaster.java:175)
	at com.sun.proxy.$Proxy5.tooManyCells(Unknown Source)
	at org.apache.fop.fo.flow.table.TableCellContainer.addTableCellChild(TableCellContainer.java:75)
	at org.apache.fop.fo.flow.table.TableRow.addChildNode(TableRow.java:95)
	at org.apache.fop.fo.FOTreeBuilder$MainFOHandler.startElement(FOTreeBuilder.java:324)
	at org.apache.fop.fo.FOTreeBuilder.startElement(FOTreeBuilder.java:179)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:208)
	at com.sun.org.apache.xml.internal.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:281)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.startElement(ToXMLSAXHandler.java:650)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:509)
	at com.sun.org.apache.xerces.internal.xinclude.XIncludeHandler.startElement(XIncludeHandler.java:949)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:380)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2787)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:118)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:668)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:737)
	... 5 more
---------
org.apache.fop.fo.ValidationException: The column-number or number of cells in the row overflows the number of fo:table-columns specified for the table. (See position 1385:1673)
	at org.apache.fop.events.ValidationExceptionFactory.createException(ValidationExceptionFactory.java:38)
	at org.apache.fop.events.EventExceptionManager.throwException(EventExceptionManager.java:58)
	at org.apache.fop.events.DefaultEventBroadcaster$1.invoke(DefaultEventBroadcaster.java:175)
	at com.sun.proxy.$Proxy5.tooManyCells(Unknown Source)
	at org.apache.fop.fo.flow.table.TableCellContainer.addTableCellChild(TableCellContainer.java:75)
	at org.apache.fop.fo.flow.table.TableRow.addChildNode(TableRow.java:95)
	at org.apache.fop.fo.FOTreeBuilder$MainFOHandler.startElement(FOTreeBuilder.java:324)
	at org.apache.fop.fo.FOTreeBuilder.startElement(FOTreeBuilder.java:179)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:208)
	at com.sun.org.apache.xml.internal.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:281)
	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.startElement(ToXMLSAXHandler.java:650)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:509)
	at com.sun.org.apache.xerces.internal.xinclude.XIncludeHandler.startElement(XIncludeHandler.java:949)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:380)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2787)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:118)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:668)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:737)
	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:351)
	at org.apache.fop.cli.InputHandler.transformTo(InputHandler.java:285)
	at org.apache.fop.cli.InputHandler.renderTo(InputHandler.java:115)
	at org.apache.fop.cli.Main.startFOP(Main.java:186)
	at org.apache.fop.cli.Main.main(Main.java:216)

../Makefile.inc:56: recipe for target 'AMQP-Messaging-Broker-Java-Book.pdf' failed
make: *** [AMQP-Messaging-Broker-Java-Book.pdf] Error 1

{noformat}"
Bug,QPID-7120,12946551,[Java Broker] Test AbruptClientDisconnectTest.testMessagingOnAbruptConnectivityLostWhilstConsuming fails sporadically,,orudyy,Closed,Fixed,2016-11-17 13:05,Java,Java Tests,,,,,,,"Test AbruptClientDisconnectTest.testMessagingOnAbruptConnectivityLostWhilstConsuming fails for corner case when one remaining message is expected to receive  but it was already received previously, Commit was sent and broker successfully committed and sent back CommitOk but CommitOk did not reach client due to abrupt disconnect

The test fails as below
{noformat}
Error Message

Expected message with index 60 but got null

Stacktrace

junit.framework.AssertionFailedError: Expected message with index 60 but got null
	at junit.framework.Assert.fail(Assert.java:57)
	at junit.framework.Assert.assertTrue(Assert.java:22)
	at junit.framework.Assert.assertNotNull(Assert.java:256)
	at junit.framework.TestCase.assertNotNull(TestCase.java:426)
	at org.apache.qpid.server.AbruptClientDisconnectTest.consumeIgnoringLastSeenOmission(AbruptClientDisconnectTest.java:242)
	at org.apache.qpid.server.AbruptClientDisconnectTest.testMessagingOnAbruptConnectivityLostWhilstConsuming(AbruptClientDisconnectTest.java:201)
{noformat}"
Bug,QPID-7052,12937522,[Java Performance Tests] In tests based on message number limit all consumed messages should be processed as normal reagrardless whether they arrive before or after StartDataCollectionCommand,lorenz.quack,orudyy,Closed,Fixed,2016-11-17 13:04,Java,Java Performance Tests,,,,,,,"In tests expecting to send and receive a pre-defined number of messages all received messages should be processed in the same way regardless whether they arrive before or after StartDataCollectionCommand. Otherwise, in some unlucky circumstances all or part of messages could be received before StartDataCollectionCommand arrival which causes tests to hang."
Bug,QPID-6189,12750750,[Java Common] 0-8/9/9-1 parser can cause stack overflow if a frame is broken into many TCP reads/writes,rgodfrey,rgodfrey,Closed,Fixed,2016-08-09 13:28,Java,Java Common,,,,,,,When an entire frame is split over many TCP reads/writes the 0-8/9/9-1 codec is effectively using tail recursion to iterate over the buffers to parse the whole frame.  When there are a lot of buffers this can cause stack overflow.  To guard against this we can simply squash the multiple buffers into a single buffer when we cross a threshold number of buffers.
Bug,QPID-6957,12923039,[Java Tests] LastValueQueueTest sporadically fails on cpp profile,,lorenz.quack,Closed,Fixed,2016-01-10 22:34,Java,Java Tests,,,,,,,"On the cpp profile the LastValueQueueTest sporadically fails because the semantics of LVQs for messages without a defined key differ from the Java broker's.
The Java broker [specifies|https://qpid.apache.org/releases/qpid-0.32/java-broker/book/Java-Broker-Management-Managing-Queues.html#Java-Broker-Management-Managing-Queues-Types-LVQ] that: {quote}Messages sent to an LVQ without the specified property will be delivered as normal and will never be ""replaced"".{quote}
The C++ broker does not document its behaviour in this case but seems to treat messages that do not set a key as having the same key.
Therefore, the shutdown messages in o.a.q.s.q.LastValueQueueTest#testParallelProductionAndConsumption replace each other and the second (or rather the first) message is never received by the consumer leading to a NPE:
{noformat}
testParallelProductionAndConsumption(org.apache.qpid.server.queue.LastValueQueueTest)  Time elapsed: 10.571 sec  <<< FAILURE!
junit.framework.AssertionFailedError: null
	at junit.framework.Assert.fail(Assert.java:55)
	at junit.framework.Assert.assertTrue(Assert.java:22)
	at junit.framework.Assert.assertNotNull(Assert.java:256)
	at junit.framework.Assert.assertNotNull(Assert.java:248)
	at junit.framework.TestCase.assertNotNull(TestCase.java:417)
	at org.apache.qpid.server.queue.LastValueQueueTest.receiveMessages(LastValueQueueTest.java:442)
	at org.apache.qpid.server.queue.LastValueQueueTest.testParallelProductionAndConsumption(LastValueQueueTest.java:405)
{noformat}"
Bug,QPID-6682,12852596,[Java Tests] SSLTest and ExternalAuthenticationTest always use AMQP 0-10 no matter which test profile is used,kwall,rgodfrey,Closed,Fixed,2015-08-12 20:13,Java,Java Tests,,,,,,,"Since SSLTest establishes a new port, the restrictions on which protocols are supported on the default port are not applied, so the attempt to establish a 0-10 connection by the client always succeeds... and SSL is never tested for AMQP 0-8/9/9-1"
Bug,QPID-6171,12749491,[Java Common] Connection.getChannels() leaks a potentially thread-unsafe data structure,rgodfrey,rgodfrey,Closed,Fixed,2015-03-19 12:23,Java,Java Common,,,,,,,"the collection returned by getChannels() may be modified by other threads, leading to unsafe iteration throwing ConcurrentModificationException.

The returned object should instead be a copy of the data and the underlying map should use a thread safe implementation to allow for the safe copying of the values() collection while another thread may be modifying the map."
Bug,QPID-6067,12738834,[Java Broker] Test BDBHAVirtualHostNodeOperationalLoggingTest.testRemoteNodeDetached fails sporadically,kwall,orudyy,Closed,Fixed,2015-03-19 12:23,Java,Java Tests,,,,,,,"The log for node leaving  the group only issued when role is changed from any value other then UNREACHABLE to UNREACHABLE .

Test does not wait or verify that remote node CO role attribute is set to REPLICA state. Thus, if node2 is stopped immediately after start, the remote node CO might not be able to detect the role change as it will be always in UNREACHABLE role.

Test needs to verify that remote node CO role is REPLICA before stopping the node.


Here is an example of test failure
{noformat}
Argument(s) are different! Wanted:

eventLogger.message(

    LogSubject does not match. Expected: [grp(/group)] , actual : [vh(/node2)/ms(BDBConfigurationStore)] ,

    Expected message does not match. Expected: HA-1006 : Left : Node : 'node2' (localhost:10001), actual: CFG-1003 : ClosedExpected hierarchy does not match. Expected: qpid.message.highavailability.left, actual: qpid.message.configstore.close

);

-> at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeOperationalLoggingTest.testRemoteNodeDetached(BDBHAVirtualHostNodeOperationalLoggingTest.java:272)

Actual invocation has different arguments:

eventLogger.message(

    org.apache.qpid.server.logging.subjects.MessageStoreLogSubject@794579f3,

    CFG-1003 : Closed

);

-> at org.apache.qpid.server.virtualhostnode.AbstractVirtualHostNode.closeConfigurationStore(AbstractVirtualHostNode.java:268)
{noformat}"
Bug,QPID-6231,12756112,[Perftests framework] Make performance framework fully JMS compatible,kwall,orudyy,Closed,Fixed,2015-03-19 12:22,Java,Java Performance Tests,,,,,,,"Pertests framework uses controller session where asynchronous message listener is set for creation and producing messages. Some JMS providers implemented checks to make sure that session with asynchronous message listener is not used for message producing. Thus, Pertests framework needs to be modified to be fully JMS complaint in order to be able to run it with any JMS implementation"
Bug,QPID-6104,12741747,Test ReplicatedEnvironmentFacadeTest.testRemoveNodeFromGroup fails sporadically,orudyy,orudyy,Closed,Fixed,2015-02-25 21:14,Java,Java Tests,,,,,,,"Error Message

(JE 5.0.97) Could not determine master from helpers at:[localhost/127.0.0.1:10000]

Stacktrace
{noformat}
com.sleepycat.je.rep.UnknownMasterException: (JE 5.0.97) Could not determine master from helpers at:[localhost/127.0.0.1:10000]
	at com.sleepycat.je.rep.elections.Learner.findMaster(Learner.java:437)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.getMasterSocket(ReplicationGroupAdmin.java:127)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.doMessageExchange(ReplicationGroupAdmin.java:449)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.getGroup(ReplicationGroupAdmin.java:262)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.checkMember(ReplicationGroupAdmin.java:407)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.removeMember(ReplicationGroupAdmin.java:244)
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacade.removeNodeFromGroup(ReplicatedEnvironmentFacade.java:814)
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacadeTest.testRemoveNodeFromGroup(ReplicatedEnvironmentFacadeTest.java:386)
{noformat}

DatabasePinger transaction was started when the second node environment was closed. Master was not assigned as designated primary.
As result, there was no majority and DatabasePinger transaction failed causing environment restart. Environment was not able to restart because there was no second node.

Setting ""designated primary"" on a Master node should resolve the test issue"
Bug,QPID-5943,12730737,[Java Broker] Test BDBHAVirtualHostNodeOperationalLoggingTest.testSetPriority fails sporadically,macbean,orudyy,Closed,Fixed,2014-09-26 15:43,Java,Java Tests,,,,,,,"Failed
org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeOperationalLoggingTest.testSetPriority

Failing for the past 3 builds (Since #194 ) 
Took 1.1 sec.

Error Message
Wanted but not invoked:
eventLogger.message(, );
-> at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeOperationalLoggingTest.testSetPriority(BDBHAVirtualHostNodeOperationalLoggingTest.java:184)
Actually, there were zero interactions with this mock.
Stacktrace
org.mockito.exceptions.verification.WantedButNotInvoked: 
Wanted but not invoked:
eventLogger.message(, );
-> at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeOperationalLoggingTest.testSetPriority(BDBHAVirtualHostNodeOperationalLoggingTest.java:184)
Actually, there were zero interactions with this mock.

	at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeOperationalLoggingTest.testSetPriority(BDBHAVirtualHostNodeOperationalLoggingTest.java:184)
"
Bug,QPID-5936,12730466,Tests from suite VirtualHostMessageStoreTest are failing on json test profiles when BDB VH is used,macbean,orudyy,Closed,Fixed,2014-09-26 15:43,Java,Java Tests,,,,,,,"In the test suite VirtualHostMessageStoreTest VH configuration store is created in the same location as a message store. BDB message store requires a sub-folder. JSON configuration store is stored in a file now. As result, sub-folder for BDB message store cannot be created in JSON configuration store location"
Bug,QPID-6053,12737764,[Java AMQP 1.0] Codec fails with exception when passed a byte[] to encode,rgodfrey,rgodfrey,Closed,Fixed,2014-09-26 15:43,Java,Java Common,,,,,,,The codec should encode a byte[] as an AMQP 1.0 binary object.
Bug,QPID-6077,12739703,[Java AMQP 1.0] Receiving messages where sender settles first causes memory leak,rgodfrey,rgodfrey,Closed,Fixed,2014-09-26 15:43,Java,Java Common,,,,,,,"[~fadams] discovered that soak testing the Java Broker sending AMQP 1.0 messages through the proton messenger javascript binding caused the Java broker to grow in memory usage continuously and eventually spend all its time trying to garbage collect.

The issue is that when a link is set up as sender settles, the unsettled state associated with a delivery is not all being cleared when the final settlement arrives from the sender."
Bug,QPID-5857,12724115,[Java Broker] Test ConsumerLoggingTest.testSubscriptionCreateQueue sporadically fails,kwall,orudyy,Closed,Fixed,2014-09-26 15:43,Java,Java Tests,,,,,,,"Test ConsumerLoggingTest.testSubscriptionCreateQueue sporadically fails:
{noformat}
testSubscriptionCreateQueueBrowser(org.apache.qpid.server.logging.ConsumerLoggingTest)  Time elapsed: 0.044 sec  <<< FAILURE!
junit.framework.AssertionFailedError: Result set larger than expected. expected:<5> but was:<2>
	at junit.framework.Assert.fail(Assert.java:57)
	at junit.framework.Assert.failNotEquals(Assert.java:329)
	at junit.framework.Assert.assertEquals(Assert.java:78)
	at junit.framework.Assert.assertEquals(Assert.java:234)
	at junit.framework.TestCase.assertEquals(TestCase.java:401)
	at org.apache.qpid.server.logging.ConsumerLoggingTest.testSubscriptionCreateQueueBrowser(ConsumerLoggingTest.java:181)
{noformat}"
Bug,QPID-5853,12723888,[Java Broker] System tests starting spawn broker(s) fail when the project location has spaces,kwall,orudyy,Closed,Fixed,2014-09-26 15:42,Java,Java Tests,,,,,,,"Tests starting spawn broker(s) fail when the project location has spaces
"
Bug,QPID-5875,12725453,[Java Tests] Test VirtualHostRestTest testPutCreateVirtualHostUsingProfileNodeType is failing because ProvidedStore virtual host cannot be used with JSON VHN,kwall,orudyy,Closed,Fixed,2014-07-04 16:07,Java,Java Tests,,,,,,,"{noformat}
qtp1061565585-20493 2014-07-04 04:50:38,574 WARN [plugin.servlet.rest.RestServlet] Caught exception
org.apache.qpid.server.configuration.IllegalConfigurationException: ProvidedStore virtual host can only be used where the node's store (org.apache.qpid.server.store.JsonFileConfigStore) is a message store provider. 
	at org.apache.qpid.server.virtualhost.ProvidedStoreVirtualHostImpl.onValidate(ProvidedStoreVirtualHostImpl.java:62)
	at org.apache.qpid.server.model.AbstractConfiguredObject.doValidation(AbstractConfiguredObject.java:531)
	at org.apache.qpid.server.model.AbstractConfiguredObject.create(AbstractConfiguredObject.java:472)
	at org.apache.qpid.server.model.AbstractConfiguredObjectTypeFactory.create(AbstractConfiguredObjectTypeFactory.java:58)
	at org.apache.qpid.server.model.AbstractConfiguredObjectTypeFactory.create(AbstractConfiguredObjectTypeFactory.java:31)
	at org.apache.qpid.server.model.ConfiguredObjectFactoryImpl.create(ConfiguredObjectFactoryImpl.java:112)
	at org.apache.qpid.server.virtualhostnode.AbstractStandardVirtualHostNode.addChild(AbstractStandardVirtualHostNode.java:63)
	at org.apache.qpid.server.model.AbstractConfiguredObject$10.execute(AbstractConfiguredObject.java:1078)
	at org.apache.qpid.server.model.AbstractConfiguredObject$10.execute(AbstractConfiguredObject.java:1072)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl.executeTask(TaskExecutorImpl.java:299)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl.access$400(TaskExecutorImpl.java:43)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl$CallableWrapper$1.run(TaskExecutorImpl.java:327)
	at java.security.AccessController.doPrivileged(Native Method)
	at javax.security.auth.Subject.doAs(Subject.java:356)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl$CallableWrapper.call(TaskExecutorImpl.java:322)
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:745)
{noformat}"
Bug,QPID-5478,12688891,[Java Common] IoSender may throw a timeout related SenderException earlier than it should,robbie,robbie,Closed,Fixed,2014-06-03 15:35,Java,Java Common,,,,,,,"IoSender may throw a timeout related SenderException earlier than it should, due to the timeout calculation accumlating successive interval values where it shouldn't. It isn't clear that this situation could really occur in actual use except via spurious wakeups, but it is a (long standing) bug either way."
Bug,QPID-5602,12698861,reduce severity and improve IOException logging in IoSender,rgodfrey,robbie,Closed,Fixed,2014-06-03 15:34,Java,Java Common,,,,,,,"IoSender emits an error message and a logs a Stacktrace when it exits due to an IoException, e.g due to a remote application being abruptly stopped.

Any issues stemming from the thread exiting result in their own exceptions being thrown and/or log messages being produced, so this logging is often duplicate and is typically not indicative of a problem needing intervention, it should be reduced in severity. It should also be improved to include the socket address, and remove the stacktrace which adds little benefit in this case and simply leads to unecessary confusion."
Bug,QPID-3868,12543817,Test org.apache.qpid.server.queue.TimeToLiveTest.testActiveTTL fails very occasionally on slow CI box.,kwall,kwall,Closed,Fixed,2014-01-01 15:56,Java,Java Tests,,,,,,,"Test org.apache.qpid.server.queue.TimeToLiveTest.testActiveTTL occasionally seen to fail on the java-bdb.0-9-1 profile on a slow CI box.

{code}
junit.framework.AssertionFailedError: Messages not automatically expired:  expected:<0> but was:<1>
	at org.apache.qpid.server.queue.TimeToLiveTest.testActiveTTL(TimeToLiveTest.java:207)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:237)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:138)
{code}"
Bug,QPID-4958,12655111,Java Performance Tests - race condition client registration detection causes tests to hang,philharveyonline,philharveyonline,Closed,Fixed,2013-09-08 13:37,Java,Java Performance Tests,,,,,,,"Occasionally various tests in ControllerAndClientTest fail with errors such as:

{noformat}
main 2013-06-25 14:39:25,539 ERROR [qpid.disttest.controller.TestRunner] Couldn't run test
org.apache.qpid.disttest.DistributedTestException: After 30000ms ... Timed out waiting for command responses ... Expecting 10 more responses.
    at org.apache.qpid.disttest.controller.TestRunner.awaitLatch(TestRunner.java:293)
    at org.apache.qpid.disttest.controller.TestRunner.awaitCommandResponses(TestRunner.java:183)
    at org.apache.qpid.disttest.controller.TestRunner.runParts(TestRunner.java:130)
    at org.apache.qpid.disttest.controller.TestRunner.run(TestRunner.java:103)
    at org.apache.qpid.disttest.controller.Controller.runAllTests(Controller.java:171)
    at org.apache.qpid.systest.disttest.controllerandclient.ControllerAndClientTest.runTestsForTwoClients(ControllerAndClientTest.java:195)
    at org.apache.qpid.systest.disttest.controllerandclient.ControllerAndClientTest.testProducerAndThreeConsumersInSeparateClients(ControllerAndClientTest.java:136)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
{noformat}

The relevant test log excerpts are shown below.

{noformat}
main 2013-06-25 14:38:35,357 INFO [qpid.disttest.controller.Controller] Awaiting client registrations
...
908 Dispatcher-1-Conn-2 2013-06-25 14:38:35,448 INFO [qpid.disttest.controller.ClientRegistry] Client registered: 63a95928-7d12-48ad-9326-133da9a0ddb6
...
920 Dispatcher-1-Conn-2 2013-06-25 14:38:35,450 INFO [qpid.disttest.controller.ClientRegistry] Client registered: 2510ce56-20d4-43a2-84db-193a87b1cfec
...
{noformat}

Client thread timing out after the 5 seconds set by the JUnit test:
{noformat}
997 2510ce56-20d4-43a2-84db-193a87b1cfec-thread 2013-06-25 14:38:40,423 DEBUG [apache.qpid.client.AMQSession] Closing session: org.apache.qpid.client.AMQSes sion_0_8@5e111b5c
{noformat}

Controller sends test set-up commands, 20 seconds after ""Awaiting client registrations"". This happens to be the length of the client registration time-out, suggesting that the ""await client registrations"" code didn't notice that client registrations.

{noformat}
1080 main 2013-06-25 14:38:55,476 DEBUG [qpid.disttest.controller.TestRunner] About to send 10 command(s) 
{noformat}

"
Bug,QPID-4904,12650620,[Java] AMQShortString.equals should not return true if it is not being compared to another AMQShortString,rgodfrey,rgodfrey,Resolved,Fixed,2013-06-03 15:49,Java,Java Common,,,,,,,"Currently AMQShortString.equals will return true if it is passed an instance of CharSequence which contains the same character sequence as the AMQShortString, however this means that a.equals(b) != b.equals(a) if a is an AMQShortString and b is (for example) a String.  This is an violation of the expected contract from equals."
Bug,QPID-3794,12540567,Test StatisticsCounterTest.testPeakOutOfOrder fails sporadically on test profile java-mms-spawn.0-10 ,robbie,orudyy,Resolved,Fixed,2012-02-04 15:30,Java,Java Tests,,,,,,,"Test StatisticsCounterTest.testPeakOutOfOrder fails sporadically on test profile java-mms-spawn.0-10 

junit.framework.AssertionFailedError: expected:<0.0> but was:<3000.0>
	at org.apache.qpid.server.stats.StatisticsCounterTest.testPeakOutOfOrder(StatisticsCounterTest.java:110)
"
Bug,QPID-3781,12539839,MaxDeliveryCountTest occasionally seen to fail on java-bdb.0-10 profile,robbie,kwall,Resolved,Fixed,2012-02-03 10:37,Java,Java Tests,,,,,,,"I've seen this test fail a couple of times over the last couple of days on my home machine when running the java-bdb.0-10 profile.

{code}
testAsynchronousDupsOkSession	Failure	The queue should have 0 msgs left expected:<0> but was:<1>

junit.framework.AssertionFailedError: The queue should have 0 msgs left expected:<0> but was:<1>
at org.apache.qpid.test.unit.client.MaxDeliveryCountTest.doTest(MaxDeliveryCountTest.java:301)
at org.apache.qpid.test.unit.client.MaxDeliveryCountTest.testAsynchronousDupsOkSession(MaxDeliveryCountTest.java:198)
at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:237)
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:135)
{code}"
Bug,QPID-1573,12412299,Not all systests are systests,,aidan,Closed,Fixed,2011-09-05 21:51,Java,Java Tests,,,,,,,"Not all of the classes in systests are really systests, some of them are unit tests that should live in their appropriate module"
Bug,QPID-2011,12431697,AlertingTest.testAlertingReallyWorksWithChanges does not test desired functionality.,,ritchiem,Closed,Fixed,2011-09-05 21:51,Java,Java Tests,,,,,,,"This alerting test has a number of problems the main ones that are causing the test to pass with incorrectly are:
1) It does not correctly set the new configuration value.
2) The previous tests do not consume the published messages so that the data carries forward to the next test

The test needs to validate that the broker is in the right state.
 - message count
 - alerting levels (where possible)
 - log file contains expected values.
 - alerting occurs when expected.
 - unconsumed messages do not affect subsequent tests."
Bug,QPID-2242,12442481,JMS_QPID_DESTTYPE is not set making getJMSDestination unusable.,,ritchiem,Closed,Fixed,2011-09-05 21:51,Java,Java Common,JMS AMQP 0-x,,,,,,"The problem is that Qpid M2.1 (and earlier) sets the JMS_QPID_DESTTYPE header property before sending. 
If you try and do that on a message that doesn't have the property set then it will attempt to write it into the _encodedForm ByteBuffer if there is one.

In the scenario where you are receiving messages and then re-sending them not creating new ones. The header has already been read so the buffer limit and position are the same which means any write to the buffer will throw a BufferOverflowException. In short the headers are Read Only.

I have tested with M2.1 After the merge to trunk for M3 the setting of this property was removed. Which does mean that the JMS Destination is marked as 'unknown' rather than 'direct' which means if you attempted to do message.getJMSDestination() to send the message back in to the queue for reprocessing it would fail.

Further investigations:
Understand why this setting was dropped after the Merge from M2.x to trunk. This property is used to control the type of Destination that message.getJMSDestination() returns.

Need to check M1 to see if it sets the value on sent Messages.

Also need to check how the 0-10 code path defines the JMSDestination() as it too appears to never to have a value set and so will be an 'unknown' destination."
Bug,QPID-2583,12463980,Update tests to throw ConfigurationExceptions,ritchiem,ritchiem,Resolved,Fixed,2010-12-01 22:45,Java,Java Tests,,,,,,,"ConfigurationException is now properly propogated during ServerConfiguration setup. This was previously done at a later stage, we now throw ConfigurationException before the broker is initialised in the ApplicationRegistry so the tests that used ServerConfiguration classes must now be updated to process the exception, currently there is no error path handling so adding a throw to the test methods will be sufficient."
Bug,QPID-1225,12401986,DupsOk doesn't fail if it times out waiting for messages to be recieved.,ritchiem,ritchiem,Resolved,Fixed,2008-08-08 12:23,Java,Java Tests,,,,,,,"DupsOk ignores the return of the _awaitCompleted.await call so we are not notified when the test fails, due to the lack of messages arriving."
Bug,QPID-861,12391884,Java RFC 1982 implementation,,rhs,Resolved,Fixed,2008-07-23 14:39,Java,Java Common,,,,,,,RFC 1982 number implementation is required for the common session implementation to be correct. (Currently it just uses regular numbers and ignores wraparound.)
Bug,QPID-872,12392171,TimeToLiveTest has unreasonably short timeouts on receive,ritchiem,ritchiem,Closed,Fixed,2008-07-07 11:27,Java,Java Tests,,,,,,,"Summary:

The test uses receive(100) but on my laptop it takes just over 100ms to process the 48 purged messages. We should define a standard time to wait for tests but failing that just now setting it to 1s(1000) should be sufficent for most cases."
Bug,QPID-841,12390472,SimpleACLTest fails due to missing file,ritchiem,ritchiem,Closed,Fixed,2008-07-07 11:25,Java,Java Tests,,,,,,,"Summary:
When running the systests the SimpleACLTest will fail one of its 17 tests as it cannot locate a file on disk that has worked with fine for the other 16 tests."
Bug,QPID-632,12380094,ImmediateMessageTest fails occasionally because AMQNoConsumersException  was not received.,ritchiem,ritchiem,Closed,Fixed,2008-07-07 11:25,Java,Java Tests,JMS AMQP 0-x,,,,,,"Occassionally I've seen this error
junit.framework.AssertionFailedError: Was expecting linked exception type org.apache.qpid.client.AMQNoConsumersException on the connection. 
Got no exceptions on the connection.
"
Bug,QPID-343,12361832,Performance test suite doesn't output missing message count on failure.,ritchiem,ritchiem,Closed,Fixed,2008-07-07 11:03,Java,Java Performance Tests,,,,,,,Currently on failure a 0 count is written to the log file.
Bug,QPID-993,12395091,org.apache.qpid.server.plugins.PluginTest is failing on trunk,rajith,rajith,Closed,Fixed,2008-07-04 3:13,Java,Java Tests,,,,,,,"The test org.apache.qpid.server.plugins.PluginTest in systest is failing initially as we don't set the ""example.plugin.target"" system property.
The test loads a plugin jar created by broker-plugins and test for the presence of the exchanges loaded by the plugin.
However the current ant build doesn't include broker-plugins module.
Once that is added and the proper paths are set for a plugin dir, the test still fails.
The ServiceTracker seems to load the jar without any errors, however when you do a .getServices() it returns a null indicating that it could not recognized the plugins from the jar."
Bug,QPID-992,12395089,SimpleACLTest fails in trunk,rajith,rajith,Closed,Fixed,2008-07-04 3:11,Java,Java Tests,,,,,,,"The org.apache.qpid.server.security.acl.SimpleACLTest in systests is failing as the temporary queue created has the form TempQueue*.
The acl.config under PUBLISH, for user ""server""  has permission for routing keys of the form tmp_*.
In order to get the test passing I will add TempQueue* under routing keys allowed for publish for user ""server""
However I believe we had a thread discussing about how the java client should name temp queues. 
Once we come to a consensus and it is implemented, I will update the acl.config to reflect that."
Bug,QPID-575,12377491,sync() called on the MINA thread should throw an exception,rhs,rajith,Closed,Fixed,2008-07-04 2:53,Java,Java Common,,,,,,,"If sync() is called on the MINA thread it should throw an exception.
If not this will cause a severe deadlock.

when sync() is called on the MINA thread, it will block until the sync returns.
however the MINA thread is unable to process the execution.complete sent by the broker as it hasn't received.
since the execution.complete is not processed, the sync call never returns.
hence there exists a deadlock.

Rajith"
Bug,QPID-899,12393012,[Java Common] Bug in AMQShortString on tokenized substrings,rgodfrey,rgodfrey,Resolved,Fixed,2008-04-16 8:26,Java,Java Common,,,,,,,"the tokenizer on AMQShortString creates substrings backed by the same array.  Unfortunately some methods on AMQShortString do not handle backing arrays with non-zero start offsets correctly (namely toIntValue and tokenize itself).

Luckily nowhere in the M2.1 code is tokenize() or toIntValue() called on a AMQShortString which is itself the product of a tokenization.

Therefore this bug should not stop the M2.1 release.

"
Bug,QPID-878,12392339,"Some tests are not run by ant as their class name does not end by ""Test""",arnaudsimon,arnaudsimon,Closed,Fixed,2008-04-02 13:04,Java,Java Tests,,,,,,,"This is case of: 
org.apache.qpid.test.unit.basic.close.CloseTests
and 
org.apache.qpid.test.unit.ct.DurableSubscriberTests

I would suggest we rename those 2 classes. 

"
Bug,QPID-836,12390367,ConnectionTest fails on Windows,,arnaudsimon,Closed,Fixed,2008-03-28 12:57,Java,Java Tests,,,,,,,"This is because the host ""0.0.0.0"" is not known on Windows. I would suggest we use ""localhost"" instead. "
Bug,QPID-598,12378041,Intermittent  TransactedTest Failure,,ritchiem,Closed,Fixed,2008-02-04 12:19,Java,Java Tests,,,,,,,"Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 3.671 sec <<< FAILURE!
testRollback(org.apache.qpid.test.unit.transacted.TransactedTest)  Time elapsed: 0.562 sec  <<< FAILURE!
junit.framework.ComparisonFailure: Message content does not match expected expected:<A> but was:<C>
        at junit.framework.Assert.assertEquals(Assert.java:81)
        at org.apache.qpid.test.unit.transacted.TransactedTest.expect(TransactedTest.java:306)
        at org.apache.qpid.test.unit.transacted.TransactedTest.testRollback(TransactedTest.java:199)

As this is related to Rollback and was seen with the fix for the CSDM ordering issue in place I would say the culprit here is the rollback mechanism. Did QPID-573 fully address rollback issues?"
Bug,QPID-597,12378040,TopicSessionTest failure,,aidan,Closed,Fixed,2008-02-04 11:52,Java,Java Tests,,,,,,,"testNoLocal(org.apache.qpid.test.unit.topic.TopicSessionTest)  Time elapsed: 2.1
25 sec  <<< FAILURE!
junit.framework.AssertionFailedError
        at junit.framework.Assert.fail(Assert.java:47)
        at junit.framework.Assert.assertTrue(Assert.java:20)
        at junit.framework.Assert.assertNotNull(Assert.java:220)
        at junit.framework.Assert.assertNotNull(Assert.java:213)
        at org.apache.qpid.test.unit.topic.TopicSessionTest.testNoLocal(TopicSes
sionTest.java:338)
"
Bug,QPID-596,12378039,Intermittent ConnectionStartTest Failure,,ritchiem,Closed,Fixed,2008-02-04 11:51,Java,Java Tests,,,,,,,"A timeout is not very helpful at all. Sorry. This poor error will be done to QPID-594

Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 31.078 sec <<< FAILURE!
testSimpleReceiveConnection(org.apache.qpid.test.unit.client.connection.ConnectionStartTest)  Time elapsed: 30.031 sec  <<< FAILURE!
junit.framework.AssertionFailedError: Connection to vm://:1 should succeed. Reason: javax.jms.JMSException: Error closing session: org.apache.qpid.AMQTimeoutException: Server did not respond in a timely fashion [error code 408: Request Timeout]
        at junit.framework.Assert.fail(Assert.java:47)
        at org.apache.qpid.test.unit.client.connection.ConnectionStartTest.setUp(ConnectionStartTest.java:80)
        at junit.framework.TestCase.runBare(TestCase.java:125)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.junit.JUnitTestSet.execute(JUnitTestSet.java:210)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:135)
        at org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:122)
        at org.apache.maven.surefire.Surefire.run(Surefire.java:129)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:225)
        at org.apache.maven.surefire.booter.SurefireBooter.run(SurefireBooter.java:139)
        at org.apache.maven.plugin.surefire.SurefirePlugin.execute(SurefirePlugin.java:376)
        at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:412)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:534)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:475)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:454)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:306)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:273)
        at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:140)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:322)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:115)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:256)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
        at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
        at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
        at org.codehaus.classworlds.Launcher.main(Launcher.java:375)
"
Bug,QPID-631,12380093,MessageRequeueTest is overzealous checking state,,aidan,Resolved,Fixed,2007-12-12 14:29,Java,Java Tests,,,,,,,"Sometimes the VMBroker is not in the cleanest of states following prior tests and testCompetingConsumers checks for exactly receving the number of messages, rather than receiving all of them. "
Bug,QPID-382,12363241,"When mvn is run on perftests/disctribution dir, it fails because the test-jar is not being available.",bhupendrab,bhupendrab,Resolved,Fixed,2007-02-21 9:22,Java,Java Performance Tests,,,,,,,"The distribution depends on test-jar, which is not being created thorugh perftests module pom."
Bug,QPID-361,12362565,Performance testing,bhupendrab,bhupendrab,Resolved,Fixed,2007-02-20 16:33,Java,Java Performance Tests,,,,,,,"Following error is thrown when LT-Qpid-3-1M.sh (script generated by perftests/pom.xml) is run

java -Xms256m -Dlog4j.configuration=perftests.log4j -Xmx512m -Dbadger.level=warn -Damqj.test.logging.level=info -Damqj.logging.level=warn ${JAVA_OPTS} -cp qpid-perftests-1.0-incubating-M2-SNAPSHOT-all-test-deps.jar uk.co.thebadgerset.junit.extensions.TKTestRunner -n LT-Qpid-3-1M -s [900000] -o . -t testAsyncPingOk org.apache.qpid.ping.PingAsyncTestPerf BatchSize=10000 messagesize=1048576 transacted=true ${ARGS}



ERROR [org.apache.qpid.client.BasicMessageConsumer] reNotification : Caught exception (dump follows) - ignoring...
org.apache.qpid.client.failover.FailoverException: Failing over about to start
        at org.apache.qpid.client.failover.FailoverHandler.run(FailoverHandler.java:78)
        at java.lang.Thread.run(Thread.java:595)
E
Time: 8.19
There was 1 error:
1) testAsyncPingOk(org.apache.qpid.ping.PingAsyncTestPerf)org.apache.qpid.client.failover.FailoverException: Failing over about to start
        at org.apache.qpid.client.failover.FailoverHandler.run(FailoverHandler.java:78)
        at java.lang.Thread.run(Thread.java:595)"
Bug,QPID-327,12361480,[race condition] PoolingFilter : Possible race condition when completing a Job,rgodfrey,rgodfrey,Resolved,Fixed,2007-02-15 16:17,Java,Java Common,,,,,,,"In the following code:

    //Job.JobCompletionHandler
    public void completed(IoSession session, Job job)
    {
        if (job.isComplete())
        {
            job.release();
            if (!job.isReferenced())
            {
                _jobs.remove(session);
            }
        }
 

Another thread could acquire() the job between the call to job.isReferenced() and _jobs.remove(session);"
Bug,QPID-358,12362513,Field table encoding: types i and I are the wrong way round,rgodfrey,rgodfrey,Resolved,Fixed,2007-02-15 16:15,Java,Java Common,,,,,,,Currently the type i is being used for signed integers and I for unsigned integers.  This is incorrect and should be reversed.
Bug,QPID-180,12358525,PropertyFieldTable could be optimised,ritchiem,rgreig,Resolved,Fixed,2006-12-15 8:45,Java,Java Common,,,,,,,"The new implementation of field table has heavy reliance on substring functions for type information. This could be improved by using an enum instead.

Also, does FieldTable interface need to extend Map?"
Bug,QPID-7185,12956119,ReplicatedEnvironmentFacadeTest.testReplicationGroupListenerHearsNodeRemoved fails sporadically on Apache CI,orudyy,kwall,Closed,Fixed,2019-10-02 19:21,Java,Java Tests,,,,,,,"The test {{testReplicationGroupListenerHearsNodeRemoved}} failed in the following way on the Apache CI host:

{noformat}
org.apache.qpid.server.store.StoreException: Exception on node removal from group
	at com.sleepycat.je.EnvironmentFailureException.unexpectedState(EnvironmentFailureException.java:426)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.getException(ReplicationGroupAdmin.java:504)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.doMessageExchange(ReplicationGroupAdmin.java:474)
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.removeMember(ReplicationGroupAdmin.java:245)
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacade.removeNodeFromGroup(ReplicatedEnvironmentFacade.java:1284)
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacadeTest.testReplicationGroupListenerHearsNodeRemoved(ReplicatedEnvironmentFacadeTest.java:377)
{noformat}

The underlying exception was as follows:

{noformat}
2016-04-03 23:19:00,667 ERROR [main] o.a.q.s.u.ServerScopedRuntimeException Exception on node removal from group
com.sleepycat.je.EnvironmentFailureException: (JE 5.0.104) (JE 5.0.104) Transaction -20 cannot execute write operations because this node is no longer a master UNEXPECTED_STATE: Unexpected internal state, may have side effects.
	at com.sleepycat.je.EnvironmentFailureException.unexpectedState(EnvironmentFailureException.java:426) ~[je-5.0.104.jar:5.0.104]
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.getException(ReplicationGroupAdmin.java:504) ~[je-5.0.104.jar:5.0.104]
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.doMessageExchange(ReplicationGroupAdmin.java:474) ~[je-5.0.104.jar:5.0.104]
	at com.sleepycat.je.rep.util.ReplicationGroupAdmin.removeMember(ReplicationGroupAdmin.java:245) ~[je-5.0.104.jar:5.0.104]
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacade.removeNodeFromGroup(ReplicatedEnvironmentFacade.java:1284) ~[classes/:na]
	at org.apache.qpid.server.store.berkeleydb.replication.ReplicatedEnvironmentFacadeTest.testReplicationGroupListenerHearsNodeRemoved(ReplicatedEnvironmentFacadeTest.java:377) [test-classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_80]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_80]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_80]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_80]
	at junit.framework.TestCase.runTest(TestCase.java:176) [junit-4.11.jar:na]
	at org.apache.qpid.test.utils.QpidTestCase.runTest(QpidTestCase.java:171) [qpid-test-utils-6.1.0-SNAPSHOT.jar:6.1.0-SNAPSHOT]
	at junit.framework.TestCase.runBare(TestCase.java:141) [junit-4.11.jar:na]
	at junit.framework.TestResult$1.protect(TestResult.java:122) [junit-4.11.jar:na]
	at junit.framework.TestResult.runProtected(TestResult.java:142) [junit-4.11.jar:na]
	at junit.framework.TestResult.run(TestResult.java:125) [junit-4.11.jar:na]
	at junit.framework.TestCase.run(TestCase.java:129) [junit-4.11.jar:na]
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:156) [qpid-test-utils-6.1.0-SNAPSHOT.jar:6.1.0-SNAPSHOT]
	at junit.framework.TestSuite.runTest(TestSuite.java:255) [junit-4.11.jar:na]
	at junit.framework.TestSuite.run(TestSuite.java:250) [junit-4.11.jar:na]
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84) [junit-4.11.jar:na]
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:200) [surefire-booter-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153) [surefire-booter-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103) [surefire-booter-2.17.jar:2.17]
{noformat}

The node that was the target of the {{ReplicationGroupAdmin.removeMember}} call was at that moment being restarted as majority had been lost.  This seems to have provoked an unexpected exception from within JE.

The test is concerned with ensuring the listener fires correctly in response to changes in group membership.  This test can avoid the possibility of a mastership loss simply by setting designated primary to true.

As changing the consistency of a group whilst a production system is live would be an unusual thing to do, this chances of this manifesting in production are small.  If it were to happen, a node restart would be required to restore service.
"
Bug,QPID-7122,12946948,CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection fails sporadically on slow CI,,kwall,Closed,Fixed,2019-10-02 19:21,Java,Java Tests,,,,,,,"The following test failed on Apache CI:

https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-BDB-TestMatrix/2155/jdk=JDK%201.7%20(latest),label=Ubuntu,profile=java-bdb.0-9-1/testReport/junit/org.apache.qpid.test.client/CloseOnNoRouteForMandatoryMessageTest/testNoRoute_brokerClosesConnection/

The test is race because it depends on how quickly the socket is closed after the connection level exception.

{noformat}
org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection

Failing for the past 1 build (Since Failed#2155 )
Took 0.71 sec.
add description
Error Message

javax.jms.JMSException: Session exception occurred while trying to commit: sender for socket /127.0.0.1:47193-localhost/127.0.0.1:33467 is closed message should contain intended queue name
Stacktrace

java.lang.AssertionError: javax.jms.JMSException: Session exception occurred while trying to commit: sender for socket /127.0.0.1:47193-localhost/127.0.0.1:33467 is closed message should contain intended queue name
	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.assertTrue(Assert.java:41)
	at org.apache.qpid.test.client.UnroutableMessageTestExceptionListener.assertNoRoute(UnroutableMessageTestExceptionListener.java:140)
	at org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection(CloseOnNoRouteForMandatoryMessageTest.java:90)
Standard Output

18:51:19,397 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.FileAppender]
18:51:19,397 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [FILE-org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection]
18:51:19,397 |-INFO in ch.qos.logback.core.joran.action.NestedComplexPropertyIA - Assuming default type [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for [encoder] property
18:51:19,398 |-INFO in ch.qos.logback.core.FileAppender[FILE-org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection] - File property is set to [/home/jenkins/jenkins-slave/workspace/Qpid-Java-Java-BDB-TestMatrix/jdk/JDK 1.7 (latest)/label/Ubuntu/profile/java-bdb.0-9-1/systests/target/surefire-reports/java-bdb.0-9-1/TEST-org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection.txt]
{noformat}


Stack trace:


{noformat}
javax.jms.JMSException: Session exception occurred while trying to commit: sender for socket /127.0.0.1:47193-localhost/127.0.0.1:33467 is closed
	at org.apache.qpid.client.AMQSession.toJMSException(AMQSession.java:3701) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQSession.commit(AMQSession.java:880) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.test.client.CloseOnNoRouteForMandatoryMessageTest.testNoRoute_brokerClosesConnection(CloseOnNoRouteForMandatoryMessageTest.java:78) ~[test-classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_80]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_80]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_80]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_80]
	at junit.framework.TestCase.runTest(TestCase.java:176) [junit-4.11.jar:na]
	at org.apache.qpid.test.utils.QpidTestCase.runTest(QpidTestCase.java:171) [qpid-test-utils-6.1.0-SNAPSHOT.jar:na]
	at junit.framework.TestCase.runBare(TestCase.java:141) [junit-4.11.jar:na]
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:138) [classes/:na]
	at junit.framework.TestResult$1.protect(TestResult.java:122) [junit-4.11.jar:na]
	at junit.framework.TestResult.runProtected(TestResult.java:142) [junit-4.11.jar:na]
	at junit.framework.TestResult.run(TestResult.java:125) [junit-4.11.jar:na]
	at junit.framework.TestCase.run(TestCase.java:129) [junit-4.11.jar:na]
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:156) [qpid-test-utils-6.1.0-SNAPSHOT.jar:na]
	at junit.framework.TestSuite.runTest(TestSuite.java:255) [junit-4.11.jar:na]
	at junit.framework.TestSuite.run(TestSuite.java:250) [junit-4.11.jar:na]
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84) [junit-4.11.jar:na]
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124) [surefire-junit4-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:200) [surefire-booter-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153) [surefire-booter-2.17.jar:2.17]
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103) [surefire-booter-2.17.jar:2.17]
Caused by: org.apache.qpid.transport.SenderClosedException: sender for socket /127.0.0.1:47193-localhost/127.0.0.1:33467 is closed
	at org.apache.qpid.transport.network.io.IoSender.checkNotAlreadyClosed(IoSender.java:383) ~[qpid-common-6.1.0-SNAPSHOT.jar:6.1.0-SNAPSHOT]
	at org.apache.qpid.transport.network.io.IoSender.send(IoSender.java:128) ~[qpid-common-6.1.0-SNAPSHOT.jar:6.1.0-SNAPSHOT]
	at org.apache.qpid.framing.AMQFrame.writePayload(AMQFrame.java:67) ~[qpid-common-6.1.0-SNAPSHOT.jar:6.1.0-SNAPSHOT]
	at org.apache.qpid.client.AMQProtocolHandler.writeFrame(AMQProtocolHandler.java:557) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQProtocolHandler.writeFrame(AMQProtocolHandler.java:550) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQProtocolHandler.writeCommandFrameAndWaitForReply(AMQProtocolHandler.java:633) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:657) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQProtocolHandler.syncWrite(AMQProtocolHandler.java:651) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQSession_0_8.commitImpl(AMQSession_0_8.java:276) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	at org.apache.qpid.client.AMQSession.commit(AMQSession.java:866) ~[qpid-client-6.1.0-SNAPSHOT.jar:na]
	... 23 common frames omitted
{noformat}
"
Bug,QPID-7888,13094140,[Java Client] [Documentation] Correct typo in end to end encryption connection url examples,kwall,kwall,Closed,Fixed,2019-10-02 19:20,Java,Java Documentation,JMS AMQP 0-x,,,,,,"As highlighted by this thread:

https://stackoverflow.com/questions/45583101/encrypted-messages-using-apache-qpid

there is a typo in the connection urls used in the example."
Bug,QPID-5798,12718120,Intermittent failure of FailoverBehaviourTest due to race condition with test,,macbean,Closed,Fixed,2019-10-02 19:20,Java,Java Tests,,,,,,,"The test org.apache.qpid.client.failover.FailoverBehaviourTest.testAutoAcknowledgedQueueBrowserCloseWhileFailover is intermittently failing under the BDB 0-9 profile.

The issue appears to be that the prepareQueueBrowser() method fails to take into account that without a forced sync (for non transacted ack modes) there is a race between the producerSession and the queueBrowsers check for the messages on the broker.  Adding a sync for the non transacted ack mode cases should resolve this."
Bug,QPID-6768,12902319,Avoid unnecessary message payload copy during send (0-8...0-91),,kwall,Resolved,Fixed,2019-10-02 19:20,Java,Java Common,JMS AMQP 0-x,,,,,,"The {{org.apache.qpid.framing.ContentBody#writePayload(java.io.DataOutput)}} method (on the client's publish path when using 0-8..0-91) always copies the payload before writing to the {{DataOutput}}.  The underlying byte buffer is expected to be a heap byte buffer and so will have a backing array, so the copy can be optimised away in this case."
Bug,QPID-7226,12961579,[Java Broker] [BDB HA] BDBHAVirtualHostNodeTest.testIntruderConnected test failed with ReplicaConsistencyException ,orudyy,kwall,Closed,Fixed,2019-10-02 19:20,Java,Java Tests,,,,,,,"The 'intruder' node timed out (on construction of the {{ReplicatedEnvironment}} with the following stack trace.  The remainder of the group had already (correctly) shut themselves down in response to the unexpected node.    It seem the {{ReplicaConsistencyException}} is another legitimate way the intruder node can fail, which, up until now the test didn't anticipate.

{noformat}
    <error message=""(JE 5.0.104) Unable to achieve consistency despite waiting for 300000 ms."" type=""com.sleepycat.je.rep.ReplicaConsistencyException""><![CDATA[com.sleepycat.je.rep.ReplicaConsistencyException: (JE 5.0.104) Unable to achieve consistency despite waiting for 300000 ms.
	at com.sleepycat.je.rep.impl.node.Replica$ConsistencyTracker.await(Replica.java:1396)
	at com.sleepycat.je.rep.impl.node.Replica$ConsistencyTracker.awaitVLSN(Replica.java:1372)
	at com.sleepycat.je.rep.impl.PointConsistencyPolicy.ensureConsistency(PointConsistencyPolicy.java:79)
	at com.sleepycat.je.rep.impl.node.RepNode.joinAsReplica(RepNode.java:1909)
	at com.sleepycat.je.rep.impl.node.RepNode.joinGroup(RepNode.java:1827)
	at com.sleepycat.je.rep.impl.RepImpl.joinGroup(RepImpl.java:506)
	at com.sleepycat.je.rep.ReplicatedEnvironment.joinGroup(ReplicatedEnvironment.java:479)
	at com.sleepycat.je.rep.ReplicatedEnvironment.<init>(ReplicatedEnvironment.java:532)
	at com.sleepycat.je.rep.ReplicatedEnvironment.<init>(ReplicatedEnvironment.java:397)
	at com.sleepycat.je.rep.ReplicatedEnvironment.<init>(ReplicatedEnvironment.java:461)
	at org.apache.qpid.server.store.berkeleydb.BDBHAVirtualHostNodeTest.joinIntruder(BDBHAVirtualHostNodeTest.java:821)
	at org.apache.qpid.server.store.berkeleydb.BDBHAVirtualHostNodeTest.testIntruderConnected(BDBHAVirtualHostNodeTest.java:795)
{noformat}"
Bug,QPID-7459,13012319,ProducerFlowControlTest#testSendTimeout test fails sprodically on 0-10 profiles,,kwall,Closed,Fixed,2017-06-20 16:20,Java,Java Tests,,,,,,,"ProducerFlowControlTest#testSendTimeout test fails sprodically on 0-10 profiles.  

The test is racey.  The test relies on message n-1 causing flow control to be imposed before the test can try to send message n.  If flow control is not imposed before the client tries to send message n, the test will fail.  In the failing case the client has not processed the incoming MessageStop before it sends message n.   The test tries tries to prevent this by sync'ing twice.  This approach is ineffective for 0-10 as the send sync to optimised out and does not caused an ExecutionSync.

The test issue does not affect the usefulness of the feature itself.


https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-Test-JDK1.8/1801/artifact/trunk/systests/target/surefire-reports/java-mms.0-10/

{noformat}
junit.framework.AssertionFailedError: No timeout exception on sending
	at junit.framework.Assert.fail(Assert.java:57)
	at junit.framework.Assert.assertTrue(Assert.java:22)
	at junit.framework.Assert.assertNotNull(Assert.java:256)
	at junit.framework.TestCase.assertNotNull(TestCase.java:426)
	at org.apache.qpid.server.queue.ProducerFlowControlTest.testSendTimeout(ProducerFlowControlTest.java:284)
{noformat}

"
Bug,QPID-4062,12560372,Java system tests sometimes fail due to JMX port already initialised,rgodfrey,philharveyonline,Closed,Fixed,2017-03-14 20:13,Java,Java Tests,,,,,,,"I'm often seeing errors such as this:

{noformat}
java.rmi.server.ExportException: Port already in use: 18999; nested exception is: 
	java.net.BindException: Address already in use
	at sun.rmi.transport.tcp.TCPTransport.listen(TCPTransport.java:310)
	at sun.rmi.transport.tcp.TCPTransport.exportObject(TCPTransport.java:218)
	at sun.rmi.transport.tcp.TCPEndpoint.exportObject(TCPEndpoint.java:393)
	at sun.rmi.transport.LiveRef.exportObject(LiveRef.java:129)
	at sun.rmi.server.UnicastServerRef.exportObject(UnicastServerRef.java:190)
	at sun.rmi.registry.RegistryImpl.setup(RegistryImpl.java:92)
	at sun.rmi.registry.RegistryImpl.<init>(RegistryImpl.java:68)
	at java.rmi.registry.LocateRegistry.createRegistry(LocateRegistry.java:222)
	at org.apache.qpid.server.management.JMXManagedObjectRegistry.start(JMXManagedObjectRegistry.java:215)
	at org.apache.qpid.server.registry.ApplicationRegistry.initialise(ApplicationRegistry.java:311)
	at org.apache.qpid.server.registry.ApplicationRegistry.initialise(ApplicationRegistry.java:202)
	at org.apache.qpid.server.Broker.startupImpl(Broker.java:123)
	at org.apache.qpid.server.Broker.startup(Broker.java:97)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.startBroker(QpidBrokerTestCase.java:394)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.startBroker(QpidBrokerTestCase.java:354)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.startBroker(QpidBrokerTestCase.java:349)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.setUp(QpidBrokerTestCase.java:295)
	at org.apache.qpid.management.jmx.MessageStatisticsTestCase.setUp(MessageStatisticsTestCase.java:61)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:237)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:139)
Caused by: java.net.BindException: Address already in use
	at java.net.PlainSocketImpl.socketBind(Native Method)
	at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:365)
	at java.net.ServerSocket.bind(ServerSocket.java:319)
	at java.net.ServerSocket.<init>(ServerSocket.java:185)
	at java.net.ServerSocket.<init>(ServerSocket.java:97)
	at sun.rmi.transport.proxy.RMIDirectSocketFactory.createServerSocket(RMIDirectSocketFactory.java:27)
	at sun.rmi.transport.proxy.RMIMasterSocketFactory.createServerSocket(RMIMasterSocketFactory.java:333)
	at sun.rmi.transport.tcp.TCPEndpoint.newServerSocket(TCPEndpoint.java:649)
	at sun.rmi.transport.tcp.TCPTransport.listen(TCPTransport.java:299)

{noformat}
"
Bug,QPID-1803,12422607,FileUtils recursive delete may throw NullPointerException if files are deleted outside of the JVM,ritchiem,ritchiem,Closed,Fixed,2017-03-14 20:12,Java,Java Common,,,,,,,"Summary:

When performing a recursive delete if a file that java has not yet processed is deleted then a NPE will be thrown an example of this can be seen when the FtD code is clearing the queueBacking store and the user is performing an rm -rf of the backing store at the same time:

java.lang.NullPointerException
        at org.apache.qpid.util.FileUtils.delete(FileUtils.java:253)
        at org.apache.qpid.util.FileUtils.delete(FileUtils.java:255)
        at org.apache.qpid.util.FileUtils.delete(FileUtils.java:255)
        at org.apache.qpid.server.queue.FileQueueBackingStoreFactory.setFlowToDisk(FileQueueBackingStoreFactory.java:87)
        at org.apache.qpid.server.queue.FileQueueBackingStoreFactory.configure(FileQueueBackingStoreFactory.java:41)
"
Bug,QPID-4099,12596408,FailoverBehaviourTest.testFlowControlFlagResetOnFailover fails occasionally on CI,robbie,kwall,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"Test FailoverBehaviourTest.testFlowControlFlagResetOnFailover has been seen to fail on Apache CI.

https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-MMS-TestMatrix/jdk=JDK%201.6%20%28latest%29,label=Ubuntu,profile=java-mms.0-9-1/405/testReport/junit/org.apache.qpid.client.failover/FailoverBehaviourTest/testFlowControlFlagResetOnFailover/

{code}
org.apache.qpid.client.failover.FailoverBehaviourTest.testFlowControlFlagResetOnFailover
Failing for the past 1 build (Since Failed#405 )
Took 13 sec.
Error Message

Unexpected number of sent messages expected:<4> but was:<3>

Stacktrace

junit.framework.AssertionFailedError: Unexpected number of sent messages expected:<4> but was:<3>
	at org.apache.qpid.client.failover.FailoverBehaviourTest.testFlowControlFlagResetOnFailover(FailoverBehaviourTest.java:897)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:243)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:137)
{code}"
Bug,QPID-3985,12554220,BrokerMessagesTest fails depending on locale,rgodfrey,rnfm7avr,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"My locale is de_DE.UTF-8.

Fehlermeldung

Message does not contain expected (1,073,741,824) text :BRK-1011 : Maximum Memory : 1.073.741.824 bytes

Stacktrace

junit.framework.AssertionFailedError: Message does not contain expected (1,073,741,824) text :BRK-1011 : Maximum Memory : 1.073.741.824 bytes
	at org.apache.qpid.server.logging.messages.AbstractTestMessages.validateLogMessage(AbstractTestMessages.java:110)
	at org.apache.qpid.server.logging.messages.AbstractTestMessages.validateLogMessage(AbstractTestMessages.java:68)
	at org.apache.qpid.server.logging.messages.BrokerMessagesTest.testBrokerMemory(BrokerMessagesTest.java:144)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:139)
"
Bug,QPID-4069,12560814,DistributedClientTest.testClientFailsToCreateProducerUsingInvalidSession occasionally seen to fail on CI,robbie,kwall,Closed,Fixed,2017-03-14 20:12,Java,Java Tests,,,,,,,"As with build 311.

https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-BDB-TestMatrix/311/jdk=JDK%201.6%20%28latest%29,label=Ubuntu,profile=java-bdb.0-9-1/testReport/junit/org.apache.qpid.systest.disttest.clientonly/DistributedClientTest/testClientFailsToCreateProducerUsingInvalidSession/

{code}

Error Message

No message received from control queue

Stacktrace

junit.framework.AssertionFailedError: No message received from control queue
	at org.apache.qpid.systest.disttest.clientonly.ControllerQueue.getNext(ControllerQueue.java:72)
	at org.apache.qpid.systest.disttest.clientonly.ControllerQueue.getNext(ControllerQueue.java:64)
	at org.apache.qpid.systest.disttest.clientonly.DistributedClientTest.sendCommandAndValidateResponse(DistributedClientTest.java:216)
	at org.apache.qpid.systest.disttest.clientonly.DistributedClientTest.createTestSession(DistributedClientTest.java:249)
	at org.apache.qpid.systest.disttest.clientonly.DistributedClientTest.createTestSession(DistributedClientTest.java:258)
	at org.apache.qpid.systest.disttest.clientonly.DistributedClientTest.setUp(DistributedClientTest.java:82)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:239)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:137)

{code}"
Bug,QPID-3052,12498513,Java test profiles do not effectively test all AMQP protocol versions,robbie,andrew.kennedy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"The Java test profiles assume that, particularly default one for InVm transports, the 0-10 protocol will fail, causing renegotiation. If 0-10 InVm support is added then the default protocol will use this. It seems to make more sense to specify exactly the version the client and the broker should announce, and force renegotiation explicitly by disabling various protocol versions on the command line when starting an external Java broker. Note that this is not possible to specify for the InVm profiles anyway. Also, the only protocol that is ever tested will be the highest supported by both broker and client, therefore this is AMQP 0-9-1. In order for the tests not to do surprising things when new protocol versions are added, I think that setting versions explicitly is the best idea. I woulsd also like to add an explicit 0-8 test profile for both InVM and external Java brokers, in order to exercise and get coverage on this code.

In future, I recommend that some form of combinatorial profile system be investigated for the test subsystem, allowing the required protocol, broker type and so on to be specified separately."
Bug,QPID-3432,12519270,Test SyncWaitTimeoutDelayTest fails,kwall,orudyy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"The test fails with the following stack trace:

Commit occured even though syncWait timeout is shorter than delay in commit

junit.framework.AssertionFailedError: Commit occured even though syncWait timeout is shorter than delay in commit
at org.apache.qpid.test.client.timeouts.SyncWaitTimeoutDelayTest.test(SyncWaitTimeoutDelayTest.java:61)
at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:243)
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:125)"
Bug,QPID-3712,12536391,QpidBrokerTestCase#isExternalBroker uses incorrect logic to determine if testing with separate Broker process,robbie,kwall,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"QpidBrokerTestCase#isExternalBroker allows system tests to determine if they are running with an external (that is, a separately spawned Broker process), rather than a (Java) Broker within the same VM as the junit test. Logic currently uses expression !_brokerType.equals(""vm""), which is a hang-over from when we used to test using Mina in-VM protocol.

This problem contributed to QPID-3566.



"
Bug,QPID-2609,12464679,MockAMQQueue does not implement getName,robbie,andrew.kennedy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"MockAMQQueue does not implement getName, only getNameShortString"
Bug,QPID-3453,12519994,Test PersistentStoreTest fails on java-bdb-spawn.0-10 profile,kwall,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,JMS AMQP 0-x,,,,,,"The PersistentStoreTest: fails as follows:

connection closed

org.apache.qpid.transport.ConnectionException: connection closed
at org.apache.qpid.transport.Connection.send(Connection.java:358)
at org.apache.qpid.transport.Session.send(Session.java:498)
at org.apache.qpid.transport.Session.invoke(Session.java:707)
at org.apache.qpid.transport.Session.invoke(Session.java:523)
at org.apache.qpid.transport.SessionInvoker.sessionRequestTimeout(SessionInvoker.java:48)
at org.apache.qpid.transport.Session.close(Session.java:917)
at org.apache.qpid.client.AMQSession_0_10.sendClose(AMQSession_0_10.java:388)
at org.apache.qpid.client.AMQSession.close(AMQSession.java:729)
at org.apache.qpid.client.AMQSession.close(AMQSession.java:695)
at org.apache.qpid.client.AMQConnection.closeAllSessions(AMQConnection.java:1147)
at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:1041)
at org.apache.qpid.client.AMQConnection.doClose(AMQConnection.java:1030)

On stopping broker, the underlining transport connection is closed and transport session is put into DETACHED state.
Corresponding AMQSession remains in an open state.
On invoking of AMQConnection#close() method all open AMQSessions are put into closed state and for each AMQSession method sendClose is invoked.
AMQSession_0_10#sendClose(long) calls  close() method for underlying DETACHED transport session which fails because transport connection is already closed.
"
Bug,QPID-2165,12439241,MINANetworkDriverTest fails to socket already in use,aidan,aidan,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Mail from Rajith:


The above test fails occasionally.
It could be due to the port is already in use? perhaps caused by a
previous test not cleaning up properly?
Sorry I haven't had time to dig deeper, but hope the following will help.

Testcase: testBindOpen took 0.15 sec
 Testcase: testBindOpenCloseOpen took 0.004 sec
       Caused an ERROR
 Could not bind to *:2323
 java.net.BindException: Could not bind to *:2323
       at org.apache.qpid.transport.network.mina.MINANetworkDriver.bind(MINANetworkDriver.java:174)
       at org.apache.qpid.transport.network.mina.MINANetworkDriverTest.testBindOpenCloseOpen(MINANetworkDriverTest.java:108)

 Testcase: testBindPortInUse took 0.008 sec
       FAILED
 First bind should not fail
 junit.framework.AssertionFailedError: First bind should not fail
       at org.apache.qpid.transport.network.mina.MINANetworkDriverTest.testBindPortInUse(MINANetworkDriverTest.java:136)
"
Bug,QPID-3768,12538748,Test org.apache.qpid.server.queue.SortedQueueTest.testGetNextWithAck fails sporadically on CI,kwall,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"test profile:java-mms-spawn.0-9-1

Received message with unexpected sorted key value expected:<7> but was:<6>

{code}
Stacktrace
junit.framework.ComparisonFailure: Received message with unexpected sorted key value expected:<7> but was:<6>
at org.apache.qpid.server.queue.SortedQueueTest.receiveAndValidateMessage(SortedQueueTest.java:352)
at org.apache.qpid.server.queue.SortedQueueTest.testGetNextWithAck(SortedQueueTest.java:300)
at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:240)
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:135)

{code}"
Bug,QPID-4311,12607651,[Java Distributed Tests] Publishing client publishes messages infinitely if start delay interval exceeds the maximum duration,robbie,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Performance Tests,,,,,,,Publishing client publishes messages infinitely if start delay interval exceeds the maximum duration
Bug,QPID-4281,12605982,Java tests logging broken because log4j.configuration is not a valid URL,orudyy,philharveyonline,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"A change was made to the log4j configuration used by our unit tests in QPID-4109, such that the log4j.configuration system property that is effective in our unit tests is ""test-profiles/log4j-test.xml"" rather than ""file:///path/to/log4j-test.xml"".

This breaks our unit test logging configuration because Log4J requires that this system property is a valid URL."
Bug,QPID-3566,12529555,ConnectionCloseTest fails with spurious thread creation,robbie,jross,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Testsuite: org.apache.qpid.test.unit.client.connection.ConnectionCloseTest
Tests run: 2, Failures: 1, Errors: 0, Time elapsed: 31.176 sec

Testcase: testSendReceiveClose took 31.009 sec
        FAILED
Spurious thread creation exceeded threshold, 10 threads created.
junit.framework.AssertionFailedError: Spurious thread creation exceeded threshold, 10 threads created.
        at org.apache.qpid.test.unit.client.connection.ConnectionCloseTest.testSendReceiveClose(ConnectionCloseTest.java:97)
        at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:240)
        at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:135)

Testcase: testConnectionCloseOnOnForcibleBrokerStop took 0.164 sec
"
Bug,QPID-3111,12500427,DynamicQueueExchangeCreateTest should check for 404 error code explicitly,robbie,andrew.kennedy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,DynamicQueueExchangeCreateTest checks for a tect string in the message property of a thrown exception. This is brittle and should be replaced with a check for the AMQConstant#NOT_FOUND (404) error code instead.
Bug,QPID-4275,12605688,Java Performance Tests - race condition between closing test consumer and test connection,kwall,philharveyonline,Closed,Fixed,2017-03-14 20:07,Java,Java Performance Tests,,,,,,,"In the new performance test framework, the ParticipantExecutor does these two things at the end when the participant has completed:

# Send the results
# Tell the participant to release its resources.

When this is done in the order listed, the client may receive a TEAR_DOWN_TEST command, which causes the connection to be closed, while it is inside releseResources(). This provokes the client deadlock reported in QPID-4276."
Bug,QPID-4303,12607588,FailoverTest sometimes fails on slower CI boxes.,robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"As shown by:

https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-BDB-TestMatrix/lastCompletedBuild/jdk=JDK%201.6%20%28latest%29,label=Ubuntu,profile=java-bdb.0-9-1/testReport/org.apache.qpid.test.client.failover/FailoverTest/testP2PFailoverTransacted/

Regression

org.apache.qpid.test.client.failover.FailoverTest.testP2PFailoverTransacted
Failing for the past 1 build (Since Failed#521 )
Took 5.5 sec.
add description
Error Message

Message 1 was null!

Stacktrace

junit.framework.AssertionFailedError: Message 1 was null!
	at org.apache.qpid.test.client.failover.FailoverTest.consumeMessages(FailoverTest.java:111)
	at org.apache.qpid.test.client.failover.FailoverTest.runP2PFailover(FailoverTest.java:216)
	at org.apache.qpid.test.client.failover.FailoverTest.testP2PFailover(FailoverTest.java:187)
	at org.apache.qpid.test.client.failover.FailoverTest.testP2PFailoverTransacted(FailoverTest.java:172)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:244)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:137)
"
Bug,QPID-3756,12538320,ManagedConnectionMBeanTest.testChannels fails on 0-10 spawned profiles,kwall,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"We see the following test fail occasionally on the java-mms-spawn.0-10 and java-bdb-spawn.0-10.  The stack trace is as folows:

Error Message

Unexpected number of connection mbeans expected:<0> but was:<1>


{code}

Stacktrace

junit.framework.AssertionFailedError: Unexpected number of connection mbeans expected:<0> but was:<1>
at org.apache.qpid.management.jmx.ManagedConnectionMBeanTest.testChannels(ManagedConnectionMBeanTest.java:125)
at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:240)
at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:135)

{code}"
Bug,QPID-3359,12514190,FailoverMethodTest.testNoFailover unreliable since QPID-2815,robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"FailoverMethodTest used to be inVM tests until QPID-2815, with removal of ivVM, converted the test to use QpidBrokerTestCase.  However, since then we notice this test fails on slower CI boxes.  It turns out the test design is *extremely* sensitive the length of time the broker takes to start up.  If broker startup is slightly too slow, the test fails, and 'spawn' profiles leave behind a broker process (causing subsequent tests to fail).

We will make the test a same-VM test to temporarily avoid the issue.  In long term, test needs redesigned to avoid the issue."
Bug,QPID-3426,12519094,Test org.apache.qpid.test.client.failover.FailoverTest#test4MinuteFailover is broken,robbie,orudyy,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Test org.apache.qpid.test.client.failover.FailoverTest#test4MinuteFailover  fails with message ""Failover did not take long enough"".
It expects that client should reconnect in 4 minutes after failover.

The test connection is configured to have a 4 retry on failover with 1 minute delay between them.
It seems that first reconnection retry is successful and client reconnects in no time which causes test to fail."
Bug,QPID-2125,12437026,FailoverBaseCase launches second broker with QPID_WORK set to /tmp/<alt port> and silently fails to clean up,robbie,robbie,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"FailoverBaseCase launches second broker with QPID_WORK set to /tmp/<alt port> and fails to clean up. Although attempt is made to clear up, the method used is ineffective. Coupled with the QueueBrowser* tests making use of queue names containing the current time in millis, this can lead to repeated runs of the test suite with a persistence store resulting in a large number of queues for the broker to recover on subsequent tests, and eventually leads to test failure due to lengthy startup times."
Bug,QPID-3493,12523534,FailoverMethodTest.testFailoverSingleDelay occasionally fails on slow CI box,kwall,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"Test FailoverMethodTest.testFailoverSingleDelay occasionally fails on an old slow CI box.   The test asserts that the failover should happen in less than 7 seconds, but in some cases the test takes slightly longer.

{code}
org.apache.qpid.server.failover.FailoverMethodTest (1)
TestName: testFailoverSingleDelay Duration: 14.881
Failover took more than 7 seconds:(7584) at org.apache.qpid.server.failover.FailoverMethodTest.testFailoverSingleDelay(FailoverMethodTest.java:133)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:238)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:131)
                            
{code}"
Bug,QPID-3332,12512359,Occasional test failures from TransactionTimeoutTest under default test profile under Jenkins,robbie,kwall,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"We have a longstanding problem that sees occasional test failures from TransactionTimeoutTest under the default test profile under Jenkins CI.  The test failures are:

{code}
junit.framework.AssertionFailedError: Expected 0 but found 1 txn idle messages
	at org.apache.qpid.test.unit.transacted.TransactionTimeoutTestCase.monitor(TransactionTimeoutTestCase.java:197)
	at org.apache.qpid.test.unit.transacted.TransactionTimeoutTest.testProducerOpenCommit(TransactionTimeoutTest.java:86)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:234)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:120)
{code}

and

{code}
junit.framework.AssertionFailedError: Expected 10 but found 6 txn idle messages
	at org.apache.qpid.test.unit.transacted.TransactionTimeoutTestCase.monitor(TransactionTimeoutTestCase.java:201)
	at org.apache.qpid.test.unit.transacted.TransactionTimeoutTest.testProducerIdleRollbackTwice(TransactionTimeoutTest.java:187)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:234)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:120)
{code}

This problem caused the following builds to fail: 146, 147, 148, 152, 161, and 162.

https://builds.apache.org/view/M-R/view/Qpid/job/qpid-java-build/147/
"
Bug,QPID-3635,12532141,AMQQConnectionTest incorrect assumes an order in which the tests are run,robbie,rgodfrey,Closed,Fixed,2017-03-14 20:07,Java,Java Tests,,,,,,,"The AMQConnection test class makes assumptions about the order in which tests are run and is generally just horribly ill-conceived.

For example the test testTopicSessionCreateBrowser() depends upon the initialisation of the member variable _topicSession which is initialised in the test testCreateTopicSession(), and is only still valid since though the test creates new connections in every setUp, it does not tear them down at the end of each test.

Note also that if the creation of _topicSession and _queueSession are moved to setUp then the test testGetChannelID() will fail as it depends on no prior sessions existing and also on a defined policy of assigning channel numbers to sessions (really this test makes no sense at all)."
Bug,QPID-9,12350530,"Missing support for field table types D, T and F",rgreig,aconway,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,"The spec defines these additional types. This area may be in flux so check spec status before implementing:
/ 'D' decimal-value
/ 'T' timestamp
/ 'F' field-table

Needs to be addressed across all languages and the python headers exchange tests should test all types.

The field table also does not support sufficient types of values for JMS support see message thread:

https://amqp.108.redhat.com/servlets/ReadMsg?list=dev&msgNo=169

Possible a possible temporary work around would be to use encoded String values "
Bug,QPID-1082,12396415,Add test case to ensure that config of housekeeping.expiredMessageCheckPeriod to 0 disables housekeeping process,aidan,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,There is no test for disabling the housekeeping threads via the config file. 
Bug,QPID-1524,12410358,AMQPriorityQueueTest message order is non-deterministic [AMQPriorityQueueTest causes NullPointerException],rgodfrey,ritchiem,Closed,Fixed,2017-03-14 20:02,Java,Java Tests,,,,,,,"Summary:
Our CI box has failed this test twice but on looking at a clean test run we get these NPEs to standard error. I'm sure this is not good, however as we have NO logging what so ever in the message delivery path we are unable to say more on when these occured. 

Also as this is a unit test and not a QTC we cannot tell which test caused these NPE.

Exception in thread ""pool-6-thread-1"" java.lang.NullPointerException
        at org.apache.qpid.server.queue.SimpleAMQQueue.attemptDelivery(SimpleAMQQueue.java:1254)
        at org.apache.qpid.server.queue.SimpleAMQQueue.flushSubscription(SimpleAMQQueue.java:1216)
        at org.apache.qpid.server.queue.SimpleAMQQueue$SubFlushRunner.run(SimpleAMQQueue.java:1177)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)
Exception in thread ""pool-10-thread-1"" java.lang.NullPointerException
        at org.apache.qpid.server.queue.SimpleAMQQueue.attemptDelivery(SimpleAMQQueue.java:1254)
        at org.apache.qpid.server.queue.SimpleAMQQueue.flushSubscription(SimpleAMQQueue.java:1216)
        at org.apache.qpid.server.queue.SimpleAMQQueue$SubFlushRunner.run(SimpleAMQQueue.java:1177)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)


Test failure was:
junit.framework.AssertionFailedError: expected:<1> but was:<6>  

The first message was not as expected, the test does not let us know if the message was lost or simply reordered.

Approach:
1) Updating the test to give more details on the loss vs. re-ordering woudl be help understand the failures
2) The NPEs should be resolved as this could cause other issues."
Bug,QPID-252,12359999,[Performance] In PoolingFilter Event objects are created needlessley,rgodfrey,rgodfrey,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,"In org.apache.qpid.pool.PoolingFilter an Event object is created for every io event that occurs.  The event type is then compared against a set of event types (which in practice only ever has one entry) and then the event is either processed synchronously or asynchronously.

Due to the huge numbers of events, the creation and processing of these objects creates a noticeable overhead.

Patch will follow."
Bug,QPID-604,12378756,Potential NullPointerException in FieldTable trace logging,,aidan,Closed,Fixed,2017-03-14 20:02,Java,Java Common,,,,,,,"When logging is set to trace, there's a potential for FieldTable.writeToBuffer to throw an NPE since it doesn't check if _properties is null. This leads to timeouts and other badness."
Bug,QPID-553,12376162,IBM performance tests don't run,,aidan,Closed,Fixed,2017-03-14 20:01,Java,Java Performance Tests,,,,,,,The tests which used the IBM performance harness had rotted slightly over time and didn't run. 
Bug,QPID-1427,12407699,[Java] QueueBrowserDupsOKTest Failure,ritchiem,marnie,Resolved,Fixed,2016-12-09 20:23,Java,Java Tests,,,,,,,"Test: 	testQueueBrowserMsgsRemainOnQueue
Class: 	org.apache.qpid.test.client.QueueBrowserDupsOkTest
	

junit.framework.AssertionFailedError: Message 0 not retrieved from queue  

at org.apache.qpid.test.client.QueueBrowserAutoAckTest.validate(QueueBrowserAutoAckTest.java:334)  

at org.apache.qpid.test.client.QueueBrowserAutoAckTest.testQueueBrowserMsgsRemainOnQueue(QueueBrowserAutoAckTest.java:379)  

at org.apache.qpid.test.utils.QpidTestCase.runBare(QpidTestCase.java:186)  

at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:220)
	
"
Bug,QPID-7108,12944874,[Java Broker] Test BDBHAVirtualHostNodeTest.testIntruderProtection is failing sporadically,,orudyy,Closed,Fixed,2016-06-13 10:27,Java,Java Tests,,,,,,,"The test BDBHAVirtualHostNodeTest.testIntruderProtection tries to remove the permitted node from a list of permitted nodes in order to make it an intruder node.

That it is not allowed as currently on changing of permitted nodes an existing implementation verifies that specified permitted nodes includes all nodes in a group. See changes made in QPID-6090 ( [Java Broker] Prevent removal of existing group nodes from the permitted nodes attribute on VHN).

The test should simply connect an intruder and verify that it cannot start up with intruder present.

Here are the exception details for the test as it is reported in jenkins
{noformat}
The current group node 'localhost:10001' cannot be removed from 'permittedNodes' as its already a group member

Stacktrace

java.lang.IllegalArgumentException: The current group node 'localhost:10001' cannot be removed from 'permittedNodes' as its already a group member
	at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeImpl.validatePermittedNodes(BDBHAVirtualHostNodeImpl.java:1007)
	at org.apache.qpid.server.virtualhostnode.berkeleydb.BDBHAVirtualHostNodeImpl.validateChange(BDBHAVirtualHostNodeImpl.java:185)
	at org.apache.qpid.server.model.AbstractConfiguredObject$23.execute(AbstractConfiguredObject.java:2382)
	at org.apache.qpid.server.model.AbstractConfiguredObject$23.execute(AbstractConfiguredObject.java:2377)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl$TaskLoggingWrapper.execute(TaskExecutorImpl.java:270)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl$CallableWrapper$1.run(TaskExecutorImpl.java:342)
	at java.security.AccessController.doPrivileged(Native Method)
	at javax.security.auth.Subject.doAs(Subject.java:356)
	at org.apache.qpid.server.configuration.updater.TaskExecutorImpl$CallableWrapper.call(TaskExecutorImpl.java:335)
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:745)
{noformat}"
Bug,QPID-6804,12907057,PerfTests potentially underestimate consumtion rate,,lorenz.quack,Resolved,Fixed,2015-11-13 15:12,Java,Java Performance Tests,,,,,,,"In a time-limited setup, the producer stops producing messages after the duration expired.
It is possible that the consumer continues to try to consume messages after this point eventually draining the queue. This means it receives less messages than it could effectively reducing its reported consumption rate.

Producers should continue to produce messages until they are notified by the controller that all consumers are done consuming.
This could happen in the TearDownTest command or in a new StopTest command."
Bug,QPID-6489,12820073,Test FailoverBehaviourTest.testFlowControlFlagResetOnFailover fails because it manages to send more messages than expected before flow is blocked ,kwall,orudyy,Closed,Fixed,2015-05-31 21:48,Java,Java Tests,,,,,,,"Test FailoverBehaviourTest.testFlowControlFlagResetOnFailover expects to send 3 or 4 messages before flow is blocked. However, with new io layer flow command arrives whilst test is sending 5th message:

{noformat}
2015-04-06 08:08:39,404 INFO  [IoReceiver-localhost/127.0.0.1:15672] (qpid.protocol) - RECV: [org.apache.qpid.client.protocol.AMQProtocolHandler@3c32b13f] Frame channelId: 1, bodyFrame: [ChannelFlowBodyImpl: active=false]
2015-04-06 08:08:39,404 DEBUG [IoReceiver-localhost/127.0.0.1:15672] (protocol.AMQProtocolHandler) - (1009955135)Method frame received: [ChannelFlowBodyImpl: active=false]
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (client.BasicMessageProducer_0_8) - Sending content body frames to direct://amq.direct/FailoverBehaviourTest-testFlowControlFlagResetOnFailover/FailoverBehaviourTest-testFlowControlFlagResetOnFailover?routingkey='FailoverBehaviourTest-testFlowControlFlagResetOnFailover'&durable='true'
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (client.BasicMessageProducer_0_8) - Sending content header frame to direct://amq.direct/FailoverBehaviourTest-testFlowControlFlagResetOnFailover/FailoverBehaviourTest-testFlowControlFlagResetOnFailover?routingkey='FailoverBehaviourTest-testFlowControlFlagResetOnFailover'&durable='true'
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (framing.FieldTable) - FieldTable::writeToBuffer: Writing encoded length of 34...
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (framing.FieldTable) - {index=[INT: 4], JMS_QPID_DESTTYPE=[INT: 1]}
2015-04-06 08:08:39,405 INFO  [IoReceiver-localhost/127.0.0.1:15672] (client.AMQSession) - Broker enforced flow control has been enforced
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (qpid.protocol) - SEND: [org.apache.qpid.client.protocol.AMQProtocolHandler@3c32b13f] org.apache.qpid.framing.CompositeAMQDataBlock{ 0=[Frame channelId: 1, bodyFrame: [BasicPublishBodyImpl: ticket=0, exchange=amq.direct, routingKey=FailoverBehaviourTest-testFlowControlFlagResetOnFailover, mandatory=true, immediate=false]] 1=[Frame channelId: 1, bodyFrame: ContentHeaderBody{classId=60, weight=0, bodySize=1024, properties=reply-to = null,propertyFlags = 47312,ApplicationID = null,ClusterID = null,UserId = admin,JMSMessageID = ID:f55c854f-dba5-35d7-8149-d02fadd8865d,JMSCorrelationID = null,JMSDeliveryMode = 2,JMSExpiration = 0,JMSPriority = 4,JMSTimestamp = 1428322119404,JMSType = null}] 2=[Frame channelId: 1, bodyFrame: org.apache.qpid.framing.ContentBody@4d6094ee]}
2015-04-06 08:08:39,405 DEBUG [Thread-3141] (qpid.protocol) - SEND: [org.apache.qpid.client.protocol.AMQProtocolHandler@3c32b13f] Frame channelId: 1, bodyFrame: [TxCommitBody]
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (transport.NonBlockingConnection) - Written 0 bytes
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (transport.NonBlockingConnection) - Read 1254 byte(s)
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.AMQChannel) - RECV[1] BasicPublish[ exchange: amq.direct routingKey: FailoverBehaviourTest-testFlowControlFlagResetOnFailover mandatory: true immediate: false ]
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.BrokerDecoder) - Frame handled in 0 ms.
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (framing.BasicContentHeaderProperties) - Property flags: 47312
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.AMQChannel) - RECV[1] MessageHeader[ properties: {reply-to = null,propertyFlags = 47312,ApplicationID = null,ClusterID = null,UserId = admin,JMSMessageID = ID:f55c854f-dba5-35d7-8149-d02fadd8865d,JMSCorrelationID = null,JMSDeliveryMode = 2,JMSExpiration = 0,JMSPriority = 4,JMSTimestamp = 1428322119404,JMSType = null} bodySize: 1024 ]
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.AMQChannel) - Content header received on channel 1
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.BrokerDecoder) - Frame handled in 0 ms.
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.AMQChannel) - RECV[1] MessageContent[ data: 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000... ] 
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (v0_8.AMQChannel) - 1(395533021) content body received on channel 1
2015-04-06 08:08:39,405 DEBUG [IO-/127.0.0.1:43713] (txn.LocalTransaction) - Enqueue of message number 5 to transaction log. Queue : FailoverBehaviourTest-testFlowControlFlagResetOnFailover
{noformat}

It seems that test needs to be fixed to account that Flow.active=false can arrive with a delay, thus, publishing of 5 messages before flow is blocked should be acceptible. "
Bug,QPID-6059,12737990,Java QMF2 Agent code made some now invalid assumptions about replyTo,,fadams,Closed,Fixed,2014-08-30 9:04,Java,Java Tools,,,,,,,"The Java QMF2 Agent code made some now invalid assumptions about replyTo (it assumed that replyTo addresses would be bound to qmf.default.direct or qmf.default.topic) and used this assumption to optimise replies and work around a bug in older versions of the JMS client that caused spurious exchangeDeclares when invoking send() on the replyTo.

The assumption that was made is still valid for most QMF clients, but there's no reason why a client's reply queue has to be bound to qmf.default.direct or qmf.default.topic.

This fix adds an additional clause to the sendResponse code that falls back to using the actual replyTo Destination if the reply address isn't bound to one of the qmf exchanges.
"
Bug,QPID-5811,12720340,FailoverBehaviourTest.testTransactionRolledBackExceptionThrownOnCommitAfterFailoverOnMessageReceiving failed with unexpected message order,macbean,macbean,Resolved,Fixed,2014-07-22 9:09,Java,Java Tests,,,,,,,"FailoverBehaviourTest.testTransactionRolledBackExceptionThrownOnCommitAfterFailoverOnMessageReceiving failed with unexpected message order, the test appears to consume messages in wrong order after a successful failover.

-------------------------------------------------------------------------------
Test set: org.apache.qpid.client.failover.FailoverBehaviourTest
-------------------------------------------------------------------------------
Tests run: 33, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 156.508 sec <<< FAILURE! - in org.apache.qpid.client.failover.FailoverBehaviourTest
testTransactionRolledBackExceptionThrownOnCommitAfterFailoverOnMessageReceiving(org.apache.qpid.client.failover.FailoverBehaviourTest) Time elapsed: 3.206 sec <<< FAILURE!
junit.framework.ComparisonFailure: Failover is broken! Expected [test message 37] but got [test message 38] expected:<test message 3[7]> but was:<test message 3[8]>
at junit.framework.Assert.assertEquals(Assert.java:100)
at junit.framework.TestCase.assertEquals(TestCase.java:261)
at org.apache.qpid.client.failover.FailoverBehaviourTest.assertReceivedMessage(FailoverBehaviourTest.java:1150)
at org.apache.qpid.client.failover.FailoverBehaviourTest.consumeMessages(FailoverBehaviourTest.java:1120)
at org.apache.qpid.client.failover.FailoverBehaviourTest.consumeMessages(FailoverBehaviourTest.java:1062)
at org.apache.qpid.client.failover.FailoverBehaviourTest.testTransactionRolledBackExceptionThrownOnCommitAfterFailoverOnMessageReceiving(FailoverBehaviourTest.java:256)

"
Bug,QPID-5512,12691016,suppress exception sometimes seen in IoReceiver due to race while closing the socket on Windows,robbie,macbean,Closed,Fixed,2014-06-03 15:35,Java,Java Common,,,,,,,"Potential for read to be performed on an already intentionally closed socket which results in an unexpected exception being seen: SocketException: ""Socket operation on nonsocket: recv failed"".

This causes intermittent ConnectionTest failures due to a race between whether this exception or the one which caused the socket to be closed originally is reported.

Dont think this exception should be reported when it was caused by close already being called. "
Bug,QPID-4014,12556861,System test ConflationQueueTest.testParallelProductionAndConsumption failed,philharveyonline,philharveyonline,Closed,Fixed,2013-05-02 2:30,Java,Java Tests,,,,,,,"Unit test ConflationQueueTest.testParallelProductionAndConsumption has failed on Jenkins at least twice: 

* [Build 206|https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-BDB-TestMatrix/jdk=JDK%201.6%20(latest),label=Ubuntu,profile=java-bdb.0-9-1/206/testReport/org.apache.qpid.server.queue/ConflationQueueTest/testParallelProductionAndConsumption/]
* [Build 291|https://builds.apache.org/job/Qpid-Java-Java-BDB-TestMatrix/291/jdk=JDK%201.6%20(latest),label=Ubuntu,profile=java-bdb.0-9-1/testReport/junit/org.apache.qpid.server.queue/ConflationQueueTest/testParallelProductionAndConsumption/]

This test has previously run successfully.

On first glance, the test doesn't appear to have any inherent race conditions, therefore it is possible that this represents a genuine problem.

In this test, two producers each each 400 messages with alternating conflation key values, followed by special ""shutdown"" messages. A single consumer remembers the latest message for each conflation key value.

Each producer's last few messages should be:
* Message 397 (conflation key '1')
* Message 398 (conflation key '0')
* Message 399 (conflation key '1')
* Shutdown message

The assertion in question checks the last message received for each conflation key value. In this case, the last message with key '1' is message 397, not the expected message 399.

Examination of the test output (attached) indicates that the consumer received message 399 once (it must have been conflated), and that - surprisingly - it arrived *after* the two shutdown messages."
Bug,QPID-1003,12395158,Junit treats Classes ending with Test as testcases,ritchiem,senakafdo,Closed,Fixed,2012-09-17 14:11,Java,Java Tools,,,,,,,Junit treats Classes in test framework ending with Test as testcases
Bug,QPID-4080,12595353,HAClusterWhiteboxTest#testClusterLosingNodeRetainsData fails occasionally on Apache CI,kwall,kwall,Resolved,Fixed,2012-07-31 12:58,Java,Java Tests,,,,,,,"Test HAClusterWhiteboxTest#testClusterLosingNodeRetainsData has been seen to fail on Apache CI (profile java-bdb.0-10).

https://builds.apache.org/view/M-R/view/Qpid/job/Qpid-Java-Java-BDB-TestMatrix/337/jdk=JDK%201.6%20(latest),label=Ubuntu,profile=java-bdb.0-10/testReport/junit/org.apache.qpid.server.store.berkeleydb/HAClusterWhiteboxTest/testClusterLosingNodeRetainsData/

{code}

Error Message

no valid connection obtained
Stacktrace

junit.framework.AssertionFailedError: no valid connection obtained
	at org.apache.qpid.server.store.berkeleydb.HAClusterWhiteboxTest.testClusterLosingNodeRetainsData(HAClusterWhiteboxTest.java:164)
	at org.apache.qpid.test.utils.QpidBrokerTestCase.runBare(QpidBrokerTestCase.java:239)
	at org.apache.qpid.test.utils.QpidTestCase.run(QpidTestCase.java:137)
{code}"
Bug,QPID-3066,12498898,UTF8Test does not run under non VM 0-10 profiles,andrew.kennedy,andrew.kennedy,Closed,Fixed,2011-08-12 7:39,Java,Java Tests,,,,,,,"The UTF8Test uses the 'isBrokerExternal' and 'isBroker010' methods to check whether it should run, rather than relying on the Excludes files. The checks wrongly cause an exception to be thrown on the java.0.10 test profile."
Bug,QPID-2718,12468553,"Update the common.bnd to match client.bnd, release version",robbie,sorins,Closed,Fixed,2010-09-28 9:41,Java,Java Common,,,,,,,"The common.bnd shows ver 0.6.0, whereas the other *.bnd files are at 0.7.0 - we should update to make sure the OSGI bundles are in sync (eg using a 0.6 common with a 0.7 client would result in errors on some code paths). "
Bug,QPID-1499,12409693,IOAcceptor test class has no shutdown method causing test failures on Mac OS X,rhs,ritchiem,Closed,Fixed,2008-12-06 20:10,Java,Java Common,Java Tests,,,,,,"Summary:

The ConnectionTest fails on MacOS X ant test run for a number of reasons.

The mina method AvailablePortFinder.getNextAvailable doesn't appear to get the next available port on MacOSX.

The problem is that each new test in ConnectionTest binds a new server but does not close the old one.

Under linux and windows the IOAcceptor must relinquish the socket but this doesn't occur under Mac OS X.


Solution.:

The IOAcceptor is a small server process for used in testing and example app

However it doesn't have a close method, if we add one then we can add a tearDown method that will clean up the ServerSocket used in the IOAcceptor between tests.
"
Bug,QPID-672,12381780,QpidTestCase fails when running from maven,,andygrove,Closed,Fixed,2008-07-08 15:25,Java,Java Tests,,,,,,,"When running ""mvn install"" the org.apache.qpid.testutil.QpidTestCase class runs and fails because it contains no tests. This is a base class for other tests. Making this class abstract resolves the issue for me."
Bug,QPID-863,12391928,PubSub example has a minor error in the closing logic,rajith,rajith,Closed,Fixed,2008-07-04 3:09,Java,Java Tests,,,,,,,"The Listener class has the following check  - ""while (_finished < 3 && !_failed)""
However there are 4 topics and this loop condition causes the Listener to close after receiving 3 ""termination messages"" instead of 4.
Due to the volume of messages this is mostly unnoticable when run manually.
But this causes an intermittent failure when run with the verify scripts as due to a race condtion sometimes all messages from all 4 topics are received before close."
Bug,QPID-874,12392175,AcknowledgeTest uses wrong method to determine queue count,aidan,aidan,Closed,Fixed,2008-04-01 21:08,Java,Java Tests,,,,,,,"AcknowledgeTest uses the InVM stuff to get at the queue depth, it should use AMQ appropriate things"
Bug,QPID-395,12363889,There needs to be a pause between batches of messages produced by the client to avoid OutOfMemory error,bhupendrab,bhupendrab,Resolved,Fixed,2007-03-08 10:58,Java,Java Performance Tests,,,,,,,"The Mina layer throws OutOfMemoryError if the messages of high size like 100k are sent with non-transacted clients.
To avoid this, a pause of few seconds needs to be set between each batch of messages.
The error is - 

Exception in thread ""Thread-2"" java.lang.OutOfMemoryError: Java heap space
org.apache.mina.filter.codec.ProtocolEncoderException: java.lang.OutOfMemoryError: Java heap space
        at org.apache.mina.filter.codec.ProtocolCodecFilter.filterWrite(ProtocolCodecFilter.java:241)
        at org.apache.mina.common.support.AbstractIoFilterChain.callPreviousFilterWrite(AbstractIoFilterChain.java:573)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1200(AbstractIoFilterChain.java:52)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.filterWrite(AbstractIoFilterChain.java:789)
        at org.apache.mina.common.support.AbstractIoFilterChain$2.filterWrite(AbstractIoFilterChain.java:213)
        at org.apache.mina.common.support.AbstractIoFilterChain.callPreviousFilterWrite(AbstractIoFilterChain.java:573)
        at org.apache.mina.common.support.AbstractIoFilterChain.fireFilterWrite(AbstractIoFilterChain.java:564)
        at org.apache.mina.transport.socket.nio.SocketSessionImpl.write0(SocketSessionImpl.java:186)
        at org.apache.mina.common.support.BaseIoSession.write(BaseIoSession.java:146)
        at org.apache.mina.common.support.BaseIoSession.write(BaseIoSession.java:132)
        at org.apache.qpid.client.protocol.AMQProtocolSession.writeFrame(AMQProtocolSession.java:282)
        at org.apache.qpid.client.protocol.AMQProtocolHandler.writeFrame(AMQProtocolHandler.java:422)
        at org.apache.qpid.client.BasicMessageProducer.sendImpl(BasicMessageProducer.java:508)
        at org.apache.qpid.client.BasicMessageProducer.sendImpl(BasicMessageProducer.java:420)
        at org.apache.qpid.client.BasicMessageProducer.send(BasicMessageProducer.java:297)
        at org.apache.qpid.requestreply.PingPongProducer.sendMessage(PingPongProducer.java:1206)
        at org.apache.qpid.requestreply.PingPongProducer.pingNoWaitForReply(PingPongProducer.java:871)
        at org.apache.qpid.requestreply.PingPongProducer.pingAndWaitForReply(PingPongProducer.java:782)
        at org.apache.qpid.requestreply.PingPongProducer.pingAndWaitForReply(PingPongProducer.java:742)
        at org.apache.qpid.ping.PingAsyncTestPerf.testAsyncPingOk(PingAsyncTestPerf.java:177)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at uk.co.thebadgerset.junit.extensions.AsymptoticTestCase.runTest(AsymptoticTestCase.java:225)
        at junit.framework.TestCase.runBare(TestCase.java:127)
        at junit.framework.TestResult$1.protect(TestResult.java:106)
        at junit.framework.TestResult.runProtected(TestResult.java:124)
        at junit.framework.TestResult.run(TestResult.java:109)
        at uk.co.thebadgerset.junit.extensions.TKTestResult.run(TKTestResult.java:382)
        at junit.framework.TestCase.run(TestCase.java:118)
        at junit.framework.TestSuite.runTest(TestSuite.java:208)
        at junit.framework.TestSuite.run(TestSuite.java:203)
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)
        at junit.extensions.TestDecorator.run(TestDecorator.java:28)
        at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)
        at junit.extensions.TestDecorator.run(TestDecorator.java:28)
        at uk.co.thebadgerset.junit.extensions.AsymptoticTestDecorator.run(AsymptoticTestDecorator.java:159)
        at uk.co.thebadgerset.junit.extensions.ScaledTestDecorator$TestThreadHandler.run(ScaledTestDecorator.java:268)
        at java.lang.Thread.run(Thread.java:595)"
Bug,QPID-6720,12860610,Replace calls to o.a.q.t.Logger with direct calls to SLF4J,lorenz.quack,kwall,Closed,Fixed,2019-10-02 19:21,Java,Java Common,JMS AMQP 0-x,,,,,,"Some client/common classes log via  o.a.q.t.Logger whilst others use SLF4J directly.  Their argument order and message formatting conventions diff, causing unnecessary complexity."
Bug,QPID-7534,13022156,EncodingUtils#readLongAsShortString does not guard against the string containing characters not in the range '0'-'9',kwall,orudyy,Closed,Fixed,2017-11-14 22:01,Java,Java Common,,,,,,,"EncodingUtils#readLongAsShortString does not guard against the string containing characters not in the range '0'-'9'.  Especially, the lines containing the following:
{{result = digit - (byte) '0';}}
{{result += digit - (byte) '0';}}"
Bug,QPID-2607,12464676,Package name typo for CRAMMD5HexInitialiserTest.java,robbie,andrew.kennedy,Closed,Fixed,2017-03-14 20:08,Java,Java Tests,,,,,,,"Change securiity to security in package name.
"
Bug,QPID-2977,12492883,Updated pom files for slf4j,andrew.kennedy,ebourg,Closed,Fixed,2017-03-14 20:08,Java,Java Common,,,,,,,"slf4j has been updated to the version 1.6.1 recently, but the corresponding pom files were not updated in qpid/java/lib/poms. The 1.4.0 poms should be removed and replaced by these:

http://repo1.maven.org/maven2/org/slf4j/slf4j-api/1.6.1/slf4j-api-1.6.1.pom
http://repo1.maven.org/maven2/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.pom
"
Bug,QPID-3631,12531819,"The ""Programming in Apache Qpid"" book does not cover all Java Connection URL options",robbie,fadams,Closed,Fixed,2016-09-06 20:27,Java,Java Documentation,,,,,,,"The ""Programming in Apache Qpid"" book does not cover all Java Connection URL options.

The edition for 0.12 is now pretty comprehensive however it doesn't cover the ""retries"" and related options described in https://cwiki.apache.org/qpid/connection-url-format.html

e.g.

retries
connecttimeout
connectdelay

etc.

The documentation in the cwiki page is much harder to find, so it would be useful if the Programming In Apache Qpid book contained the full consolidated reference information."
Bug,QPID-5604,12698878,Bash scripts doesn't support Cygwin,,jan_bar,Resolved,Fixed,2014-03-14 7:41,Java,Java Tools,,,,,,,"Under Cygwin the scripts like bin/QpidRestAPI.sh pass Cygwin related path to windows program (Java) and also Unix classpath separator. Adding support for Cygwin is easy:
{noformat}
cygwin=false;
case ""`uname`"" in
  CYGWIN*) cygwin=true;;
esac

if $cygwin; then
  CLASSPATH=$(cygpath -wp $CLASSPATH)
fi
{noformat}

Something similar can be done for Mac's Darwin, but I cannot test it."
Bug,QPID-5093,12665254,Adding ASF licence note to a bunch of html/css/js files that were missing it,,fadams,Closed,Fixed,2013-09-08 13:51,Java,Java Tools,,,,,,,A number of html/css/js files were missing ASF licence comments this change adds said licence.
